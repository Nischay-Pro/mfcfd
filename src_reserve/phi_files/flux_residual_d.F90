!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE FLUX_RESIDUAL_MOD_DIFF
  USE PARAMETER_MOD
  USE DATA_STRUCTURE_MOD_DIFF
  USE INTERIOR_FLUXES_MOD_DIFF
  USE WALL_FLUXES_MOD_DIFF
  USE OUTER_FLUXES_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of cal_flux_residual in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: *(point.flux_res)
!   with respect to varying inputs: *(point.delta) *(point.q) *(point.flux_res)
!                *(point.dq) *(point.ddq) *(point.phi1) *(point.phi2)
!   Plus diff mem management of: point.delta:in point.q:in point.flux_res:in
!                point.dq:in point.ddq:in point.phi1:in point.phi2:in
  SUBROUTINE CAL_FLUX_RESIDUAL_D()
    IMPLICIT NONE
    INTEGER :: i, k
    REAL*8 :: gxp(4), gxn(4), gyp(4), gyn(4)
    REAL*8 :: gxpd(4), gxnd(4), gypd(4), gynd(4)
    DO i=1,wall_points
      k = wall_points_index(i)
      CALL WALL_DGX_POS_D(gxp, gxpd, k)
      CALL WALL_DGX_NEG_D(gxn, gxnd, k)
      CALL WALL_DGY_NEG_D(gyn, gynd, k)
      pointd%flux_res(:, k) = gxpd + gxnd + gynd
      point%flux_res(:, k) = gxp + gxn + gyn
      pointd%flux_res(:, k) = 2.0d0*(pointd%delta(k)*point%flux_res(:, k&
&       )+point%delta(k)*pointd%flux_res(:, k))
      point%flux_res(:, k) = 2.0d0*point%delta(k)*point%flux_res(:, k)
    END DO
    DO i=1,outer_points
      k = outer_points_index(i)
      CALL OUTER_DGX_POS_D(gxp, gxpd, k)
      CALL OUTER_DGX_NEG_D(gxn, gxnd, k)
      CALL OUTER_DGY_POS_D(gyp, gypd, k)
      pointd%flux_res(:, k) = pointd%delta(k)*(gxp+gxn+gyp) + point%&
&       delta(k)*(gxpd+gxnd+gypd)
      point%flux_res(:, k) = point%delta(k)*(gxp+gxn+gyp)
    END DO
    DO i=1,interior_points
      k = interior_points_index(i)
      CALL INTERIOR_DGX_POS_D(gxp, gxpd, k)
      CALL INTERIOR_DGX_NEG_D(gxn, gxnd, k)
      CALL INTERIOR_DGY_POS_D(gyp, gypd, k)
      CALL INTERIOR_DGY_NEG_D(gyn, gynd, k)
      pointd%flux_res(:, k) = pointd%delta(k)*(gxp+gxn+gyp+gyn) + point%&
&       delta(k)*(gxpd+gxnd+gypd+gynd)
      point%flux_res(:, k) = point%delta(k)*(gxp+gxn+gyp+gyn)
    END DO
  END SUBROUTINE CAL_FLUX_RESIDUAL_D

  SUBROUTINE CAL_FLUX_RESIDUAL()
    IMPLICIT NONE
    INTEGER :: i, k
    REAL*8 :: gxp(4), gxn(4), gyp(4), gyn(4)
    DO i=1,wall_points
      k = wall_points_index(i)
      CALL WALL_DGX_POS(gxp, k)
      CALL WALL_DGX_NEG(gxn, k)
      CALL WALL_DGY_NEG(gyn, k)
      point%flux_res(:, k) = gxp + gxn + gyn
      point%flux_res(:, k) = 2.0d0*point%delta(k)*point%flux_res(:, k)
    END DO
    DO i=1,outer_points
      k = outer_points_index(i)
      CALL OUTER_DGX_POS(gxp, k)
      CALL OUTER_DGX_NEG(gxn, k)
      CALL OUTER_DGY_POS(gyp, k)
      point%flux_res(:, k) = point%delta(k)*(gxp+gxn+gyp)
    END DO
    DO i=1,interior_points
      k = interior_points_index(i)
      CALL INTERIOR_DGX_POS(gxp, k)
      CALL INTERIOR_DGX_NEG(gxn, k)
      CALL INTERIOR_DGY_POS(gyp, k)
      CALL INTERIOR_DGY_NEG(gyn, k)
      point%flux_res(:, k) = point%delta(k)*(gxp+gxn+gyp+gyn)
    END DO
  END SUBROUTINE CAL_FLUX_RESIDUAL

END MODULE FLUX_RESIDUAL_MOD_DIFF

