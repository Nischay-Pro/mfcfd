!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE COMPUTE_ENSTROPHY_MOD_DIFF
! #include <petsc/finclude/petscsys.h>
  USE DATA_STRUCTURE_MOD_DIFF
  USE PETSC_DATA_STRUCTURE_MOD
  IMPLICIT NONE

CONTAINS
!  Differentiation of compute_enstrophy in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: total_enstrophy *(point.vorticity_sqr)
!   with respect to varying inputs: *(point.x) *(point.y) *(point.prim)
!                *(point.vorticity_sqr)
!   Plus diff mem management of: point.x:in point.y:in point.prim:in
!                point.vorticity_sqr:in
  SUBROUTINE COMPUTE_ENSTROPHY_D()
    IMPLICIT NONE
! call MPI_Allreduce(total_enstrophy, gtotal_enstrophy , 1, &
! & MPI_DOUBLE, MPI_SUM, PETSC_COMM_WORLD, ierr)
! if(rank == 0) then
!write(*,*)"total enstrophy :", gtotal_enstrophy
! end if
    INTEGER :: i, k, r, nbh
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_id, y_id, x_kd, y_kd
    REAL*8 :: delx, dely, dist, weights
    REAL*8 :: delxd, delyd, distd, weightsd
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrd, sum_dely_sqrd, sum_delx_delyd
    REAL*8 :: sum_delx_delu1, sum_delx_delu2, sum_dely_delu1, &
&   sum_dely_delu2
    REAL*8 :: sum_delx_delu1d, sum_delx_delu2d, sum_dely_delu1d, &
&   sum_dely_delu2d
    REAL*8 :: det
    REAL*8 :: detd
    REAL*8 :: one_by_det
    REAL*8 :: one_by_detd
    REAL*8 :: du1_dy, du2_dx, temp
    REAL*8 :: du1_dyd, du2_dxd, tempd
    REAL*8 :: gtotal_enstrophy
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1d
! PetscErrorCode :: ierr
    total_enstrophy = 0.d0
    total_enstrophyd = 0.0_8
    DO i=1,local_points
      x_id = pointd%x(i)
      x_i = point%x(i)
      y_id = pointd%y(i)
      y_i = point%y(i)
      sum_delx_sqr = 0.d0
      sum_dely_sqr = 0.d0
      sum_delx_dely = 0.d0
      sum_delx_delu1 = 0.d0
      sum_dely_delu1 = 0.d0
      sum_delx_delu2 = 0.d0
      sum_dely_delu2 = 0.d0
      sum_delx_delyd = 0.0_8
      sum_delx_sqrd = 0.0_8
      sum_dely_delu1d = 0.0_8
      sum_dely_delu2d = 0.0_8
      sum_dely_sqrd = 0.0_8
      sum_delx_delu1d = 0.0_8
      sum_delx_delu2d = 0.0_8
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        x_kd = pointd%x(nbh)
        x_k = point%x(nbh)
        y_kd = pointd%y(nbh)
        y_k = point%y(nbh)
        delxd = x_kd - x_id
        delx = x_k - x_i
        delyd = y_kd - y_id
        dely = y_k - y_i
        arg1d = delxd*delx + delx*delxd + delyd*dely + dely*delyd
        arg1 = delx*delx + dely*dely
        IF (arg1 .EQ. 0.0) THEN
          distd = 0.0_8
        ELSE
          distd = arg1d/(2.D0*DSQRT(arg1))
        END IF
        dist = DSQRT(arg1)
        IF (dist .GT. 0.0 .OR. (dist .LT. 0.0 .AND. power .EQ. INT(power&
&           ))) THEN
          weightsd = power*dist**(power-1)*distd
        ELSE IF (dist .EQ. 0.0 .AND. power .EQ. 1.0) THEN
          weightsd = distd
        ELSE
          weightsd = 0.0
        END IF
        weights = dist**power
        sum_delx_sqrd = sum_delx_sqrd + (delxd*delx+delx*delxd)*weights &
&         + delx**2*weightsd
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqrd = sum_dely_sqrd + (delyd*dely+dely*delyd)*weights &
&         + dely**2*weightsd
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_delyd = sum_delx_delyd + (delxd*dely+delx*delyd)*&
&         weights + delx*dely*weightsd
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        sum_delx_delu1d = sum_delx_delu1d + (weightsd*delx+weights*delxd&
&         )*(point%prim(2, nbh)-point%prim(2, i)) + weights*delx*(pointd&
&         %prim(2, nbh)-pointd%prim(2, i))
        sum_delx_delu1 = sum_delx_delu1 + weights*delx*(point%prim(2, &
&         nbh)-point%prim(2, i))
        sum_delx_delu2d = sum_delx_delu2d + (weightsd*delx+weights*delxd&
&         )*(point%prim(3, nbh)-point%prim(3, i)) + weights*delx*(pointd&
&         %prim(3, nbh)-pointd%prim(3, i))
        sum_delx_delu2 = sum_delx_delu2 + weights*delx*(point%prim(3, &
&         nbh)-point%prim(3, i))
        sum_dely_delu1d = sum_dely_delu1d + (weightsd*dely+weights*delyd&
&         )*(point%prim(2, nbh)-point%prim(2, i)) + weights*dely*(pointd&
&         %prim(2, nbh)-pointd%prim(2, i))
        sum_dely_delu1 = sum_dely_delu1 + weights*dely*(point%prim(2, &
&         nbh)-point%prim(2, i))
        sum_dely_delu2d = sum_dely_delu2d + (weightsd*dely+weights*delyd&
&         )*(point%prim(3, nbh)-point%prim(3, i)) + weights*dely*(pointd&
&         %prim(3, nbh)-pointd%prim(3, i))
        sum_dely_delu2 = sum_dely_delu2 + weights*dely*(point%prim(3, &
&         nbh)-point%prim(3, i))
      END DO
      detd = sum_delx_sqrd*sum_dely_sqr + sum_delx_sqr*sum_dely_sqrd - &
&       sum_delx_delyd*sum_delx_dely - sum_delx_dely*sum_delx_delyd
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      one_by_detd = -(detd/det**2)
      one_by_det = 1.0d0/det
      du2_dxd = (sum_delx_delu2d*sum_dely_sqr+sum_delx_delu2*&
&       sum_dely_sqrd-sum_dely_delu2d*sum_delx_dely-sum_dely_delu2*&
&       sum_delx_delyd)*one_by_det + (sum_delx_delu2*sum_dely_sqr-&
&       sum_dely_delu2*sum_delx_dely)*one_by_detd
      du2_dx = (sum_delx_delu2*sum_dely_sqr-sum_dely_delu2*sum_delx_dely&
&       )*one_by_det
      du1_dyd = (sum_dely_delu1d*sum_delx_sqr+sum_dely_delu1*&
&       sum_delx_sqrd-sum_delx_delu1d*sum_delx_dely-sum_delx_delu1*&
&       sum_delx_delyd)*one_by_det + (sum_dely_delu1*sum_delx_sqr-&
&       sum_delx_delu1*sum_delx_dely)*one_by_detd
      du1_dy = (sum_dely_delu1*sum_delx_sqr-sum_delx_delu1*sum_delx_dely&
&       )*one_by_det
      tempd = du2_dxd - du1_dyd
      temp = du2_dx - du1_dy
      point%vorticity(i) = temp
      pointd%vorticity_sqr(i) = tempd*temp + temp*tempd
      point%vorticity_sqr(i) = temp*temp
      total_enstrophyd = total_enstrophyd + pointd%vorticity_sqr(i)
      total_enstrophy = total_enstrophy + point%vorticity_sqr(i)
    END DO
  END SUBROUTINE COMPUTE_ENSTROPHY_D

  SUBROUTINE COMPUTE_ENSTROPHY()
    IMPLICIT NONE
! call MPI_Allreduce(total_enstrophy, gtotal_enstrophy , 1, &
! & MPI_DOUBLE, MPI_SUM, PETSC_COMM_WORLD, ierr)
! if(rank == 0) then
!write(*,*)"total enstrophy :", gtotal_enstrophy
! end if
    INTEGER :: i, k, r, nbh
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: delx, dely, dist, weights
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delu1, sum_delx_delu2, sum_dely_delu1, &
&   sum_dely_delu2
    REAL*8 :: det
    REAL*8 :: one_by_det
    REAL*8 :: du1_dy, du2_dx, temp
    REAL*8 :: gtotal_enstrophy
    INTRINSIC DSQRT
    REAL*8 :: arg1
! PetscErrorCode :: ierr
    total_enstrophy = 0.d0
    DO i=1,local_points
      x_i = point%x(i)
      y_i = point%y(i)
      sum_delx_sqr = 0.d0
      sum_dely_sqr = 0.d0
      sum_delx_dely = 0.d0
      sum_delx_delu1 = 0.d0
      sum_dely_delu1 = 0.d0
      sum_delx_delu2 = 0.d0
      sum_dely_delu2 = 0.d0
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        x_k = point%x(nbh)
        y_k = point%y(nbh)
        delx = x_k - x_i
        dely = y_k - y_i
        arg1 = delx*delx + dely*dely
        dist = DSQRT(arg1)
        weights = dist**power
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        sum_delx_delu1 = sum_delx_delu1 + weights*delx*(point%prim(2, &
&         nbh)-point%prim(2, i))
        sum_delx_delu2 = sum_delx_delu2 + weights*delx*(point%prim(3, &
&         nbh)-point%prim(3, i))
        sum_dely_delu1 = sum_dely_delu1 + weights*dely*(point%prim(2, &
&         nbh)-point%prim(2, i))
        sum_dely_delu2 = sum_dely_delu2 + weights*dely*(point%prim(3, &
&         nbh)-point%prim(3, i))
      END DO
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      one_by_det = 1.0d0/det
      du2_dx = (sum_delx_delu2*sum_dely_sqr-sum_dely_delu2*sum_delx_dely&
&       )*one_by_det
      du1_dy = (sum_dely_delu1*sum_delx_sqr-sum_delx_delu1*sum_delx_dely&
&       )*one_by_det
      temp = du2_dx - du1_dy
      point%vorticity(i) = temp
      point%vorticity_sqr(i) = temp*temp
      total_enstrophy = total_enstrophy + point%vorticity_sqr(i)
    END DO
  END SUBROUTINE COMPUTE_ENSTROPHY

END MODULE COMPUTE_ENSTROPHY_MOD_DIFF

