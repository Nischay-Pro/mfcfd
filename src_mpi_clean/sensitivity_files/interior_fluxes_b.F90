!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
MODULE INTERIOR_FLUXES_MOD_DIFF
!	First written on 14.10.2016.
!	updated on Sep 23, 2017
!	
  USE DATA_STRUCTURE_MOD_DIFF
  USE SPLIT_FLUXES_MOD_DIFF
  USE Q_VARIABLES_MOD_DIFF
  USE LIMITERS_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of interior_dgx_pos in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: *(point.x) *(point.y) *(point.nx)
!                *(point.ny) *(point.q) *(point.dq) *(point.qm)
!                g
!   with respect to varying inputs: *(point.x) *(point.y) *(point.nx)
!                *(point.ny) *(point.q) *(point.dq) *(point.qm)
!   Plus diff mem management of: point.x:in point.y:in point.nx:in
!                point.ny:in point.q:in point.dq:in point.qm:in
!	This subroutine evaluates the interior flux derivative dGx_pos
  SUBROUTINE INTERIOR_DGX_POS_B(g, gb, i)
    USE DIFFSIZES
!  Hint: ISIZE1OFtemp should be the size of dimension 1 of array temp
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txb, tyb, nxb, nyb
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxb, delyb, detb, one_by_detb
    REAL*8 :: dels, deln
    REAL*8 :: delsb, delnb
!		
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: dist, weights
    REAL*8 :: distb, weightsb
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_ib(4), phi_kb(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsb, deln_weightsb
    REAL*8 :: maxi(4), mini(4)
    INTRINSIC DSQRT
    REAL*8 :: tempb
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb0
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb1
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb2
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      CALL PUSHREAL8(dist)
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL PUSHREAL8ARRAY(phi_i, 4)
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL PUSHREAL8ARRAY(phi_k, 4)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_i, 4)
      CALL FLUX_GXP(g_i, nx, ny, u1, u2, rho, pr)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_k, 4)
      CALL FLUX_GXP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    tempb4 = one_by_det*gb
    one_by_detb = SUM((sum_delx_delf*sum_dely_sqr-sum_dely_delf*&
&     sum_delx_dely)*gb)
    sum_delx_delfb = sum_dely_sqr*tempb4
    sum_dely_delfb = -(sum_delx_dely*tempb4)
    detb = -(one_by_detb/det**2)
    sum_dely_sqrb = SUM(sum_delx_delf*tempb4) + sum_delx_sqr*detb
    sum_delx_delyb = -SUM(sum_dely_delf*tempb4) - 2*sum_delx_dely*detb
    sum_delx_sqrb = sum_dely_sqr*detb
    txb = 0.0_8
    tyb = 0.0_8
    nxb = 0.0_8
    y_ib = 0.0_8
    nyb = 0.0_8
    g_ib = 0.0_8
    g_kb = 0.0_8
    x_ib = 0.0_8
    phi_ib = 0.0_8
    phi_kb = 0.0_8
    DO j=point%xpos_nbhs(i),1,-1
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      delx = x_k - x_i
      y_k = point%y(k)
      dely = y_k - y_i
      deln = delx*nx + dely*ny
      weights = dist**power
      deln_weights = deln*weights
      dels = delx*tx + dely*ty
      deln_weightsb = SUM((g_k-g_i)*sum_dely_delfb) + dels*&
&       sum_delx_delyb + deln*sum_dely_sqrb
      dels_weights = dels*weights
      g_kb = g_kb + deln_weights*sum_dely_delfb + dels_weights*&
&       sum_delx_delfb
      g_ib = g_ib - deln_weights*sum_dely_delfb - dels_weights*&
&       sum_delx_delfb
      dels_weightsb = SUM((g_k-g_i)*sum_delx_delfb) + dels*sum_delx_sqrb
      CALL POPREAL8ARRAY(g_k, 4)
      CALL FLUX_GXP_B(g_k, g_kb, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_k, qtilde_kb, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPREAL8ARRAY(g_i, 4)
      CALL FLUX_GXP_B(g_i, g_ib, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_i, qtilde_ib, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      phi_kb = phi_kb - (delx*point%dq(1, :, k)+dely*point%dq(2, :, k))*&
&       0.5d0*qtilde_kb
      tempb3 = -(phi_k*0.5d0*qtilde_kb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb3
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb3
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      phi_ib = phi_ib - (delx*point%dq(1, :, i)+dely*point%dq(2, :, i))*&
&       0.5d0*qtilde_ib
      tempb2 = -(phi_i*0.5d0*qtilde_ib)
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb2
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb2
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL POPREAL8ARRAY(phi_k, 4)
      CALL VENKAT_LIMITER_B(qtilde_k, qtilde_kb, phi_k, phi_kb, k)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL POPREAL8ARRAY(phi_i, 4)
      CALL VENKAT_LIMITER_B(qtilde_i, qtilde_ib, phi_i, phi_ib, i)
      CALL POPREAL8ARRAY(qtilde_k, 4)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      tempb1 = -(0.5d0*qtilde_kb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb1
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb1
      CALL POPREAL8ARRAY(qtilde_i, 4)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      tempb0 = -(0.5d0*qtilde_ib)
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb0
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb0
      weightsb = deln*deln_weightsb + dels*dels_weightsb
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        distb = 0.0_8
      ELSE
        distb = power*dist**(power-1)*weightsb
      END IF
      CALL POPREAL8(dist)
      IF (dels**2 + deln**2 .EQ. 0.0) THEN
        tempb = 0.0_8
      ELSE
        tempb = distb/(2.D0*DSQRT(dels**2+deln**2))
      END IF
      delsb = deln_weights*sum_delx_delyb + dels_weights*sum_delx_sqrb +&
&       weights*dels_weightsb + 2*dels*tempb
      delnb = deln_weights*sum_dely_sqrb + weights*deln_weightsb + 2*&
&       deln*tempb
      delxb = SUM(point%dq(1, :, k)*tempb3) + SUM(point%dq(1, :, i)*&
&       tempb2) + SUM(point%dq(1, :, k)*tempb1) + SUM(point%dq(1, :, i)*&
&       tempb0) + nx*delnb + tx*delsb
      delyb = SUM(point%dq(2, :, k)*tempb3) + SUM(point%dq(2, :, i)*&
&       tempb2) + SUM(point%dq(2, :, k)*tempb1) + SUM(point%dq(2, :, i)*&
&       tempb0) + ny*delnb + ty*delsb
      nxb = nxb + delx*delnb
      nyb = nyb + dely*delnb
      txb = txb + delx*delsb
      tyb = tyb + dely*delsb
      y_kb = delyb
      y_ib = y_ib - delyb
      x_kb = delxb
      x_ib = x_ib - delxb
      pointb%y(k) = pointb%y(k) + y_kb
      pointb%x(k) = pointb%x(k) + x_kb
    END DO
    nxb = nxb - tyb
    nyb = nyb + txb
    pointb%ny(i) = pointb%ny(i) + nyb
    pointb%nx(i) = pointb%nx(i) + nxb
    pointb%y(i) = pointb%y(i) + y_ib
    pointb%x(i) = pointb%x(i) + x_ib
  END SUBROUTINE INTERIOR_DGX_POS_B

!	This subroutine evaluates the interior flux derivative dGx_pos
  SUBROUTINE INTERIOR_DGX_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
!		
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: maxi(4), mini(4)
    INTRINSIC DSQRT
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GXP(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GXP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGX_POS

!  Differentiation of interior_dgx_neg in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: *(point.x) *(point.y) *(point.nx)
!                *(point.ny) *(point.q) *(point.dq) *(point.qm)
!                g
!   with respect to varying inputs: *(point.x) *(point.y) *(point.nx)
!                *(point.ny) *(point.q) *(point.dq) *(point.qm)
!   Plus diff mem management of: point.x:in point.y:in point.nx:in
!                point.ny:in point.q:in point.dq:in point.qm:in
!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGX_NEG_B(g, gb, i)
    USE DIFFSIZES
!  Hint: ISIZE1OFtemp should be the size of dimension 1 of array temp
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txb, tyb, nxb, nyb
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxb, delyb, detb, one_by_detb
    REAL*8 :: dels, deln
    REAL*8 :: delsb, delnb
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: dist, weights
    REAL*8 :: distb, weightsb
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_ib(4), phi_kb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsb, deln_weightsb
    INTRINSIC DSQRT
    REAL*8 :: tempb
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb0
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb1
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb2
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      CALL PUSHREAL8(dist)
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL PUSHREAL8ARRAY(phi_i, 4)
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL PUSHREAL8ARRAY(phi_k, 4)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_i, 4)
      CALL FLUX_GXN(g_i, nx, ny, u1, u2, rho, pr)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_k, 4)
      CALL FLUX_GXN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    tempb4 = one_by_det*gb
    one_by_detb = SUM((sum_delx_delf*sum_dely_sqr-sum_dely_delf*&
&     sum_delx_dely)*gb)
    sum_delx_delfb = sum_dely_sqr*tempb4
    sum_dely_delfb = -(sum_delx_dely*tempb4)
    detb = -(one_by_detb/det**2)
    sum_dely_sqrb = SUM(sum_delx_delf*tempb4) + sum_delx_sqr*detb
    sum_delx_delyb = -SUM(sum_dely_delf*tempb4) - 2*sum_delx_dely*detb
    sum_delx_sqrb = sum_dely_sqr*detb
    txb = 0.0_8
    tyb = 0.0_8
    nxb = 0.0_8
    nyb = 0.0_8
    y_ib = 0.0_8
    g_ib = 0.0_8
    g_kb = 0.0_8
    x_ib = 0.0_8
    phi_ib = 0.0_8
    phi_kb = 0.0_8
    DO j=point%xneg_nbhs(i),1,-1
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      delx = x_k - x_i
      y_k = point%y(k)
      dely = y_k - y_i
      deln = delx*nx + dely*ny
      weights = dist**power
      deln_weights = deln*weights
      dels = delx*tx + dely*ty
      deln_weightsb = SUM((g_k-g_i)*sum_dely_delfb) + dels*&
&       sum_delx_delyb + deln*sum_dely_sqrb
      dels_weights = dels*weights
      g_kb = g_kb + deln_weights*sum_dely_delfb + dels_weights*&
&       sum_delx_delfb
      g_ib = g_ib - deln_weights*sum_dely_delfb - dels_weights*&
&       sum_delx_delfb
      dels_weightsb = SUM((g_k-g_i)*sum_delx_delfb) + dels*sum_delx_sqrb
      CALL POPREAL8ARRAY(g_k, 4)
      CALL FLUX_GXN_B(g_k, g_kb, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_k, qtilde_kb, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPREAL8ARRAY(g_i, 4)
      CALL FLUX_GXN_B(g_i, g_ib, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_i, qtilde_ib, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      phi_kb = phi_kb - (delx*point%dq(1, :, k)+dely*point%dq(2, :, k))*&
&       0.5d0*qtilde_kb
      tempb3 = -(phi_k*0.5d0*qtilde_kb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb3
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb3
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      phi_ib = phi_ib - (delx*point%dq(1, :, i)+dely*point%dq(2, :, i))*&
&       0.5d0*qtilde_ib
      tempb2 = -(phi_i*0.5d0*qtilde_ib)
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb2
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb2
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL POPREAL8ARRAY(phi_k, 4)
      CALL VENKAT_LIMITER_B(qtilde_k, qtilde_kb, phi_k, phi_kb, k)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL POPREAL8ARRAY(phi_i, 4)
      CALL VENKAT_LIMITER_B(qtilde_i, qtilde_ib, phi_i, phi_ib, i)
      CALL POPREAL8ARRAY(qtilde_k, 4)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      tempb1 = -(0.5d0*qtilde_kb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb1
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb1
      CALL POPREAL8ARRAY(qtilde_i, 4)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      tempb0 = -(0.5d0*qtilde_ib)
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb0
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb0
      weightsb = deln*deln_weightsb + dels*dels_weightsb
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        distb = 0.0_8
      ELSE
        distb = power*dist**(power-1)*weightsb
      END IF
      CALL POPREAL8(dist)
      IF (dels**2 + deln**2 .EQ. 0.0) THEN
        tempb = 0.0_8
      ELSE
        tempb = distb/(2.D0*DSQRT(dels**2+deln**2))
      END IF
      delsb = deln_weights*sum_delx_delyb + dels_weights*sum_delx_sqrb +&
&       weights*dels_weightsb + 2*dels*tempb
      delnb = deln_weights*sum_dely_sqrb + weights*deln_weightsb + 2*&
&       deln*tempb
      delxb = SUM(point%dq(1, :, k)*tempb3) + SUM(point%dq(1, :, i)*&
&       tempb2) + SUM(point%dq(1, :, k)*tempb1) + SUM(point%dq(1, :, i)*&
&       tempb0) + nx*delnb + tx*delsb
      delyb = SUM(point%dq(2, :, k)*tempb3) + SUM(point%dq(2, :, i)*&
&       tempb2) + SUM(point%dq(2, :, k)*tempb1) + SUM(point%dq(2, :, i)*&
&       tempb0) + ny*delnb + ty*delsb
      nxb = nxb + delx*delnb
      nyb = nyb + dely*delnb
      txb = txb + delx*delsb
      tyb = tyb + dely*delsb
      y_kb = delyb
      y_ib = y_ib - delyb
      x_kb = delxb
      x_ib = x_ib - delxb
      pointb%y(k) = pointb%y(k) + y_kb
      pointb%x(k) = pointb%x(k) + x_kb
    END DO
    nxb = nxb - tyb
    nyb = nyb + txb
    pointb%ny(i) = pointb%ny(i) + nyb
    pointb%nx(i) = pointb%nx(i) + nxb
    pointb%y(i) = pointb%y(i) + y_ib
    pointb%x(i) = pointb%x(i) + x_ib
  END SUBROUTINE INTERIOR_DGX_NEG_B

!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGX_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GXN(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GXN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGX_NEG

!  Differentiation of interior_dgy_pos in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: *(point.x) *(point.y) *(point.nx)
!                *(point.ny) *(point.q) *(point.dq) *(point.qm)
!                g
!   with respect to varying inputs: *(point.x) *(point.y) *(point.nx)
!                *(point.ny) *(point.q) *(point.dq) *(point.qm)
!   Plus diff mem management of: point.x:in point.y:in point.nx:in
!                point.ny:in point.q:in point.dq:in point.qm:in
!	This subroutine evaluates the interior flux derivative dGx_neg
!
!
  SUBROUTINE INTERIOR_DGY_POS_B(g, gb, i)
    USE DIFFSIZES
!  Hint: ISIZE1OFtemp should be the size of dimension 1 of array temp
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txb, tyb, nxb, nyb
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxb, delyb, detb, one_by_detb
    REAL*8 :: dels, deln
    REAL*8 :: delsb, delnb
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: dist, weights
    REAL*8 :: distb, weightsb
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_ib(4), phi_kb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsb, deln_weightsb
    INTRINSIC DSQRT
    REAL*8 :: tempb
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb0
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb1
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb2
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%ypos_nbhs(i)
      k = point%ypos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      CALL PUSHREAL8(dist)
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL PUSHREAL8ARRAY(phi_i, 4)
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL PUSHREAL8ARRAY(phi_k, 4)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_i, 4)
      CALL FLUX_GYP(g_i, nx, ny, u1, u2, rho, pr)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_k, 4)
      CALL FLUX_GYP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    tempb4 = one_by_det*gb
    one_by_detb = SUM((sum_dely_delf*sum_delx_sqr-sum_delx_delf*&
&     sum_delx_dely)*gb)
    sum_dely_delfb = sum_delx_sqr*tempb4
    sum_delx_delfb = -(sum_delx_dely*tempb4)
    detb = -(one_by_detb/det**2)
    sum_delx_sqrb = SUM(sum_dely_delf*tempb4) + sum_dely_sqr*detb
    sum_delx_delyb = -SUM(sum_delx_delf*tempb4) - 2*sum_delx_dely*detb
    sum_dely_sqrb = sum_delx_sqr*detb
    txb = 0.0_8
    tyb = 0.0_8
    nxb = 0.0_8
    nyb = 0.0_8
    y_ib = 0.0_8
    g_ib = 0.0_8
    g_kb = 0.0_8
    x_ib = 0.0_8
    phi_ib = 0.0_8
    phi_kb = 0.0_8
    DO j=point%ypos_nbhs(i),1,-1
      k = point%ypos_conn(i, j)
      x_k = point%x(k)
      delx = x_k - x_i
      y_k = point%y(k)
      dely = y_k - y_i
      deln = delx*nx + dely*ny
      weights = dist**power
      deln_weights = deln*weights
      dels = delx*tx + dely*ty
      deln_weightsb = SUM((g_k-g_i)*sum_dely_delfb) + dels*&
&       sum_delx_delyb + deln*sum_dely_sqrb
      dels_weights = dels*weights
      g_kb = g_kb + deln_weights*sum_dely_delfb + dels_weights*&
&       sum_delx_delfb
      g_ib = g_ib - deln_weights*sum_dely_delfb - dels_weights*&
&       sum_delx_delfb
      dels_weightsb = SUM((g_k-g_i)*sum_delx_delfb) + dels*sum_delx_sqrb
      CALL POPREAL8ARRAY(g_k, 4)
      CALL FLUX_GYP_B(g_k, g_kb, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_k, qtilde_kb, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPREAL8ARRAY(g_i, 4)
      CALL FLUX_GYP_B(g_i, g_ib, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_i, qtilde_ib, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      phi_kb = phi_kb - (delx*point%dq(1, :, k)+dely*point%dq(2, :, k))*&
&       0.5d0*qtilde_kb
      tempb3 = -(phi_k*0.5d0*qtilde_kb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb3
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb3
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      phi_ib = phi_ib - (delx*point%dq(1, :, i)+dely*point%dq(2, :, i))*&
&       0.5d0*qtilde_ib
      tempb2 = -(phi_i*0.5d0*qtilde_ib)
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb2
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb2
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL POPREAL8ARRAY(phi_k, 4)
      CALL VENKAT_LIMITER_B(qtilde_k, qtilde_kb, phi_k, phi_kb, k)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL POPREAL8ARRAY(phi_i, 4)
      CALL VENKAT_LIMITER_B(qtilde_i, qtilde_ib, phi_i, phi_ib, i)
      CALL POPREAL8ARRAY(qtilde_k, 4)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      tempb1 = -(0.5d0*qtilde_kb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb1
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb1
      CALL POPREAL8ARRAY(qtilde_i, 4)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      tempb0 = -(0.5d0*qtilde_ib)
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb0
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb0
      weightsb = deln*deln_weightsb + dels*dels_weightsb
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        distb = 0.0_8
      ELSE
        distb = power*dist**(power-1)*weightsb
      END IF
      CALL POPREAL8(dist)
      IF (dels**2 + deln**2 .EQ. 0.0) THEN
        tempb = 0.0_8
      ELSE
        tempb = distb/(2.D0*DSQRT(dels**2+deln**2))
      END IF
      delsb = deln_weights*sum_delx_delyb + dels_weights*sum_delx_sqrb +&
&       weights*dels_weightsb + 2*dels*tempb
      delnb = deln_weights*sum_dely_sqrb + weights*deln_weightsb + 2*&
&       deln*tempb
      delxb = SUM(point%dq(1, :, k)*tempb3) + SUM(point%dq(1, :, i)*&
&       tempb2) + SUM(point%dq(1, :, k)*tempb1) + SUM(point%dq(1, :, i)*&
&       tempb0) + nx*delnb + tx*delsb
      delyb = SUM(point%dq(2, :, k)*tempb3) + SUM(point%dq(2, :, i)*&
&       tempb2) + SUM(point%dq(2, :, k)*tempb1) + SUM(point%dq(2, :, i)*&
&       tempb0) + ny*delnb + ty*delsb
      nxb = nxb + delx*delnb
      nyb = nyb + dely*delnb
      txb = txb + delx*delsb
      tyb = tyb + dely*delsb
      y_kb = delyb
      y_ib = y_ib - delyb
      x_kb = delxb
      x_ib = x_ib - delxb
      pointb%y(k) = pointb%y(k) + y_kb
      pointb%x(k) = pointb%x(k) + x_kb
    END DO
    nxb = nxb - tyb
    nyb = nyb + txb
    pointb%ny(i) = pointb%ny(i) + nyb
    pointb%nx(i) = pointb%nx(i) + nxb
    pointb%y(i) = pointb%y(i) + y_ib
    pointb%x(i) = pointb%x(i) + x_ib
  END SUBROUTINE INTERIOR_DGY_POS_B

!	This subroutine evaluates the interior flux derivative dGx_neg
!
!
  SUBROUTINE INTERIOR_DGY_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%ypos_nbhs(i)
      k = point%ypos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GYP(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GYP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGY_POS

!  Differentiation of interior_dgy_neg in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: *(point.x) *(point.y) *(point.nx)
!                *(point.ny) *(point.q) *(point.dq) *(point.qm)
!                g
!   with respect to varying inputs: *(point.x) *(point.y) *(point.nx)
!                *(point.ny) *(point.q) *(point.dq) *(point.qm)
!   Plus diff mem management of: point.x:in point.y:in point.nx:in
!                point.ny:in point.q:in point.dq:in point.qm:in
!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGY_NEG_B(g, gb, i)
    USE DIFFSIZES
!  Hint: ISIZE1OFtemp should be the size of dimension 1 of array temp
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txb, tyb, nxb, nyb
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxb, delyb, detb, one_by_detb
    REAL*8 :: dels, deln
    REAL*8 :: delsb, delnb
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: dist, weights
    REAL*8 :: distb, weightsb
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_ib(4), phi_kb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsb, deln_weightsb
    INTRINSIC DSQRT
    REAL*8 :: tempb
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb0
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb1
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb2
    REAL*8, DIMENSION(ISIZE1OFtemp) :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%yneg_nbhs(i)
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      CALL PUSHREAL8(dist)
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL PUSHREAL8ARRAY(phi_i, 4)
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL PUSHREAL8ARRAY(phi_k, 4)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_i, 4)
      CALL FLUX_GYN(g_i, nx, ny, u1, u2, rho, pr)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_k, 4)
      CALL FLUX_GYN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    tempb4 = one_by_det*gb
    one_by_detb = SUM((sum_dely_delf*sum_delx_sqr-sum_delx_delf*&
&     sum_delx_dely)*gb)
    sum_dely_delfb = sum_delx_sqr*tempb4
    sum_delx_delfb = -(sum_delx_dely*tempb4)
    detb = -(one_by_detb/det**2)
    sum_delx_sqrb = SUM(sum_dely_delf*tempb4) + sum_dely_sqr*detb
    sum_delx_delyb = -SUM(sum_delx_delf*tempb4) - 2*sum_delx_dely*detb
    sum_dely_sqrb = sum_delx_sqr*detb
    txb = 0.0_8
    tyb = 0.0_8
    nxb = 0.0_8
    y_ib = 0.0_8
    nyb = 0.0_8
    g_ib = 0.0_8
    g_kb = 0.0_8
    x_ib = 0.0_8
    phi_ib = 0.0_8
    phi_kb = 0.0_8
    DO j=point%yneg_nbhs(i),1,-1
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      delx = x_k - x_i
      y_k = point%y(k)
      dely = y_k - y_i
      deln = delx*nx + dely*ny
      weights = dist**power
      deln_weights = deln*weights
      dels = delx*tx + dely*ty
      deln_weightsb = SUM((g_k-g_i)*sum_dely_delfb) + dels*&
&       sum_delx_delyb + deln*sum_dely_sqrb
      dels_weights = dels*weights
      g_kb = g_kb + deln_weights*sum_dely_delfb + dels_weights*&
&       sum_delx_delfb
      g_ib = g_ib - deln_weights*sum_dely_delfb - dels_weights*&
&       sum_delx_delfb
      dels_weightsb = SUM((g_k-g_i)*sum_delx_delfb) + dels*sum_delx_sqrb
      CALL POPREAL8ARRAY(g_k, 4)
      CALL FLUX_GYN_B(g_k, g_kb, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_k, qtilde_kb, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPREAL8ARRAY(g_i, 4)
      CALL FLUX_GYN_B(g_i, g_ib, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_i, qtilde_ib, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      phi_kb = phi_kb - (delx*point%dq(1, :, k)+dely*point%dq(2, :, k))*&
&       0.5d0*qtilde_kb
      tempb3 = -(phi_k*0.5d0*qtilde_kb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb3
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb3
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      phi_ib = phi_ib - (delx*point%dq(1, :, i)+dely*point%dq(2, :, i))*&
&       0.5d0*qtilde_ib
      tempb2 = -(phi_i*0.5d0*qtilde_ib)
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb2
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb2
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL POPREAL8ARRAY(phi_k, 4)
      CALL VENKAT_LIMITER_B(qtilde_k, qtilde_kb, phi_k, phi_kb, k)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL POPREAL8ARRAY(phi_i, 4)
      CALL VENKAT_LIMITER_B(qtilde_i, qtilde_ib, phi_i, phi_ib, i)
      CALL POPREAL8ARRAY(qtilde_k, 4)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      tempb1 = -(0.5d0*qtilde_kb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb1
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb1
      CALL POPREAL8ARRAY(qtilde_i, 4)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      tempb0 = -(0.5d0*qtilde_ib)
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb0
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb0
      weightsb = deln*deln_weightsb + dels*dels_weightsb
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        distb = 0.0_8
      ELSE
        distb = power*dist**(power-1)*weightsb
      END IF
      CALL POPREAL8(dist)
      IF (dels**2 + deln**2 .EQ. 0.0) THEN
        tempb = 0.0_8
      ELSE
        tempb = distb/(2.D0*DSQRT(dels**2+deln**2))
      END IF
      delsb = deln_weights*sum_delx_delyb + dels_weights*sum_delx_sqrb +&
&       weights*dels_weightsb + 2*dels*tempb
      delnb = deln_weights*sum_dely_sqrb + weights*deln_weightsb + 2*&
&       deln*tempb
      delxb = SUM(point%dq(1, :, k)*tempb3) + SUM(point%dq(1, :, i)*&
&       tempb2) + SUM(point%dq(1, :, k)*tempb1) + SUM(point%dq(1, :, i)*&
&       tempb0) + nx*delnb + tx*delsb
      delyb = SUM(point%dq(2, :, k)*tempb3) + SUM(point%dq(2, :, i)*&
&       tempb2) + SUM(point%dq(2, :, k)*tempb1) + SUM(point%dq(2, :, i)*&
&       tempb0) + ny*delnb + ty*delsb
      nxb = nxb + delx*delnb
      nyb = nyb + dely*delnb
      txb = txb + delx*delsb
      tyb = tyb + dely*delsb
      y_kb = delyb
      y_ib = y_ib - delyb
      x_kb = delxb
      x_ib = x_ib - delxb
      pointb%y(k) = pointb%y(k) + y_kb
      pointb%x(k) = pointb%x(k) + x_kb
    END DO
    nxb = nxb - tyb
    nyb = nyb + txb
    pointb%ny(i) = pointb%ny(i) + nyb
    pointb%nx(i) = pointb%nx(i) + nxb
    pointb%y(i) = pointb%y(i) + y_ib
    pointb%x(i) = pointb%x(i) + x_ib
  END SUBROUTINE INTERIOR_DGY_NEG_B

!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGY_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%yneg_nbhs(i)
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GYN(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GYN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGY_NEG

END MODULE INTERIOR_FLUXES_MOD_DIFF

