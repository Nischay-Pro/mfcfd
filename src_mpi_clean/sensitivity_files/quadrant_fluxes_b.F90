!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
MODULE QUADRANT_FLUXES_MOD_DIFF
!	This module consists of quadrant split fluxes 
!	with respect to the x-coordinate direction ..
  USE PARAMETER_MOD
  IMPLICIT NONE
!

CONTAINS
!  Differentiation of flux_quad_gxi in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: g nx ny
!   with respect to varying inputs: g nx ny u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXI_B(g, gb, nx, nxb, ny, nyb, u1, u1b, u2, u2b, &
&   rho, rhob, pr, prb)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betab
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1b, b1b, s2b, b2b
    DOUBLE PRECISION :: a1neg, a2neg
    DOUBLE PRECISION :: a1negb, a2negb
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: tempb0
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.0d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1neg - b1
    tempb0 = rho*a2neg*gb(4)
    temp4b = -gb(4)
    temp2b = tempb0
    temp3b = -tempb0
    tempb0 = b2*temp1*0.5d0*temp4b
    rhob = a2neg*(temp2-temp3)*gb(4) + un*tempb0
    a2negb = rho*(temp2-temp3)*gb(4)
    gb(4) = 0.D0
    tempb = rho*un*0.5d0*temp4b
    b2b = temp1*tempb
    temp1b = b2*tempb
    unb = rho*tempb0
    utb = a1neg*temp1b
    temp1 = 6.0d0*pr_by_rho + u_sqr
    b1b = temp1*0.5d0*temp3b - temp1b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    a1negb = ut*temp1b + ut*temp1*0.5d0*temp2b
    temp1b = b1*0.5d0*temp3b
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    tempb0 = a1neg*0.5d0*temp2b
    temp1b = ut*tempb0
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    temp2 = un*a2neg - b2
    temp1b = rho*temp2*gb(3)
    utb = utb + temp1*tempb0 + a1neg*temp1b
    temp1 = ut*a1neg - b1
    rhob = rhob + temp1*temp2*gb(3)
    temp2b = rho*temp1*gb(3)
    gb(3) = 0.D0
    unb = unb + a2neg*temp2b
    b2b = b2b - temp2b
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    tempb0 = (ut*a1neg-b1)*gb(1)
    a2negb = a2negb + un*temp2b + rho*temp2*gb(2) + rho*tempb0
    rhob = rhob + a2neg*temp2*gb(2) + a2neg*tempb0
    temp2b = rho*a2neg*gb(2)
    gb(2) = 0.D0
    tempb = rho*a2neg*gb(1)
    a1negb = a1negb + ut*temp1b + temp1*temp2b + ut*tempb
    b1b = b1b - temp1b - ut*temp2b - tempb
    temp1b = a1neg*temp2b
    utb = utb + 2*ut*temp1b - b1*temp2b + a1neg*tempb
    pr_by_rhob = pr_by_rhob + temp1b
    gb(1) = 0.D0
    result1b = -(0.5d0*a2negb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0
    CALL DERF_B(s2, s2b, result1b)
    CALL POPREAL8(s2)
    result1b = -(0.5d0*a1negb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0
    CALL DERF_B(s1, s1b, result1b)
    CALL POPREAL8(s1)
    temp0 = DSQRT(pi*beta)
    tempb = 0.5d0*b2b/temp0
    s2b = s2b - 2*s2*DEXP(-(s2**2))*tempb
    IF (pi*beta .EQ. 0.0) THEN
      betab = 0.D0
    ELSE
      betab = -(pi*DEXP(-(s2**2))*tempb/(2.D0*DSQRT(pi*beta)*temp0))
    END IF
    temp = DSQRT(pi*beta)
    tempb0 = 0.5d0*b1b/temp
    s1b = s1b - 2*s1*DEXP(-(s1**2))*tempb0
    IF (.NOT.pi*beta .EQ. 0.0) betab = betab - pi*DEXP(-(s1**2))*tempb0/&
&       (2.D0*DSQRT(pi*beta)*temp)
    temp = DSQRT(beta)
    unb = unb + 2*un*u_sqrb + temp*s2b
    IF (.NOT.beta .EQ. 0.0) betab = betab + un*s2b/(2.D0*DSQRT(beta))
    temp = DSQRT(beta)
    utb = utb + 2*ut*u_sqrb + temp*s1b
    IF (.NOT.beta .EQ. 0.0) betab = betab + ut*s1b/(2.D0*DSQRT(beta))
    tempb = 0.5d0*betab/pr
    prb = pr_by_rhob/rho - rho*tempb/pr
    rhob = rhob + tempb - pr*pr_by_rhob/rho**2
    u1b = nx*unb + tx*utb
    u2b = ny*unb + ty*utb
    txb = u1*utb
    nyb = nyb + u2*unb + txb
    tyb = u2*utb
    nxb = nxb + u1*unb - tyb
  END SUBROUTINE FLUX_QUAD_GXI_B

  SUBROUTINE FLUX_QUAD_GXI(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1neg, a2neg
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: result1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.0d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    g(1) = rho*a2neg*(ut*a1neg-b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    g(2) = rho*a2neg*temp2
    temp1 = ut*a1neg - b1
    temp2 = un*a2neg - b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1neg - b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2neg*(temp2-temp3) - temp4
  END SUBROUTINE FLUX_QUAD_GXI

!  Differentiation of flux_quad_gxii in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: g nx ny
!   with respect to varying inputs: g nx ny u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXII_B(g, gb, nx, nxb, ny, nyb, u1, u1b, u2, u2b&
&   , rho, rhob, pr, prb)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betab
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1b, b1b, s2b, b2b
    DOUBLE PRECISION :: a1pos, a2neg
    DOUBLE PRECISION :: a1posb, a2negb
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: tempb0
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.d0+result1)
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1pos + b1
    tempb0 = rho*a2neg*gb(4)
    temp4b = -gb(4)
    temp2b = tempb0
    temp3b = tempb0
    tempb0 = b2*temp1*0.5d0*temp4b
    rhob = a2neg*(temp2+temp3)*gb(4) + un*tempb0
    a2negb = rho*(temp2+temp3)*gb(4)
    gb(4) = 0.D0
    tempb = rho*un*0.5d0*temp4b
    b2b = temp1*tempb
    temp1b = b2*tempb
    unb = rho*tempb0
    utb = a1pos*temp1b
    temp1 = 6.0d0*pr_by_rho + u_sqr
    b1b = temp1b + temp1*0.5d0*temp3b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    a1posb = ut*temp1b + ut*temp1*0.5d0*temp2b
    temp1b = b1*0.5d0*temp3b
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    tempb0 = a1pos*0.5d0*temp2b
    temp1b = ut*tempb0
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    temp2 = un*a2neg - b2
    temp1b = rho*temp2*gb(3)
    utb = utb + temp1*tempb0 + a1pos*temp1b
    temp1 = ut*a1pos + b1
    rhob = rhob + temp1*temp2*gb(3)
    temp2b = rho*temp1*gb(3)
    gb(3) = 0.D0
    unb = unb + a2neg*temp2b
    b2b = b2b - temp2b
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    tempb0 = (ut*a1pos+b1)*gb(1)
    a2negb = a2negb + un*temp2b + rho*temp2*gb(2) + rho*tempb0
    rhob = rhob + a2neg*temp2*gb(2) + a2neg*tempb0
    temp2b = rho*a2neg*gb(2)
    gb(2) = 0.D0
    tempb = rho*a2neg*gb(1)
    a1posb = a1posb + ut*temp1b + temp1*temp2b + ut*tempb
    b1b = b1b + temp1b + ut*temp2b + tempb
    temp1b = a1pos*temp2b
    utb = utb + b1*temp2b + 2*ut*temp1b + a1pos*tempb
    pr_by_rhob = pr_by_rhob + temp1b
    gb(1) = 0.D0
    result1b = -(0.5d0*a2negb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0
    CALL DERF_B(s2, s2b, result1b)
    CALL POPREAL8(s2)
    result1b = 0.5d0*a1posb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0
    CALL DERF_B(s1, s1b, result1b)
    CALL POPREAL8(s1)
    temp0 = DSQRT(pi*beta)
    tempb = 0.5d0*b2b/temp0
    s2b = s2b - 2*s2*DEXP(-(s2**2))*tempb
    IF (pi*beta .EQ. 0.0) THEN
      betab = 0.D0
    ELSE
      betab = -(pi*DEXP(-(s2**2))*tempb/(2.D0*DSQRT(pi*beta)*temp0))
    END IF
    temp = DSQRT(pi*beta)
    tempb0 = 0.5d0*b1b/temp
    s1b = s1b - 2*s1*DEXP(-(s1**2))*tempb0
    IF (.NOT.pi*beta .EQ. 0.0) betab = betab - pi*DEXP(-(s1**2))*tempb0/&
&       (2.D0*DSQRT(pi*beta)*temp)
    temp = DSQRT(beta)
    unb = unb + 2*un*u_sqrb + temp*s2b
    IF (.NOT.beta .EQ. 0.0) betab = betab + un*s2b/(2.D0*DSQRT(beta))
    temp = DSQRT(beta)
    utb = utb + 2*ut*u_sqrb + temp*s1b
    IF (.NOT.beta .EQ. 0.0) betab = betab + ut*s1b/(2.D0*DSQRT(beta))
    tempb = 0.5d0*betab/pr
    prb = pr_by_rhob/rho - rho*tempb/pr
    rhob = rhob + tempb - pr*pr_by_rhob/rho**2
    u1b = nx*unb + tx*utb
    u2b = ny*unb + ty*utb
    txb = u1*utb
    nyb = nyb + u2*unb + txb
    tyb = u2*utb
    nxb = nxb + u1*unb - tyb
  END SUBROUTINE FLUX_QUAD_GXII_B

  SUBROUTINE FLUX_QUAD_GXII(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1pos, a2neg
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: result1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.d0+result1)
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    g(1) = rho*a2neg*(ut*a1pos+b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    g(2) = rho*a2neg*temp2
    temp1 = ut*a1pos + b1
    temp2 = un*a2neg - b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1pos + b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2neg*(temp2+temp3) - temp4
  END SUBROUTINE FLUX_QUAD_GXII

!  Differentiation of flux_quad_gxiii in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: g nx ny
!   with respect to varying inputs: g nx ny u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXIII_B(g, gb, nx, nxb, ny, nyb, u1, u1b, u2, u2b&
&   , rho, rhob, pr, prb)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betab
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1b, b1b, s2b, b2b
    DOUBLE PRECISION :: a1pos, a2pos
    DOUBLE PRECISION :: a1posb, a2posb
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: tempb0
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.0d0+result1)
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1pos + b1
    tempb0 = rho*a2pos*gb(4)
    temp4b = gb(4)
    temp2b = tempb0
    temp3b = tempb0
    tempb0 = b2*temp1*0.5d0*temp4b
    rhob = a2pos*(temp2+temp3)*gb(4) + un*tempb0
    a2posb = rho*(temp2+temp3)*gb(4)
    gb(4) = 0.D0
    tempb = rho*un*0.5d0*temp4b
    b2b = temp1*tempb
    temp1b = b2*tempb
    unb = rho*tempb0
    utb = a1pos*temp1b
    temp1 = 6.0d0*pr_by_rho + u_sqr
    b1b = temp1b + temp1*0.5d0*temp3b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    a1posb = ut*temp1b + ut*temp1*0.5d0*temp2b
    temp1b = b1*0.5d0*temp3b
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    tempb0 = a1pos*0.5d0*temp2b
    temp1b = ut*tempb0
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    temp2 = un*a2pos + b2
    temp1b = rho*temp2*gb(3)
    utb = utb + temp1*tempb0 + a1pos*temp1b
    temp1 = ut*a1pos + b1
    rhob = rhob + temp1*temp2*gb(3)
    temp2b = rho*temp1*gb(3)
    gb(3) = 0.D0
    unb = unb + a2pos*temp2b
    b2b = b2b + temp2b
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    tempb0 = (ut*a1pos+b1)*gb(1)
    a2posb = a2posb + un*temp2b + rho*temp2*gb(2) + rho*tempb0
    rhob = rhob + a2pos*temp2*gb(2) + a2pos*tempb0
    temp2b = rho*a2pos*gb(2)
    gb(2) = 0.D0
    tempb = rho*a2pos*gb(1)
    a1posb = a1posb + ut*temp1b + temp1*temp2b + ut*tempb
    b1b = b1b + temp1b + ut*temp2b + tempb
    temp1b = a1pos*temp2b
    utb = utb + b1*temp2b + 2*ut*temp1b + a1pos*tempb
    pr_by_rhob = pr_by_rhob + temp1b
    gb(1) = 0.D0
    result1b = 0.5d0*a2posb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0
    CALL DERF_B(s2, s2b, result1b)
    CALL POPREAL8(s2)
    result1b = 0.5d0*a1posb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0
    CALL DERF_B(s1, s1b, result1b)
    CALL POPREAL8(s1)
    temp0 = DSQRT(pi*beta)
    tempb = 0.5d0*b2b/temp0
    s2b = s2b - 2*s2*DEXP(-(s2**2))*tempb
    IF (pi*beta .EQ. 0.0) THEN
      betab = 0.D0
    ELSE
      betab = -(pi*DEXP(-(s2**2))*tempb/(2.D0*DSQRT(pi*beta)*temp0))
    END IF
    temp = DSQRT(pi*beta)
    tempb0 = 0.5d0*b1b/temp
    s1b = s1b - 2*s1*DEXP(-(s1**2))*tempb0
    IF (.NOT.pi*beta .EQ. 0.0) betab = betab - pi*DEXP(-(s1**2))*tempb0/&
&       (2.D0*DSQRT(pi*beta)*temp)
    temp = DSQRT(beta)
    unb = unb + 2*un*u_sqrb + temp*s2b
    IF (.NOT.beta .EQ. 0.0) betab = betab + un*s2b/(2.D0*DSQRT(beta))
    temp = DSQRT(beta)
    utb = utb + 2*ut*u_sqrb + temp*s1b
    IF (.NOT.beta .EQ. 0.0) betab = betab + ut*s1b/(2.D0*DSQRT(beta))
    tempb = 0.5d0*betab/pr
    prb = pr_by_rhob/rho - rho*tempb/pr
    rhob = rhob + tempb - pr*pr_by_rhob/rho**2
    u1b = nx*unb + tx*utb
    u2b = ny*unb + ty*utb
    txb = u1*utb
    nyb = nyb + u2*unb + txb
    tyb = u2*utb
    nxb = nxb + u1*unb - tyb
  END SUBROUTINE FLUX_QUAD_GXIII_B

  SUBROUTINE FLUX_QUAD_GXIII(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1pos, a2pos
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: result1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.0d0+result1)
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    g(1) = rho*a2pos*(ut*a1pos+b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    g(2) = rho*a2pos*temp2
    temp1 = ut*a1pos + b1
    temp2 = un*a2pos + b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1pos + b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2pos*(temp2+temp3) + temp4
  END SUBROUTINE FLUX_QUAD_GXIII

!  Differentiation of flux_quad_gxiv in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: g nx ny
!   with respect to varying inputs: g nx ny u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXIV_B(g, gb, nx, nxb, ny, nyb, u1, u1b, u2, u2b&
&   , rho, rhob, pr, prb)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betab
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1b, b1b, s2b, b2b
    DOUBLE PRECISION :: a1neg, a2pos
    DOUBLE PRECISION :: a1negb, a2posb
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: tempb0
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1neg - b1
    tempb0 = rho*a2pos*gb(4)
    temp4b = gb(4)
    temp2b = tempb0
    temp3b = -tempb0
    tempb0 = b2*temp1*0.5d0*temp4b
    rhob = a2pos*(temp2-temp3)*gb(4) + un*tempb0
    a2posb = rho*(temp2-temp3)*gb(4)
    gb(4) = 0.D0
    tempb = rho*un*0.5d0*temp4b
    b2b = temp1*tempb
    temp1b = b2*tempb
    unb = rho*tempb0
    utb = a1neg*temp1b
    temp1 = 6.0d0*pr_by_rho + u_sqr
    b1b = temp1*0.5d0*temp3b - temp1b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    a1negb = ut*temp1b + ut*temp1*0.5d0*temp2b
    temp1b = b1*0.5d0*temp3b
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    tempb0 = a1neg*0.5d0*temp2b
    temp1b = ut*tempb0
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    temp2 = un*a2pos + b2
    temp1b = rho*temp2*gb(3)
    utb = utb + temp1*tempb0 + a1neg*temp1b
    temp1 = ut*a1neg - b1
    rhob = rhob + temp1*temp2*gb(3)
    temp2b = rho*temp1*gb(3)
    gb(3) = 0.D0
    unb = unb + a2pos*temp2b
    b2b = b2b + temp2b
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    tempb0 = (ut*a1neg-b1)*gb(1)
    a2posb = a2posb + un*temp2b + rho*temp2*gb(2) + rho*tempb0
    rhob = rhob + a2pos*temp2*gb(2) + a2pos*tempb0
    temp2b = rho*a2pos*gb(2)
    gb(2) = 0.D0
    tempb = rho*a2pos*gb(1)
    a1negb = a1negb + ut*temp1b + temp1*temp2b + ut*tempb
    b1b = b1b - temp1b - ut*temp2b - tempb
    temp1b = a1neg*temp2b
    utb = utb + 2*ut*temp1b - b1*temp2b + a1neg*tempb
    pr_by_rhob = pr_by_rhob + temp1b
    gb(1) = 0.D0
    result1b = 0.5d0*a2posb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0
    CALL DERF_B(s2, s2b, result1b)
    CALL POPREAL8(s2)
    result1b = -(0.5d0*a1negb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0
    CALL DERF_B(s1, s1b, result1b)
    CALL POPREAL8(s1)
    temp0 = DSQRT(pi*beta)
    tempb = 0.5d0*b2b/temp0
    s2b = s2b - 2*s2*DEXP(-(s2**2))*tempb
    IF (pi*beta .EQ. 0.0) THEN
      betab = 0.D0
    ELSE
      betab = -(pi*DEXP(-(s2**2))*tempb/(2.D0*DSQRT(pi*beta)*temp0))
    END IF
    temp = DSQRT(pi*beta)
    tempb0 = 0.5d0*b1b/temp
    s1b = s1b - 2*s1*DEXP(-(s1**2))*tempb0
    IF (.NOT.pi*beta .EQ. 0.0) betab = betab - pi*DEXP(-(s1**2))*tempb0/&
&       (2.D0*DSQRT(pi*beta)*temp)
    temp = DSQRT(beta)
    unb = unb + 2*un*u_sqrb + temp*s2b
    IF (.NOT.beta .EQ. 0.0) betab = betab + un*s2b/(2.D0*DSQRT(beta))
    temp = DSQRT(beta)
    utb = utb + 2*ut*u_sqrb + temp*s1b
    IF (.NOT.beta .EQ. 0.0) betab = betab + ut*s1b/(2.D0*DSQRT(beta))
    tempb = 0.5d0*betab/pr
    prb = pr_by_rhob/rho - rho*tempb/pr
    rhob = rhob + tempb - pr*pr_by_rhob/rho**2
    u1b = nx*unb + tx*utb
    u2b = ny*unb + ty*utb
    txb = u1*utb
    nyb = nyb + u2*unb + txb
    tyb = u2*utb
    nxb = nxb + u1*unb - tyb
  END SUBROUTINE FLUX_QUAD_GXIV_B

  SUBROUTINE FLUX_QUAD_GXIV(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1neg, a2pos
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: result1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    g(1) = rho*a2pos*(ut*a1neg-b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    g(2) = rho*a2pos*temp2
    temp1 = ut*a1neg - b1
    temp2 = un*a2pos + b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1neg - b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2pos*(temp2-temp3) + temp4
  END SUBROUTINE FLUX_QUAD_GXIV

END MODULE QUADRANT_FLUXES_MOD_DIFF
