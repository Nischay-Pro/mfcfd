!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE Q_LSKUM_MOD_DIFF
!	First written on 14.10.2016
!	updated on Dec 26, 2016
!	updated on Dec 29, 2016
  USE DATA_STRUCTURE_MOD_DIFF
  USE POINT_NORMALS_MOD_DIFF
  USE GENERATE_CONNECTIVITY_MOD_DIFF
  USE FPI_SOLVER_MOD_DIFF
  USE INITIAL_CONDITIONS_MOD
  IMPLICIT NONE

CONTAINS
!  Differentiation of q_lskum in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: *vector_cost_func
!   with respect to varying inputs: mach q_inf theta euler cfl
!                power *clcd *cd *vector_cost_func *cl *cm vl_const
!                *(point.x) *(point.y) *(point.nx) *(point.ny)
!                *(point.min_dist) *(point.prim) *(point.prim_old)
!                *(point.flux_res) *(point.q) *(point.dq) *(point.qm)
!                *(point.temp) *(point.vorticity_sqr) *(point.delta)
!   RW status of diff variables: mach:in q_inf:in theta:in aoa:(loc)
!                q_init:(loc) euler:in res_new:(loc) cfl:in t:(loc)
!                sum_res_sqr:(loc) cfv:(loc) *cfv:(loc) max_res:(loc)
!                cm_flag:(loc) tfinal:(loc) total_enstrophy:(loc)
!                ens_flag:(loc) total_loss_stagpressure:(loc) power:in
!                res_old:(loc) cl_cd_flag:(loc) clcd:(loc) *clcd:in-killed
!                cd:(loc) *cd:in-killed vector_cost_func:(loc)
!                *vector_cost_func:in-out cl:(loc) *cl:in-killed
!                cm:(loc) *cm:in-killed vl_const:in cd_flag:(loc)
!                residue:(loc) total_entropy:(loc) point.original_id:(loc)
!                point.x:(loc) *(point.x):in point.y:(loc) *(point.y):in
!                point.left:(loc) point.right:(loc) point.flag_1:(loc)
!                point.flag_2:(loc) point.qtdepth:(loc) point.nx:(loc)
!                *(point.nx):in-killed point.ny:(loc) *(point.ny):in-killed
!                point.nbhs:(loc) point.conn:(loc) point.min_dist:(loc)
!                *(point.min_dist):in point.prim:(loc) *(point.prim):in-killed
!                point.prim_old:(loc) *(point.prim_old):in-killed
!                point.flux_res:(loc) *(point.flux_res):in-killed
!                point.q:(loc) *(point.q):in-killed point.u:(loc)
!                *(point.u):(loc) point.dq:(loc) *(point.dq):in-killed
!                point.qm:(loc) *(point.qm):in-killed point.temp:(loc)
!                *(point.temp):in-killed point.entropy:(loc) *(point.entropy):(loc)
!                point.vorticity:(loc) *(point.vorticity):(loc)
!                point.vorticity_sqr:(loc) *(point.vorticity_sqr):in-killed
!                point.xpos_nbhs:(loc) point.xneg_nbhs:(loc) point.ypos_nbhs:(loc)
!                point.yneg_nbhs:(loc) point.xpos_conn:(loc) point.xneg_conn:(loc)
!                point.ypos_conn:(loc) point.yneg_conn:(loc) point.delta:(loc)
!                *(point.delta):in-killed point.u_old:(loc) *(point.u_old):(loc)
!                fo_flag:(loc) cl_flag:(loc) gsum_res_sqr:(loc)
!                ent_flag:(loc) dtg:(loc)
!   Plus diff mem management of: clcd:in cd:in vector_cost_func:in
!                cl:in cm:in point.x:in point.y:in point.nx:in
!                point.ny:in point.min_dist:in point.prim:in point.prim_old:in
!                point.flux_res:in point.q:in point.dq:in point.qm:in
!                point.temp:in point.vorticity_sqr:in point.delta:in
  SUBROUTINE Q_LSKUM_D()
    IMPLICIT NONE
    INTEGER :: i
    IF (rank .EQ. 0) OPEN(unit=301, file='residue', form='FORMATTED', &
&                   status='REPLACE', action='WRITE') 
    CALL COMPUTE_NORMALS_D()
    CALL GENERATE_CONNECTIVITY()
    IF (rank .EQ. 0) THEN
      WRITE(*, *) 
      WRITE(*, *) '%%%%-Normals and connectivity generated-%%%'
      WRITE(*, *) 
    END IF
! Set U_old to U for first iteration
    DO i=1,local_points
      pointd%u_old(1, i) = 0.0_8
      point%u_old(1, i) = point%prim(1, i)
      pointd%u_old(2, i) = 0.0_8
      point%u_old(2, i) = point%prim(1, i)*point%prim(2, i)
      pointd%u_old(3, i) = 0.0_8
      point%u_old(3, i) = point%prim(1, i)*point%prim(3, i)
      pointd%u_old(4, i) = 0.0_8
      point%u_old(4, i) = 2.5d0*point%prim(4, i) + 0.5d0*point%prim(1, i&
&       )*(point%prim(2, i)*point%prim(2, i)+point%prim(3, i)*point%prim&
&       (3, i))
    END DO
    IF (rank .EQ. 0) THEN
      WRITE(*, *) '%%%%%%%%%%%%%-Iterations begin-%%%%%%%%%%%%'
      WRITE(*, *) 
    END IF
    t = 0.0d0
    IF (restart .EQ. 0) itr = 0
    DO it=itr+1,itr+max_iters
      CALL FPI_SOLVER_D(it)
      t = t + dtg
      IF (rank .EQ. 0) THEN
        IF (timestep .EQ. 0) THEN
          WRITE(*, '(a12,i8,a15,e30.20)') 'iterations:', it, 'residue:'&
&         , residue
          WRITE(301, *) it, residue
        ELSE IF (timestep .EQ. 1) THEN
          WRITE(*, '(a12,i8,a15,e30.20)') 'iterations:', it, 'time:', t
          WRITE(301, *) it, t, dtg
        END IF
        IF (IEEE_IS_NAN(residue)) EXIT
      END IF
    END DO
    CLOSE(unit=301) 
  END SUBROUTINE Q_LSKUM_D

END MODULE Q_LSKUM_MOD_DIFF
