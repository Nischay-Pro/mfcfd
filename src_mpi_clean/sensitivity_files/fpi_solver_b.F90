!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
MODULE FPI_SOLVER_MOD_DIFF
! #include <petsc/finclude/petscsys.h>
  USE DATA_STRUCTURE_MOD_DIFF
  USE FLUX_RESIDUAL_MOD_DIFF
  USE STATE_UPDATE_MOD_DIFF
  USE Q_VARIABLES_MOD_DIFF
  USE OBJECTIVE_FUNCTION_MOD_DIFF
  USE POST_PROCESSING_MOD
  IMPLICIT NONE

CONTAINS
!  Differentiation of fpi_solver in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: *vector_cost_func *cl *(point.x)
!                *(point.y) *(point.nx) *(point.ny) *(point.prim)
!                *(point.prim_old) *(point.flux_res) *(point.q)
!                *(point.dq) *(point.qm) *(point.temp) *(point.delta)
!   with respect to varying inputs: *vector_cost_func *cl *(point.x)
!                *(point.y) *(point.nx) *(point.ny) *(point.prim)
!                *(point.prim_old) *(point.flux_res) *(point.q)
!                *(point.dq) *(point.qm) *(point.temp) *(point.delta)
!   Plus diff mem management of: vector_cost_func:in cl:in point.x:in
!                point.y:in point.nx:in point.ny:in point.prim:in
!                point.prim_old:in point.flux_res:in point.q:in
!                point.dq:in point.qm:in point.temp:in point.delta:in
  SUBROUTINE FPI_SOLVER_B(t)
    USE DIFFSIZES
!  Hint: ISIZE2OFDrfpoint_q should be the size of dimension 2 of array *point%q
!  Hint: ISIZE1OFDrfpoint_q should be the size of dimension 1 of array *point%q
!  Hint: ISIZE3OFDrfpoint_qm should be the size of dimension 3 of array *point%qm
!  Hint: ISIZE2OFDrfpoint_qm should be the size of dimension 2 of array *point%qm
!  Hint: ISIZE1OFDrfpoint_qm should be the size of dimension 1 of array *point%qm
!  Hint: ISIZE3OFDrfpoint_dq should be the size of dimension 3 of array *point%dq
!  Hint: ISIZE2OFDrfpoint_dq should be the size of dimension 2 of array *point%dq
!  Hint: ISIZE1OFDrfpoint_dq should be the size of dimension 1 of array *point%dq
!  Hint: ISIZE2OFDrfpoint_flux_res should be the size of dimension 2 of array *point%flux_res
!  Hint: ISIZE1OFDrfpoint_flux_res should be the size of dimension 1 of array *point%flux_res
!  Hint: ISIZE2OFDrfpoint_prim should be the size of dimension 2 of array *point%prim
!  Hint: ISIZE1OFDrfpoint_prim should be the size of dimension 1 of array *point%prim
    IMPLICIT NONE
    INTEGER :: t, i, rk
    INTRINSIC DSQRT
    INTRINSIC DLOG10
    INTRINSIC MOD
    EXTERNAL PRINT_PRIMAL_OUTPUT
! PetscErrorCode :: ierr
    DO i=1,local_points
      point%prim_old(:, i) = point%prim(:, i)
    END DO
    CALL FUNC_DELTA()
! Perform 4-stage, 3-order SSPRK update
    DO rk=1,rks
      CALL PUSHREAL8ARRAY(point%q, ISIZE1OFDrfpoint_q*ISIZE2OFDrfpoint_q&
&                  )
      CALL EVAL_Q_VARIABLES()
      CALL PUSHREAL8ARRAY(point%qm, ISIZE1OFDrfpoint_qm*&
&                   ISIZE2OFDrfpoint_qm*ISIZE3OFDrfpoint_qm)
      CALL PUSHREAL8ARRAY(point%dq, ISIZE1OFDrfpoint_dq*&
&                   ISIZE2OFDrfpoint_dq*ISIZE3OFDrfpoint_dq)
      CALL EVAL_Q_DERIVATIVES()
!Update the ghost values from the owned process
! call update_begin_dq_ghost()
! call update_begin_qm_ghost()
! call update_end_dq_ghost()
! call update_end_qm_ghost()
      DO i=1,inner_iterations
        CALL EVAL_Q_INNER_LOOP()
        CALL PUSHREAL8ARRAY(point%dq, ISIZE1OFDrfpoint_dq*&
&                     ISIZE2OFDrfpoint_dq*ISIZE3OFDrfpoint_dq)
        CALL EVAL_UPDATE_INNERLOOP()
      END DO
! call update_begin_dq_ghost()
! call update_end_dq_ghost()
      CALL PUSHREAL8ARRAY(point%flux_res, ISIZE1OFDrfpoint_flux_res*&
&                   ISIZE2OFDrfpoint_flux_res)
      CALL CAL_FLUX_RESIDUAL()
      CALL PUSHREAL8ARRAY(point%prim, ISIZE1OFDrfpoint_prim*&
&                   ISIZE2OFDrfpoint_prim)
      CALL STATE_UPDATE(rk)
    END DO
    CALL OBJECTIVE_FUNCTION_B()
    DO rk=rks,1,-1
      CALL POPREAL8ARRAY(point%prim, ISIZE1OFDrfpoint_prim*&
&                  ISIZE2OFDrfpoint_prim)
      CALL STATE_UPDATE_B(rk)
      CALL POPREAL8ARRAY(point%flux_res, ISIZE1OFDrfpoint_flux_res*&
&                  ISIZE2OFDrfpoint_flux_res)
      CALL CAL_FLUX_RESIDUAL_B()
      DO i=inner_iterations,1,-1
        CALL POPREAL8ARRAY(point%dq, ISIZE1OFDrfpoint_dq*&
&                    ISIZE2OFDrfpoint_dq*ISIZE3OFDrfpoint_dq)
        CALL EVAL_UPDATE_INNERLOOP_B()
        CALL EVAL_Q_INNER_LOOP_B()
      END DO
      CALL POPREAL8ARRAY(point%dq, ISIZE1OFDrfpoint_dq*&
&                  ISIZE2OFDrfpoint_dq*ISIZE3OFDrfpoint_dq)
      CALL POPREAL8ARRAY(point%qm, ISIZE1OFDrfpoint_qm*&
&                  ISIZE2OFDrfpoint_qm*ISIZE3OFDrfpoint_qm)
      CALL EVAL_Q_DERIVATIVES_B()
      CALL POPREAL8ARRAY(point%q, ISIZE1OFDrfpoint_q*ISIZE2OFDrfpoint_q)
      CALL EVAL_Q_VARIABLES_B()
    END DO
    CALL FUNC_DELTA_B()
    DO i=local_points,1,-1
      pointb%prim(:, i) = pointb%prim(:, i) + pointb%prim_old(:, i)
      pointb%prim_old(:, i) = 0.0_8
    END DO
  END SUBROUTINE FPI_SOLVER_B

  SUBROUTINE FPI_SOLVER(t)
    IMPLICIT NONE
    INTEGER :: t, i, rk
    INTRINSIC DSQRT
    INTRINSIC DLOG10
    INTRINSIC MOD
    EXTERNAL PRINT_PRIMAL_OUTPUT
! PetscErrorCode :: ierr
    DO i=1,local_points
      point%prim_old(:, i) = point%prim(:, i)
    END DO
    CALL FUNC_DELTA()
! Perform 4-stage, 3-order SSPRK update
    DO rk=1,rks
      CALL EVAL_Q_VARIABLES()
      CALL EVAL_Q_DERIVATIVES()
!Update the ghost values from the owned process
! call update_begin_dq_ghost()
! call update_begin_qm_ghost()
! call update_end_dq_ghost()
! call update_end_qm_ghost()
      DO i=1,inner_iterations
        CALL EVAL_Q_INNER_LOOP()
        CALL EVAL_UPDATE_INNERLOOP()
      END DO
! call update_begin_dq_ghost()
! call update_end_dq_ghost()
      CALL CAL_FLUX_RESIDUAL()
      CALL STATE_UPDATE(rk)
    END DO
! start updating primitive values
! call update_begin_prim_ghost()
! call update_end_prim_ghost()
    CALL OBJECTIVE_FUNCTION()
! call MPI_Reduce(sum_res_sqr,gsum_res_sqr, 1, MPI_DOUBLE, MPI_SUM, &
!    0, PETSC_COMM_WORLD, ierr)
! call MPI_Bcast(gsum_res_sqr, 1, MPI_DOUBLE, 0, PETSC_COMM_WORLD, &
!   ierr)
    res_new = DSQRT(gsum_res_sqr)/plen
    IF (t .LE. 2 .AND. restart .EQ. 0) THEN
      res_old = res_new
      residue = 0.d0
    ELSE
      residue = DLOG10(res_new/res_old)
    END IF
! Print primal output
    IF (MOD(it, nsave) .EQ. 0) THEN
      IF (rank .EQ. 0) THEN
        WRITE(*, *) 
        WRITE(*, *) '%%%%%%%%%%%%%-Saving solution-%%%%%%%%%%%%%'
        WRITE(*, *) 
      END IF
      CALL PRINT_PRIMAL_OUTPUT()
    END IF
  END SUBROUTINE FPI_SOLVER

END MODULE FPI_SOLVER_MOD_DIFF

