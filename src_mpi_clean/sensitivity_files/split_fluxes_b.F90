!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE SPLIT_FLUXES_MOD_DIFF
  USE PARAMETER_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of flux_gxp in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: gxp nx ny
!   with respect to varying inputs: gxp nx ny u1 u2 pr rho
  SUBROUTINE FLUX_GXP_B(gxp, gxpb, nx, nxb, ny, nyb, u1, u1b, u2, u2b, &
&   rho, rhob, pr, prb)
    IMPLICIT NONE
    DOUBLE PRECISION :: gxp(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gxpb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: beta, s1, b1, a1pos
    DOUBLE PRECISION :: betab, s1b, b1b, a1posb
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: temp1b, temp2b
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: tempb2
    DOUBLE PRECISION :: tempb3
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!     Expressions for the split fluxes ..	
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp = DSQRT(beta)
    tempb = rho*gxpb(4)
    rhob = (temp2+0.5d0*(temp1*b1))*gxpb(4)
    temp2b = tempb
    temp1b = 0.5d0*b1*tempb
    b1b = 0.5d0*temp1*tempb
    gxpb(4) = 0.D0
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    tempb0 = 0.5d0*a1pos*temp2b
    temp1b = ut*tempb0
    a1posb = 0.5d0*ut*temp1*temp2b
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    temp1b = rho*gxpb(3)
    utb = a1pos*un*temp1b + temp1*tempb0
    temp1 = ut*un*a1pos + un*b1
    rhob = rhob + temp1*gxpb(3)
    gxpb(3) = 0.D0
    unb = 2*un*u_sqrb + (b1+a1pos*ut)*temp1b
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    rhob = rhob + temp2*gxpb(2)
    temp2b = rho*gxpb(2)
    gxpb(2) = 0.D0
    tempb1 = rho*gxpb(1)
    a1posb = a1posb + temp1*temp2b + ut*tempb1 + ut*un*temp1b
    b1b = b1b + ut*temp2b + tempb1 + un*temp1b
    temp1b = a1pos*temp2b
    pr_by_rhob = pr_by_rhob + temp1b
    result1b = 0.5d0*a1posb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0
    CALL DERF_B(s1, s1b, result1b)
    CALL POPREAL8(s1)
    temp0 = DSQRT(pi*beta)
    tempb3 = 0.5d0*b1b/temp0
    s1b = s1b - DEXP(-(s1**2))*2*s1*tempb3
    utb = utb + 2*ut*temp1b + 2*ut*u_sqrb + temp*s1b + a1pos*tempb1 + b1&
&     *temp2b
    IF (pi*beta .EQ. 0.0) THEN
      betab = 0.0
    ELSE
      betab = -(DEXP(-(s1**2))*pi*tempb3/(2.D0*DSQRT(pi*beta)*temp0))
    END IF
    IF (.NOT.beta .EQ. 0.0) betab = betab + ut*s1b/(2.D0*DSQRT(beta))
    tempb2 = 0.5d0*betab/pr
    rhob = rhob + tempb2 - pr*pr_by_rhob/rho**2 + (ut*a1pos+b1)*gxpb(1)
    gxpb(1) = 0.D0
    prb = pr_by_rhob/rho - rho*tempb2/pr
    u1b = tx*utb + nx*unb
    u2b = ty*utb + ny*unb
    txb = u1*utb
    nyb = nyb + txb + u2*unb
    tyb = u2*utb
    nxb = nxb + u1*unb - tyb
  END SUBROUTINE FLUX_GXP_B

  SUBROUTINE FLUX_GXP(gxp, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: gxp(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta, s1, b1, a1pos
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: result1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!     Expressions for the split fluxes ..	
    gxp(1) = rho*(ut*a1pos+b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    gxp(2) = rho*temp2
    temp1 = ut*un*a1pos + un*b1
    gxp(3) = rho*temp1
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    gxp(4) = rho*(temp2+0.5d0*temp1*b1)
  END SUBROUTINE FLUX_GXP

!  Differentiation of flux_gxn in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: gxn nx ny
!   with respect to varying inputs: gxn nx ny u1 u2 pr rho
  SUBROUTINE FLUX_GXN_B(gxn, gxnb, nx, nxb, ny, nyb, u1, u1b, u2, u2b, &
&   rho, rhob, pr, prb)
    IMPLICIT NONE
    DOUBLE PRECISION :: gxn(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gxnb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: beta, s1, b1, a1neg
    DOUBLE PRECISION :: betab, s1b, b1b, a1negb
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: temp1b, temp2b
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: tempb2
    DOUBLE PRECISION :: tempb3
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp = DSQRT(beta)
    tempb = rho*gxnb(4)
    rhob = (temp2-0.5d0*(temp1*b1))*gxnb(4)
    temp2b = tempb
    temp1b = -(0.5d0*b1*tempb)
    b1b = -(0.5d0*temp1*tempb)
    gxnb(4) = 0.D0
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    tempb0 = 0.5d0*a1neg*temp2b
    temp1b = ut*tempb0
    a1negb = 0.5d0*ut*temp1*temp2b
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    temp1b = rho*gxnb(3)
    utb = a1neg*un*temp1b + temp1*tempb0
    temp1 = ut*un*a1neg - un*b1
    rhob = rhob + temp1*gxnb(3)
    gxnb(3) = 0.D0
    unb = 2*un*u_sqrb + (a1neg*ut-b1)*temp1b
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    rhob = rhob + temp2*gxnb(2)
    temp2b = rho*gxnb(2)
    gxnb(2) = 0.D0
    tempb1 = rho*gxnb(1)
    a1negb = a1negb + temp1*temp2b + ut*tempb1 + ut*un*temp1b
    b1b = b1b - ut*temp2b - tempb1 - un*temp1b
    temp1b = a1neg*temp2b
    pr_by_rhob = pr_by_rhob + temp1b
    result1b = -(0.5d0*a1negb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0
    CALL DERF_B(s1, s1b, result1b)
    CALL POPREAL8(s1)
    temp0 = DSQRT(pi*beta)
    tempb3 = 0.5d0*b1b/temp0
    s1b = s1b - DEXP(-(s1**2))*2*s1*tempb3
    utb = utb + 2*ut*temp1b + 2*ut*u_sqrb + temp*s1b + a1neg*tempb1 - b1&
&     *temp2b
    IF (pi*beta .EQ. 0.0) THEN
      betab = 0.0
    ELSE
      betab = -(DEXP(-(s1**2))*pi*tempb3/(2.D0*DSQRT(pi*beta)*temp0))
    END IF
    IF (.NOT.beta .EQ. 0.0) betab = betab + ut*s1b/(2.D0*DSQRT(beta))
    tempb2 = 0.5d0*betab/pr
    rhob = rhob + tempb2 - pr*pr_by_rhob/rho**2 + (ut*a1neg-b1)*gxnb(1)
    gxnb(1) = 0.D0
    prb = pr_by_rhob/rho - rho*tempb2/pr
    u1b = tx*utb + nx*unb
    u2b = ty*utb + ny*unb
    txb = u1*utb
    nyb = nyb + txb + u2*unb
    tyb = u2*utb
    nxb = nxb + u1*unb - tyb
  END SUBROUTINE FLUX_GXN_B

  SUBROUTINE FLUX_GXN(gxn, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: gxn(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta, s1, b1, a1neg
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: result1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    gxn(1) = rho*(ut*a1neg-b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    gxn(2) = rho*temp2
    temp1 = ut*un*a1neg - un*b1
    gxn(3) = rho*temp1
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    gxn(4) = rho*(temp2-0.5d0*temp1*b1)
  END SUBROUTINE FLUX_GXN

!  Differentiation of flux_gyp in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: nx ny gyp
!   with respect to varying inputs: nx ny gyp u1 u2 pr rho
  SUBROUTINE FLUX_GYP_B(gyp, gypb, nx, nxb, ny, nyb, u1, u1b, u2, u2b, &
&   rho, rhob, pr, prb)
    IMPLICIT NONE
    DOUBLE PRECISION :: gyp(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gypb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: beta, s2, b2, a2pos
    DOUBLE PRECISION :: betab, s2b, b2b, a2posb
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: temp1b, temp2b
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: tempb2
    DOUBLE PRECISION :: tempb3
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s2 = un*DSQRT(beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*un*temp1*a2pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp = DSQRT(beta)
    tempb = rho*gypb(4)
    rhob = (temp2+0.5d0*(temp1*b2))*gypb(4)
    temp2b = tempb
    temp1b = 0.5d0*b2*tempb
    b2b = 0.5d0*temp1*tempb
    gypb(4) = 0.D0
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    tempb0 = 0.5d0*a2pos*temp2b
    temp1b = un*tempb0
    a2posb = 0.5d0*un*temp1*temp2b
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    temp1b = rho*gypb(2)
    unb = a2pos*ut*temp1b + temp1*tempb0
    temp1 = ut*un*a2pos + ut*b2
    rhob = rhob + temp1*gypb(2)
    gypb(2) = 0.D0
    utb = 2*ut*u_sqrb + (b2+a2pos*un)*temp1b
    temp1 = pr_by_rho + un*un
    temp2 = temp1*a2pos + un*b2
    rhob = rhob + temp2*gypb(3)
    temp2b = rho*gypb(3)
    gypb(3) = 0.D0
    tempb1 = rho*gypb(1)
    a2posb = a2posb + temp1*temp2b + un*tempb1 + ut*un*temp1b
    b2b = b2b + un*temp2b + tempb1 + ut*temp1b
    temp1b = a2pos*temp2b
    pr_by_rhob = pr_by_rhob + temp1b
    result1b = 0.5d0*a2posb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0
    CALL DERF_B(s2, s2b, result1b)
    CALL POPREAL8(s2)
    temp0 = DSQRT(pi*beta)
    tempb3 = 0.5d0*b2b/temp0
    s2b = s2b - DEXP(-(s2**2))*2*s2*tempb3
    unb = unb + 2*un*temp1b + 2*un*u_sqrb + temp*s2b + a2pos*tempb1 + b2&
&     *temp2b
    IF (pi*beta .EQ. 0.0) THEN
      betab = 0.0
    ELSE
      betab = -(DEXP(-(s2**2))*pi*tempb3/(2.D0*DSQRT(pi*beta)*temp0))
    END IF
    IF (.NOT.beta .EQ. 0.0) betab = betab + un*s2b/(2.D0*DSQRT(beta))
    tempb2 = 0.5d0*betab/pr
    rhob = rhob + tempb2 - pr*pr_by_rhob/rho**2 + (un*a2pos+b2)*gypb(1)
    gypb(1) = 0.D0
    prb = pr_by_rhob/rho - rho*tempb2/pr
    u1b = tx*utb + nx*unb
    u2b = ty*utb + ny*unb
    txb = u1*utb
    nyb = nyb + txb + u2*unb
    tyb = u2*utb
    nxb = nxb + u1*unb - tyb
  END SUBROUTINE FLUX_GYP_B

  SUBROUTINE FLUX_GYP(gyp, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: gyp(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta, s2, b2, a2pos
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: result1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s2 = un*DSQRT(beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    gyp(1) = rho*(un*a2pos+b2)
    temp1 = pr_by_rho + un*un
    temp2 = temp1*a2pos + un*b2
    gyp(3) = rho*temp2
    temp1 = ut*un*a2pos + ut*b2
    gyp(2) = rho*temp1
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*un*temp1*a2pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    gyp(4) = rho*(temp2+0.5d0*temp1*b2)
  END SUBROUTINE FLUX_GYP

!  Differentiation of flux_gyn in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: nx ny gyn
!   with respect to varying inputs: nx ny gyn u1 u2 pr rho
  SUBROUTINE FLUX_GYN_B(gyn, gynb, nx, nxb, ny, nyb, u1, u1b, u2, u2b, &
&   rho, rhob, pr, prb)
    IMPLICIT NONE
    DOUBLE PRECISION :: gyn(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gynb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: beta, s2, b2, a2neg
    DOUBLE PRECISION :: betab, s2b, b2b, a2negb
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: temp1b, temp2b
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: tempb2
    DOUBLE PRECISION :: tempb3
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s2 = un*DSQRT(beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.0d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*un*temp1*a2neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp = DSQRT(beta)
    tempb = rho*gynb(4)
    rhob = (temp2-0.5d0*(temp1*b2))*gynb(4)
    temp2b = tempb
    temp1b = -(0.5d0*b2*tempb)
    b2b = -(0.5d0*temp1*tempb)
    gynb(4) = 0.D0
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    tempb0 = 0.5d0*a2neg*temp2b
    temp1b = un*tempb0
    a2negb = 0.5d0*un*temp1*temp2b
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    temp1b = rho*gynb(2)
    unb = a2neg*ut*temp1b + temp1*tempb0
    temp1 = ut*un*a2neg - ut*b2
    rhob = rhob + temp1*gynb(2)
    gynb(2) = 0.D0
    utb = 2*ut*u_sqrb + (a2neg*un-b2)*temp1b
    temp1 = pr_by_rho + un*un
    temp2 = temp1*a2neg - un*b2
    rhob = rhob + temp2*gynb(3)
    temp2b = rho*gynb(3)
    gynb(3) = 0.D0
    tempb1 = rho*gynb(1)
    a2negb = a2negb + temp1*temp2b + un*tempb1 + ut*un*temp1b
    b2b = b2b - un*temp2b - tempb1 - ut*temp1b
    temp1b = a2neg*temp2b
    pr_by_rhob = pr_by_rhob + temp1b
    result1b = -(0.5d0*a2negb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0
    CALL DERF_B(s2, s2b, result1b)
    CALL POPREAL8(s2)
    temp0 = DSQRT(pi*beta)
    tempb3 = 0.5d0*b2b/temp0
    s2b = s2b - DEXP(-(s2**2))*2*s2*tempb3
    unb = unb + 2*un*temp1b + 2*un*u_sqrb + temp*s2b + a2neg*tempb1 - b2&
&     *temp2b
    IF (pi*beta .EQ. 0.0) THEN
      betab = 0.0
    ELSE
      betab = -(DEXP(-(s2**2))*pi*tempb3/(2.D0*DSQRT(pi*beta)*temp0))
    END IF
    IF (.NOT.beta .EQ. 0.0) betab = betab + un*s2b/(2.D0*DSQRT(beta))
    tempb2 = 0.5d0*betab/pr
    rhob = rhob + tempb2 - pr*pr_by_rhob/rho**2 + (un*a2neg-b2)*gynb(1)
    gynb(1) = 0.D0
    prb = pr_by_rhob/rho - rho*tempb2/pr
    u1b = tx*utb + nx*unb
    u2b = ty*utb + ny*unb
    txb = u1*utb
    nyb = nyb + txb + u2*unb
    tyb = u2*utb
    nxb = nxb + u1*unb - tyb
  END SUBROUTINE FLUX_GYN_B

  SUBROUTINE FLUX_GYN(gyn, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: gyn(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta, s2, b2, a2neg
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: result1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s2 = un*DSQRT(beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.0d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    gyn(1) = rho*(un*a2neg-b2)
    temp1 = pr_by_rho + un*un
    temp2 = temp1*a2neg - un*b2
    gyn(3) = rho*temp2
    temp1 = ut*un*a2neg - ut*b2
    gyn(2) = rho*temp1
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*un*temp1*a2neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    gyn(4) = rho*(temp2-0.5d0*temp1*b2)
  END SUBROUTINE FLUX_GYN

END MODULE SPLIT_FLUXES_MOD_DIFF

