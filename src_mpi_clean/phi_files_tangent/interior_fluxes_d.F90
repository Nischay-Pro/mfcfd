!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE INTERIOR_FLUXES_MOD_DIFF
!	First written on 14.10.2016.
!	updated on Sep 23, 2017
!	
  USE DATA_STRUCTURE_MOD_DIFF
  USE SPLIT_FLUXES_MOD_DIFF
  USE Q_VARIABLES_MOD_DIFF
  USE LIMITERS_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of interior_dgx_pos in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: *(point.q) *(point.dq) *(point.ddq)
!                *(point.phi1) *(point.phi2)
!   Plus diff mem management of: point.q:in point.dq:in point.ddq:in
!                point.phi1:in point.phi2:in
!	This subroutine evaluates the interior flux derivative dGx_pos
  SUBROUTINE INTERIOR_DGX_POS_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
!		
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi1_i(4), phi1_k(4)
    REAL*8 :: phi1_id(4), phi1_kd(4)
    REAL*8 :: phi2_i(4), phi2_k(4)
    REAL*8 :: phi2_id(4), phi2_kd(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: maxi(4), mini(4)
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    phi1_id = pointd%phi1(:, i)
    phi1_i = point%phi1(:, i)
    phi2_id = pointd%phi2(:, i)
    phi2_i = point%phi2(:, i)
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      phi1_kd = pointd%phi1(:, k)
      phi1_k = point%phi1(:, k)
      phi2_kd = pointd%phi2(:, k)
      phi2_k = point%phi2(:, k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(phi1_id*(delx*point%dq(1, :, i&
&       )+dely*point%dq(2, :, i))+phi1_i*(delx*pointd%dq(1, :, i)+dely*&
&       pointd%dq(2, :, i))) + (phi2_id*(delx*delx*point%ddq(1, :, i)+&
&       2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :, i))+&
&       phi2_i*(delx**2*pointd%ddq(1, :, i)+2.0*delx*dely*pointd%ddq(2, &
&       :, i)+dely**2*pointd%ddq(3, :, i)))/12d0
      qtilde_i = point%q(:, i) - 0.5d0*phi1_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i)) + 1/12d0*phi2_i*(delx*delx*point%ddq(1, &
&       :, i)+2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :&
&       , i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(phi1_kd*(delx*point%dq(1, :, k&
&       )+dely*point%dq(2, :, k))+phi1_k*(delx*pointd%dq(1, :, k)+dely*&
&       pointd%dq(2, :, k))) + (phi2_kd*(delx*delx*point%ddq(1, :, k)+&
&       2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :, k))+&
&       phi2_k*(delx**2*pointd%ddq(1, :, k)+2.0*delx*dely*pointd%ddq(2, &
&       :, k)+dely**2*pointd%ddq(3, :, k)))/12d0
      qtilde_k = point%q(:, k) - 0.5d0*phi1_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k)) + 1/12d0*phi2_k*(delx*delx*point%ddq(1, &
&       :, k)+2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :&
&       , k))
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GXP_D(g_i, g_id, nx, ny, u1, u1d, u2, u2d, rho, rhod, pr&
&               , prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GXP_D(g_k, g_kd, nx, ny, u1, u1d, u2, u2d, rho, rhod, pr&
&               , prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id)
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    gd = one_by_det*(sum_dely_sqr*sum_delx_delfd-sum_delx_dely*&
&     sum_dely_delfd)
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGX_POS_D

!	This subroutine evaluates the interior flux derivative dGx_pos
  SUBROUTINE INTERIOR_DGX_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
!		
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi1_i(4), phi1_k(4)
    REAL*8 :: phi2_i(4), phi2_k(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: maxi(4), mini(4)
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    phi1_i = point%phi1(:, i)
    phi2_i = point%phi2(:, i)
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      phi1_k = point%phi1(:, k)
      phi2_k = point%phi2(:, k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*phi1_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i)) + 1/12d0*phi2_i*(delx*delx*point%ddq(1, &
&       :, i)+2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :&
&       , i))
      qtilde_k = point%q(:, k) - 0.5d0*phi1_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k)) + 1/12d0*phi2_k*(delx*delx*point%ddq(1, &
&       :, k)+2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :&
&       , k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GXP(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GXP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGX_POS

!  Differentiation of interior_dgx_neg in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: *(point.q) *(point.dq) *(point.ddq)
!                *(point.phi1) *(point.phi2)
!   Plus diff mem management of: point.q:in point.dq:in point.ddq:in
!                point.phi1:in point.phi2:in
!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGX_NEG_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi1_i(4), phi1_k(4)
    REAL*8 :: phi1_id(4), phi1_kd(4)
    REAL*8 :: phi2_i(4), phi2_k(4)
    REAL*8 :: phi2_id(4), phi2_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    phi1_id = pointd%phi1(:, i)
    phi1_i = point%phi1(:, i)
    phi2_id = pointd%phi2(:, i)
    phi2_i = point%phi2(:, i)
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      phi1_kd = pointd%phi1(:, k)
      phi1_k = point%phi1(:, k)
      phi2_kd = pointd%phi2(:, k)
      phi2_k = point%phi2(:, k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(phi1_id*(delx*point%dq(1, :, i&
&       )+dely*point%dq(2, :, i))+phi1_i*(delx*pointd%dq(1, :, i)+dely*&
&       pointd%dq(2, :, i))) + (phi2_id*(delx*delx*point%ddq(1, :, i)+&
&       2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :, i))+&
&       phi2_i*(delx**2*pointd%ddq(1, :, i)+2.0*delx*dely*pointd%ddq(2, &
&       :, i)+dely**2*pointd%ddq(3, :, i)))/12d0
      qtilde_i = point%q(:, i) - 0.5d0*phi1_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i)) + 1/12d0*phi2_i*(delx*delx*point%ddq(1, &
&       :, i)+2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :&
&       , i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(phi1_kd*(delx*point%dq(1, :, k&
&       )+dely*point%dq(2, :, k))+phi1_k*(delx*pointd%dq(1, :, k)+dely*&
&       pointd%dq(2, :, k))) + (phi2_kd*(delx*delx*point%ddq(1, :, k)+&
&       2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :, k))+&
&       phi2_k*(delx**2*pointd%ddq(1, :, k)+2.0*delx*dely*pointd%ddq(2, &
&       :, k)+dely**2*pointd%ddq(3, :, k)))/12d0
      qtilde_k = point%q(:, k) - 0.5d0*phi1_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k)) + 1/12d0*phi2_k*(delx*delx*point%ddq(1, &
&       :, k)+2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :&
&       , k))
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GXN_D(g_i, g_id, nx, ny, u1, u1d, u2, u2d, rho, rhod, pr&
&               , prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GXN_D(g_k, g_kd, nx, ny, u1, u1d, u2, u2d, rho, rhod, pr&
&               , prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id)
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    gd = one_by_det*(sum_dely_sqr*sum_delx_delfd-sum_delx_dely*&
&     sum_dely_delfd)
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGX_NEG_D

!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGX_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi1_i(4), phi1_k(4)
    REAL*8 :: phi2_i(4), phi2_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    phi1_i = point%phi1(:, i)
    phi2_i = point%phi2(:, i)
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      phi1_k = point%phi1(:, k)
      phi2_k = point%phi2(:, k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*phi1_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i)) + 1/12d0*phi2_i*(delx*delx*point%ddq(1, &
&       :, i)+2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :&
&       , i))
      qtilde_k = point%q(:, k) - 0.5d0*phi1_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k)) + 1/12d0*phi2_k*(delx*delx*point%ddq(1, &
&       :, k)+2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :&
&       , k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GXN(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GXN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGX_NEG

!  Differentiation of interior_dgy_pos in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: *(point.q) *(point.dq) *(point.ddq)
!                *(point.phi1) *(point.phi2)
!   Plus diff mem management of: point.q:in point.dq:in point.ddq:in
!                point.phi1:in point.phi2:in
!	This subroutine evaluates the interior flux derivative dGx_neg
!
!
  SUBROUTINE INTERIOR_DGY_POS_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi1_i(4), phi1_k(4)
    REAL*8 :: phi1_id(4), phi1_kd(4)
    REAL*8 :: phi2_i(4), phi2_k(4)
    REAL*8 :: phi2_id(4), phi2_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    phi1_id = pointd%phi1(:, i)
    phi1_i = point%phi1(:, i)
    phi2_id = pointd%phi2(:, i)
    phi2_i = point%phi2(:, i)
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%ypos_nbhs(i)
      k = point%ypos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      phi1_kd = pointd%phi1(:, k)
      phi1_k = point%phi1(:, k)
      phi2_kd = pointd%phi2(:, k)
      phi2_k = point%phi2(:, k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(phi1_id*(delx*point%dq(1, :, i&
&       )+dely*point%dq(2, :, i))+phi1_i*(delx*pointd%dq(1, :, i)+dely*&
&       pointd%dq(2, :, i))) + (phi2_id*(delx*delx*point%ddq(1, :, i)+&
&       2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :, i))+&
&       phi2_i*(delx**2*pointd%ddq(1, :, i)+2.0*delx*dely*pointd%ddq(2, &
&       :, i)+dely**2*pointd%ddq(3, :, i)))/12d0
      qtilde_i = point%q(:, i) - 0.5d0*phi1_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i)) + 1/12d0*phi2_i*(delx*delx*point%ddq(1, &
&       :, i)+2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :&
&       , i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(phi1_kd*(delx*point%dq(1, :, k&
&       )+dely*point%dq(2, :, k))+phi1_k*(delx*pointd%dq(1, :, k)+dely*&
&       pointd%dq(2, :, k))) + (phi2_kd*(delx*delx*point%ddq(1, :, k)+&
&       2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :, k))+&
&       phi2_k*(delx**2*pointd%ddq(1, :, k)+2.0*delx*dely*pointd%ddq(2, &
&       :, k)+dely**2*pointd%ddq(3, :, k)))/12d0
      qtilde_k = point%q(:, k) - 0.5d0*phi1_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k)) + 1/12d0*phi2_k*(delx*delx*point%ddq(1, &
&       :, k)+2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :&
&       , k))
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GYP_D(g_i, g_id, nx, ny, u1, u1d, u2, u2d, rho, rhod, pr&
&               , prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GYP_D(g_k, g_kd, nx, ny, u1, u1d, u2, u2d, rho, rhod, pr&
&               , prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id)
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    gd = one_by_det*(sum_delx_sqr*sum_dely_delfd-sum_delx_dely*&
&     sum_delx_delfd)
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGY_POS_D

!	This subroutine evaluates the interior flux derivative dGx_neg
!
!
  SUBROUTINE INTERIOR_DGY_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi1_i(4), phi1_k(4)
    REAL*8 :: phi2_i(4), phi2_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    phi1_i = point%phi1(:, i)
    phi2_i = point%phi2(:, i)
    DO j=1,point%ypos_nbhs(i)
      k = point%ypos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      phi1_k = point%phi1(:, k)
      phi2_k = point%phi2(:, k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*phi1_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i)) + 1/12d0*phi2_i*(delx*delx*point%ddq(1, &
&       :, i)+2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :&
&       , i))
      qtilde_k = point%q(:, k) - 0.5d0*phi1_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k)) + 1/12d0*phi2_k*(delx*delx*point%ddq(1, &
&       :, k)+2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :&
&       , k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GYP(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GYP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGY_POS

!  Differentiation of interior_dgy_neg in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: *(point.q) *(point.dq) *(point.ddq)
!                *(point.phi1) *(point.phi2)
!   Plus diff mem management of: point.q:in point.dq:in point.ddq:in
!                point.phi1:in point.phi2:in
!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGY_NEG_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi1_i(4), phi1_k(4)
    REAL*8 :: phi1_id(4), phi1_kd(4)
    REAL*8 :: phi2_i(4), phi2_k(4)
    REAL*8 :: phi2_id(4), phi2_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    phi1_id = pointd%phi1(:, i)
    phi1_i = point%phi1(:, i)
    phi2_id = pointd%phi2(:, i)
    phi2_i = point%phi2(:, i)
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%yneg_nbhs(i)
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      phi1_kd = pointd%phi1(:, k)
      phi1_k = point%phi1(:, k)
      phi2_kd = pointd%phi2(:, k)
      phi2_k = point%phi2(:, k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(phi1_id*(delx*point%dq(1, :, i&
&       )+dely*point%dq(2, :, i))+phi1_i*(delx*pointd%dq(1, :, i)+dely*&
&       pointd%dq(2, :, i))) + (phi2_id*(delx*delx*point%ddq(1, :, i)+&
&       2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :, i))+&
&       phi2_i*(delx**2*pointd%ddq(1, :, i)+2.0*delx*dely*pointd%ddq(2, &
&       :, i)+dely**2*pointd%ddq(3, :, i)))/12d0
      qtilde_i = point%q(:, i) - 0.5d0*phi1_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i)) + 1/12d0*phi2_i*(delx*delx*point%ddq(1, &
&       :, i)+2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :&
&       , i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(phi1_kd*(delx*point%dq(1, :, k&
&       )+dely*point%dq(2, :, k))+phi1_k*(delx*pointd%dq(1, :, k)+dely*&
&       pointd%dq(2, :, k))) + (phi2_kd*(delx*delx*point%ddq(1, :, k)+&
&       2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :, k))+&
&       phi2_k*(delx**2*pointd%ddq(1, :, k)+2.0*delx*dely*pointd%ddq(2, &
&       :, k)+dely**2*pointd%ddq(3, :, k)))/12d0
      qtilde_k = point%q(:, k) - 0.5d0*phi1_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k)) + 1/12d0*phi2_k*(delx*delx*point%ddq(1, &
&       :, k)+2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :&
&       , k))
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GYN_D(g_i, g_id, nx, ny, u1, u1d, u2, u2d, rho, rhod, pr&
&               , prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GYN_D(g_k, g_kd, nx, ny, u1, u1d, u2, u2d, rho, rhod, pr&
&               , prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id)
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    gd = one_by_det*(sum_delx_sqr*sum_dely_delfd-sum_delx_dely*&
&     sum_delx_delfd)
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGY_NEG_D

!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGY_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi1_i(4), phi1_k(4)
    REAL*8 :: phi2_i(4), phi2_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    phi1_i = point%phi1(:, i)
    phi2_i = point%phi2(:, i)
    DO j=1,point%yneg_nbhs(i)
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      phi1_k = point%phi1(:, k)
      phi2_k = point%phi2(:, k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*phi1_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i)) + 1/12d0*phi2_i*(delx*delx*point%ddq(1, &
&       :, i)+2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :&
&       , i))
      qtilde_k = point%q(:, k) - 0.5d0*phi1_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k)) + 1/12d0*phi2_k*(delx*delx*point%ddq(1, &
&       :, k)+2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :&
&       , k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GYN(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GYN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGY_NEG

END MODULE INTERIOR_FLUXES_MOD_DIFF

