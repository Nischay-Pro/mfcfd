!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
MODULE GENERATE_CONNECTIVITY_MOD_DIFF
  USE DATA_STRUCTURE_MOD_DIFF
  USE PETSC_DATA_STRUCTURE_MOD
  IMPLICIT NONE

CONTAINS
  SUBROUTINE GENERATE_CONNECTIVITY()
    IMPLICIT NONE
    INTEGER :: i, k
    REAL*8 :: nx, ny
    DO k=1,interior_points
      i = interior_points_index(k)
      nx = point%nx(i)
      ny = point%ny(i)
      CALL GET_INTERIOR_NEIGHBOURS(i, nx, ny)
      CALL CHECK_CONDITION_NUMBER(i, nx, ny)
    END DO
    DO k=1,wall_points
      i = wall_points_index(k)
      nx = point%nx(i)
      ny = point%ny(i)
      CALL GET_WALL_BOUNDARY_NEIGHBOURS(i, nx, ny)
    END DO
    DO k=1,outer_points
      i = outer_points_index(k)
      nx = point%nx(i)
      ny = point%ny(i)
      CALL GET_OUTER_BOUNDARY_NEIGHBOURS(i, nx, ny)
    END DO
  END SUBROUTINE GENERATE_CONNECTIVITY

  SUBROUTINE GET_INTERIOR_NEIGHBOURS(i, nx, ny)
    IMPLICIT NONE
    REAL*8 :: xi, yi, xk, yk
    REAL*8 :: delx, dely, dels, deln
    REAL*8 :: nx, ny, tx, ty
    INTEGER :: i, r, count, nbh
    TYPE(UNKNOWNTYPE) :: rank
    xi = point%x(i)
    yi = point%y(i)
    tx = ny
    ty = -nx
    point%xpos_nbhs(i) = 0
    point%xneg_nbhs(i) = 0
    point%ypos_nbhs(i) = 0
    point%yneg_nbhs(i) = 0
    DO r=1,point%nbhs(i)
      nbh = point%conn(i, r)
      xk = point%x(nbh)
      yk = point%y(nbh)
      delx = xk - xi
      dely = yk - yi
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      IF (dels .LE. 0.0d0) THEN
        point%xpos_nbhs(i) = point%xpos_nbhs(i) + 1
        count = point%xpos_nbhs(i)
        point%xpos_conn(i, count) = nbh
      END IF
      IF (dels .GE. 0.0d0) THEN
        point%xneg_nbhs(i) = point%xneg_nbhs(i) + 1
        count = point%xneg_nbhs(i)
        point%xneg_conn(i, count) = nbh
      END IF
      IF (deln .LE. 0.0d0) THEN
        point%ypos_nbhs(i) = point%ypos_nbhs(i) + 1
        count = point%ypos_nbhs(i)
        point%ypos_conn(i, count) = nbh
      END IF
      IF (deln .GE. 0.0d0) THEN
        point%yneg_nbhs(i) = point%yneg_nbhs(i) + 1
        count = point%yneg_nbhs(i)
        point%yneg_conn(i, count) = nbh
      END IF
    END DO
    IF (point%xpos_nbhs(i) .EQ. 0) THEN
      PRINT*, 'WARNING!!! xpos zero for interior point number:', i, ', rank:', rank
    ELSE IF (point%xneg_nbhs(i) .EQ. 0) THEN
      PRINT*, 'WARNING!!! xneg zero for interior point number:', i, ', rank:', rank
    ELSE IF (point%ypos_nbhs(i) .EQ. 0) THEN
      PRINT*, 'WARNING!!! ypos zero for interior point number:', i, ', rank:', rank
    ELSE IF (point%yneg_nbhs(i) .EQ. 0) THEN
      PRINT*, 'WARNING!!! yneg zero for interior point number:', i, ', rank:', rank
    END IF
  END SUBROUTINE GET_INTERIOR_NEIGHBOURS

  SUBROUTINE GET_WALL_BOUNDARY_NEIGHBOURS(i, nx, ny)
    IMPLICIT NONE
    REAL*8 :: xi, yi, xk, yk
    REAL*8 :: delx, dely, dels, deln
    REAL*8 :: nx, ny, tx, ty
    INTEGER :: i, r, count, nbh
    TYPE(UNKNOWNTYPE) :: rank
    xi = point%x(i)
    yi = point%y(i)
    tx = ny
    ty = -nx
    point%xpos_nbhs(i) = 0
    point%xneg_nbhs(i) = 0
    point%yneg_nbhs(i) = 0
    DO r=1,point%nbhs(i)
      nbh = point%conn(i, r)
      xk = point%x(nbh)
      yk = point%y(nbh)
      delx = xk - xi
      dely = yk - yi
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      IF (dels .LE. 0.0d0) THEN
        point%xpos_nbhs(i) = point%xpos_nbhs(i) + 1
        count = point%xpos_nbhs(i)
        point%xpos_conn(i, count) = nbh
      END IF
      IF (dels .GE. 0.0d0) THEN
        point%xneg_nbhs(i) = point%xneg_nbhs(i) + 1
        count = point%xneg_nbhs(i)
        point%xneg_conn(i, count) = nbh
      END IF
      point%yneg_nbhs(i) = point%yneg_nbhs(i) + 1
      count = point%yneg_nbhs(i)
      point%yneg_conn(i, count) = nbh
    END DO
    IF (point%xpos_nbhs(i) .EQ. 0) THEN
      PRINT*, 'WARNING!!! xpos zero for wall point number:', i, ', rank:', rank
    ELSE IF (point%xneg_nbhs(i) .EQ. 0) THEN
      PRINT*, 'WARNING!!! xneg zero for wall point number:', i, ', rank:', rank
    ELSE IF (point%yneg_nbhs(i) .EQ. 0) THEN
      PRINT*, 'WARNING!!! yneg zero for wall point number:', i, ', rank:', rank
    END IF
  END SUBROUTINE GET_WALL_BOUNDARY_NEIGHBOURS

  SUBROUTINE GET_OUTER_BOUNDARY_NEIGHBOURS(i, nx, ny)
    IMPLICIT NONE
    REAL*8 :: xi, yi, xk, yk
    REAL*8 :: delx, dely, dels, deln
    REAL*8 :: nx, ny, tx, ty
    INTEGER :: i, r, count, nbh
    TYPE(UNKNOWNTYPE) :: rank
    xi = point%x(i)
    yi = point%y(i)
    tx = ny
    ty = -nx
    point%xpos_nbhs(i) = 0
    point%xneg_nbhs(i) = 0
    point%ypos_nbhs(i) = 0
    DO r=1,point%nbhs(i)
      nbh = point%conn(i, r)
      xk = point%x(nbh)
      yk = point%y(nbh)
      delx = xk - xi
      dely = yk - yi
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      IF (dels .LE. 0.0d0) THEN
        point%xpos_nbhs(i) = point%xpos_nbhs(i) + 1
        count = point%xpos_nbhs(i)
        point%xpos_conn(i, count) = nbh
      END IF
      IF (dels .GE. 0.0d0) THEN
        point%xneg_nbhs(i) = point%xneg_nbhs(i) + 1
        count = point%xneg_nbhs(i)
        point%xneg_conn(i, count) = nbh
      END IF
      point%ypos_nbhs(i) = point%ypos_nbhs(i) + 1
      count = point%ypos_nbhs(i)
      point%ypos_conn(i, count) = nbh
    END DO
    IF (point%xpos_nbhs(i) .EQ. 0) THEN
      PRINT*, 'WARNING!!! xpos zero for outer point number:', i, ', rank:', rank
    ELSE IF (point%xneg_nbhs(i) .EQ. 0) THEN
      PRINT*, 'WARNING!!! xneg zero for outer point number:', i, ', rank:', rank
    ELSE IF (point%ypos_nbhs(i) .EQ. 0) THEN
      PRINT*, 'WARNING!!! ypos zero for outer point number:', i, ', rank:', rank
    END IF
  END SUBROUTINE GET_OUTER_BOUNDARY_NEIGHBOURS

  SUBROUTINE CHECK_CONDITION_NUMBER(i, nx, ny)
    IMPLICIT NONE
    INTEGER :: i
    REAL*8 :: nx, ny
  END SUBROUTINE CHECK_CONDITION_NUMBER

END MODULE GENERATE_CONNECTIVITY_MOD_DIFF

