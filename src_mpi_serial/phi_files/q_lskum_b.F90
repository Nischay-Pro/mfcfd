!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE Q_LSKUM_MOD_DIFF
!	First written on 14.10.2016
!	updated on Dec 26, 2016
!	updated on Dec 29, 2016
  USE DATA_STRUCTURE_MOD_DIFF
  USE POINT_NORMALS_MOD_DIFF
  USE GENERATE_CONNECTIVITY_MOD_DIFF
  USE FPI_SOLVER_MOD_DIFF
  USE INITIAL_CONDITIONS_MOD
  USE IEEE_ARITHMETIC
  IMPLICIT NONE

CONTAINS
!  Differentiation of q_lskum in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: cost_func
!   with respect to varying inputs: *(point.phi1) *(point.phi2)
!   RW status of diff variables: cost_func:in-killed *(point.prim):(loc)
!                *(point.prim_old):(loc) *(point.flux_res):(loc)
!                *(point.q):(loc) *(point.dq):(loc) *(point.ddq):(loc)
!                *(point.temp):(loc) *(point.phi1):out *(point.phi2):out
!                *(point.delta):(loc)
!   Plus diff mem management of: point.prim:in point.prim_old:in
!                point.flux_res:in point.q:in point.dq:in point.ddq:in
!                point.temp:in point.phi1:in point.phi2:in point.delta:in
  SUBROUTINE Q_LSKUM_B()
    USE DIFFSIZES
!  Hint: ISIZE1OFDrfpoint_delta should be the size of dimension 1 of array *point%delta
!  Hint: ISIZE3OFDrfpoint_temp should be the size of dimension 3 of array *point%temp
!  Hint: ISIZE2OFDrfpoint_temp should be the size of dimension 2 of array *point%temp
!  Hint: ISIZE1OFDrfpoint_temp should be the size of dimension 1 of array *point%temp
!  Hint: ISIZE3OFDrfpoint_ddq should be the size of dimension 3 of array *point%ddq
!  Hint: ISIZE2OFDrfpoint_ddq should be the size of dimension 2 of array *point%ddq
!  Hint: ISIZE1OFDrfpoint_ddq should be the size of dimension 1 of array *point%ddq
!  Hint: ISIZE3OFDrfpoint_qm should be the size of dimension 3 of array *point%qm
!  Hint: ISIZE2OFDrfpoint_qm should be the size of dimension 2 of array *point%qm
!  Hint: ISIZE1OFDrfpoint_qm should be the size of dimension 1 of array *point%qm
!  Hint: ISIZE3OFDrfpoint_dq should be the size of dimension 3 of array *point%dq
!  Hint: ISIZE2OFDrfpoint_dq should be the size of dimension 2 of array *point%dq
!  Hint: ISIZE1OFDrfpoint_dq should be the size of dimension 1 of array *point%dq
!  Hint: ISIZE2OFDrfpoint_q should be the size of dimension 2 of array *point%q
!  Hint: ISIZE1OFDrfpoint_q should be the size of dimension 1 of array *point%q
!  Hint: ISIZE2OFDrfpoint_flux_res should be the size of dimension 2 of array *point%flux_res
!  Hint: ISIZE1OFDrfpoint_flux_res should be the size of dimension 1 of array *point%flux_res
!  Hint: ISIZE2OFDrfpoint_prim_old should be the size of dimension 2 of array *point%prim_old
!  Hint: ISIZE1OFDrfpoint_prim_old should be the size of dimension 1 of array *point%prim_old
!  Hint: ISIZE2OFDrfpoint_prim should be the size of dimension 2 of array *point%prim
!  Hint: ISIZE1OFDrfpoint_prim should be the size of dimension 1 of array *point%prim
    IMPLICIT NONE
    INTEGER :: i
    EXTERNAL IEEE_IS_NAN
    LOGICAL :: IEEE_IS_NAN
    LOGICAL :: res
    INTEGER :: branch
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: rank
    IF (rank .EQ. 0) OPEN(unit=301, file='residue', form='FORMATTED', &
&                   status='REPLACE', action='WRITE') 
    CALL COMPUTE_NORMALS()
    CALL GENERATE_CONNECTIVITY()
    IF (rank .EQ. 0) THEN
      WRITE(*, *) 
      WRITE(*, *) '%%%%-Normals and connectivity generated-%%%'
      WRITE(*, *) 
    END IF
    DO i=1,local_points
      point%phi1(1, i) = 1.0d0
      point%phi1(2, i) = 1.0d0
      point%phi1(3, i) = 1.0d0
      point%phi1(4, i) = 1.0d0
      point%phi2(1, i) = 1.0d0
      point%phi2(2, i) = 1.0d0
      point%phi2(3, i) = 1.0d0
      point%phi2(4, i) = 1.0d0
    END DO
    DO i=1,ghost_points
      point%phi1(1, i+local_points) = 1.0d0
      point%phi1(2, i+local_points) = 1.0d0
      point%phi1(3, i+local_points) = 1.0d0
      point%phi1(4, i+local_points) = 1.0d0
      point%phi2(1, i+local_points) = 1.0d0
      point%phi2(2, i+local_points) = 1.0d0
      point%phi2(3, i+local_points) = 1.0d0
      point%phi2(4, i+local_points) = 1.0d0
    END DO
    IF (rank .EQ. 0) THEN
      WRITE(*, *) '%%%%%%%%%%%%%-Iterations begin-%%%%%%%%%%%%'
      WRITE(*, *) 
    END IF
    t = 0.0d0
    IF (restart .EQ. 0) itr = 0
    ad_count = 1
    DO it=itr+1,itr+max_iters
      CALL PUSHREAL8(gsum_res_sqr)
      CALL PUSHREAL8ARRAY(point%delta, ISIZE1OFDrfpoint_delta)
      CALL PUSHREAL8ARRAY(point%temp, ISIZE1OFDrfpoint_temp*&
&                   ISIZE2OFDrfpoint_temp*ISIZE3OFDrfpoint_temp)
      CALL PUSHREAL8ARRAY(point%ddq, ISIZE1OFDrfpoint_ddq*&
&                   ISIZE2OFDrfpoint_ddq*ISIZE3OFDrfpoint_ddq)
      CALL PUSHREAL8ARRAY(point%qm, ISIZE1OFDrfpoint_qm*&
&                   ISIZE2OFDrfpoint_qm*ISIZE3OFDrfpoint_qm)
      CALL PUSHREAL8ARRAY(point%dq, ISIZE1OFDrfpoint_dq*&
&                   ISIZE2OFDrfpoint_dq*ISIZE3OFDrfpoint_dq)
      CALL PUSHREAL8ARRAY(point%q, ISIZE1OFDrfpoint_q*ISIZE2OFDrfpoint_q&
&                  )
      CALL PUSHREAL8ARRAY(point%flux_res, ISIZE1OFDrfpoint_flux_res*&
&                   ISIZE2OFDrfpoint_flux_res)
      CALL PUSHREAL8ARRAY(point%prim_old, ISIZE1OFDrfpoint_prim_old*&
&                   ISIZE2OFDrfpoint_prim_old)
      CALL PUSHREAL8ARRAY(point%prim, ISIZE1OFDrfpoint_prim*&
&                   ISIZE2OFDrfpoint_prim)
      CALL PUSHREAL8(sum_res_sqr)
      CALL FPI_SOLVER(it)
      t = t + dtg
      IF (rank .EQ. 0) THEN
        IF (timestep .EQ. 0) THEN
          CALL PUSHCONTROL1B(0)
          WRITE(*, '(a12,i8,a15,e30.20)') 'iterations:', it, 'residue:'&
&         , residue
          WRITE(301, *) it, residue
        ELSE IF (timestep .EQ. 1) THEN
          CALL PUSHCONTROL1B(1)
          WRITE(*, '(a12,i8,a15,e30.20)') 'iterations:', it, 'time:', t
          WRITE(301, *) it, t, dtg
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        res = IEEE_IS_NAN(residue)
        IF (res) THEN
          GOTO 100
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      ad_count = ad_count + 1
    END DO
    CALL PUSHCONTROL1B(0)
    CALL PUSHINTEGER4(ad_count)
    GOTO 110
 100 CALL PUSHCONTROL1B(1)
    CALL PUSHINTEGER4(ad_count)
 110 CLOSE(unit=301) 
    CALL POPINTEGER4(ad_count)
    DO 130 i0=1,ad_count
      IF (i0 .EQ. 1) THEN
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          pointb%prim = 0.0_8
          pointb%prim_old = 0.0_8
          pointb%flux_res = 0.0_8
          pointb%q = 0.0_8
          pointb%dq = 0.0_8
          pointb%ddq = 0.0_8
          pointb%temp = 0.0_8
          pointb%phi1 = 0.0_8
          pointb%phi2 = 0.0_8
          pointb%delta = 0.0_8
          GOTO 130
        ELSE
          pointb%prim = 0.0_8
          pointb%prim_old = 0.0_8
          pointb%flux_res = 0.0_8
          pointb%q = 0.0_8
          pointb%dq = 0.0_8
          pointb%ddq = 0.0_8
          pointb%temp = 0.0_8
          pointb%phi1 = 0.0_8
          pointb%phi2 = 0.0_8
          pointb%delta = 0.0_8
        END IF
      ELSE
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) GOTO 120
      END IF
      CALL POPCONTROL1B(branch)
 120  CALL POPREAL8(sum_res_sqr)
      CALL POPREAL8ARRAY(point%prim, ISIZE1OFDrfpoint_prim*&
&                  ISIZE2OFDrfpoint_prim)
      CALL POPREAL8ARRAY(point%prim_old, ISIZE1OFDrfpoint_prim_old*&
&                  ISIZE2OFDrfpoint_prim_old)
      CALL POPREAL8ARRAY(point%flux_res, ISIZE1OFDrfpoint_flux_res*&
&                  ISIZE2OFDrfpoint_flux_res)
      CALL POPREAL8ARRAY(point%q, ISIZE1OFDrfpoint_q*ISIZE2OFDrfpoint_q)
      CALL POPREAL8ARRAY(point%dq, ISIZE1OFDrfpoint_dq*&
&                  ISIZE2OFDrfpoint_dq*ISIZE3OFDrfpoint_dq)
      CALL POPREAL8ARRAY(point%qm, ISIZE1OFDrfpoint_qm*&
&                  ISIZE2OFDrfpoint_qm*ISIZE3OFDrfpoint_qm)
      CALL POPREAL8ARRAY(point%ddq, ISIZE1OFDrfpoint_ddq*&
&                  ISIZE2OFDrfpoint_ddq*ISIZE3OFDrfpoint_ddq)
      CALL POPREAL8ARRAY(point%temp, ISIZE1OFDrfpoint_temp*&
&                  ISIZE2OFDrfpoint_temp*ISIZE3OFDrfpoint_temp)
      CALL POPREAL8ARRAY(point%delta, ISIZE1OFDrfpoint_delta)
      CALL POPREAL8(gsum_res_sqr)
      CALL FPI_SOLVER_B(it)
      cost_funcb = 0.0_8
 130 CONTINUE
    DO i=ghost_points,1,-1
      pointb%phi2(4, i+local_points) = 0.0_8
      pointb%phi2(3, i+local_points) = 0.0_8
      pointb%phi2(2, i+local_points) = 0.0_8
      pointb%phi2(1, i+local_points) = 0.0_8
      pointb%phi1(4, i+local_points) = 0.0_8
      pointb%phi1(3, i+local_points) = 0.0_8
      pointb%phi1(2, i+local_points) = 0.0_8
      pointb%phi1(1, i+local_points) = 0.0_8
    END DO
    DO i=local_points,1,-1
      pointb%phi2(4, i) = 0.0_8
      pointb%phi2(3, i) = 0.0_8
      pointb%phi2(2, i) = 0.0_8
      pointb%phi2(1, i) = 0.0_8
      pointb%phi1(4, i) = 0.0_8
      pointb%phi1(3, i) = 0.0_8
      pointb%phi1(2, i) = 0.0_8
      pointb%phi1(1, i) = 0.0_8
    END DO
  END SUBROUTINE Q_LSKUM_B

  SUBROUTINE Q_LSKUM()
    IMPLICIT NONE
    INTEGER :: i
    EXTERNAL IEEE_IS_NAN
    LOGICAL :: IEEE_IS_NAN
    INTEGER :: rank
    IF (rank .EQ. 0) OPEN(unit=301, file='residue', form='FORMATTED', &
&                   status='REPLACE', action='WRITE') 
    CALL COMPUTE_NORMALS()
    CALL GENERATE_CONNECTIVITY()
    IF (rank .EQ. 0) THEN
      WRITE(*, *) 
      WRITE(*, *) '%%%%-Normals and connectivity generated-%%%'
      WRITE(*, *) 
    END IF
    DO i=1,local_points
      point%phi1(1, i) = 1.0d0
      point%phi1(2, i) = 1.0d0
      point%phi1(3, i) = 1.0d0
      point%phi1(4, i) = 1.0d0
      point%phi2(1, i) = 1.0d0
      point%phi2(2, i) = 1.0d0
      point%phi2(3, i) = 1.0d0
      point%phi2(4, i) = 1.0d0
    END DO
    DO i=1,ghost_points
      point%phi1(1, i+local_points) = 1.0d0
      point%phi1(2, i+local_points) = 1.0d0
      point%phi1(3, i+local_points) = 1.0d0
      point%phi1(4, i+local_points) = 1.0d0
      point%phi2(1, i+local_points) = 1.0d0
      point%phi2(2, i+local_points) = 1.0d0
      point%phi2(3, i+local_points) = 1.0d0
      point%phi2(4, i+local_points) = 1.0d0
    END DO
! Set U_old to U for first iteration
    DO i=1,local_points
      point%u_old(1, i) = point%prim(1, i)
      point%u_old(2, i) = point%prim(1, i)*point%prim(2, i)
      point%u_old(3, i) = point%prim(1, i)*point%prim(3, i)
      point%u_old(4, i) = 2.5d0*point%prim(4, i) + 0.5d0*point%prim(1, i&
&       )*(point%prim(2, i)*point%prim(2, i)+point%prim(3, i)*point%prim&
&       (3, i))
    END DO
    IF (rank .EQ. 0) THEN
      WRITE(*, *) '%%%%%%%%%%%%%-Iterations begin-%%%%%%%%%%%%'
      WRITE(*, *) 
    END IF
    t = 0.0d0
    IF (restart .EQ. 0) itr = 0
    DO it=itr+1,itr+max_iters
      CALL FPI_SOLVER(it)
      t = t + dtg
      IF (rank .EQ. 0) THEN
        IF (timestep .EQ. 0) THEN
          WRITE(*, '(a12,i8,a15,e30.20)') 'iterations:', it, 'residue:'&
&         , residue
          WRITE(301, *) it, residue
        ELSE IF (timestep .EQ. 1) THEN
          WRITE(*, '(a12,i8,a15,e30.20)') 'iterations:', it, 'time:', t
          WRITE(301, *) it, t, dtg
        END IF
        IF (IEEE_IS_NAN(residue)) GOTO 100
      END IF
    END DO
 100 CLOSE(unit=301) 
  END SUBROUTINE Q_LSKUM

END MODULE Q_LSKUM_MOD_DIFF

