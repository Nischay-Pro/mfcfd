!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE QUADRANT_FLUXES_MOD_DIFF
!	This module consists of quadrant split fluxes
!	with respect to the x-coordinate direction ..
  USE PARAMETER_MOD
  IMPLICIT NONE
!
!

CONTAINS
!  Differentiation of flux_quad_gxi in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: g
!   with respect to varying inputs: g u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXI_B(g, gb, nx, ny, u1, u1b, u2, u2b, rho, rhob&
&   , pr, prb)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utb, unb
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betab
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1b, b1b, s2b, b2b
    DOUBLE PRECISION :: a1neg, a2neg
    DOUBLE PRECISION :: a1negb, a2negb
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    ! DOUBLE PRECISION :: DERF
    ! INTRINSIC DSQRT
    ! INTRINSIC DEXP
    ! EXTERNAL DERF
    ! EXTERNAL DERF_B
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: temp5
    DOUBLE PRECISION :: temp6
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: tempb2
    DOUBLE PRECISION :: tempb3
    DOUBLE PRECISION :: tempb4
    DOUBLE PRECISION :: tempb5
    DOUBLE PRECISION :: tempb6
    DOUBLE PRECISION :: tempb7
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.0d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1neg - b1
    temp = DSQRT(beta)
    temp0 = DSQRT(beta)
    tempb = rho*a2neg*gb(4)
    rhob = (temp2-temp3)*a2neg*gb(4)
    a2negb = (temp2-temp3)*rho*gb(4)
    temp2b = tempb
    temp3b = -tempb
    temp4b = -gb(4)
    gb(4) = 0.D0
    tempb0 = 0.5d0*b2*temp1*temp4b
    tempb1 = 0.5d0*rho*un*temp4b
    b2b = temp1*tempb1
    temp1b = b2*tempb1
    utb = a1neg*temp1b
    temp1 = 6.0d0*pr_by_rho + u_sqr
    b1b = 0.5d0*temp1*temp3b - temp1b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    a1negb = 0.5d0*ut*temp1*temp2b + ut*temp1b
    temp1b = 0.5d0*b1*temp3b
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    tempb2 = 0.5d0*a1neg*temp2b
    temp1b = ut*tempb2
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    temp2 = un*a2neg - b2
    temp1b = temp2*rho*gb(3)
    utb = utb + a1neg*temp1b + temp1*tempb2
    temp1 = ut*a1neg - b1
    rhob = rhob + temp2*temp1*gb(3) + un*tempb0
    temp2b = rho*temp1*gb(3)
    unb = a2neg*temp2b + rho*tempb0
    gb(3) = 0.D0
    b2b = b2b - temp2b
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    a2negb = a2negb + temp2*rho*gb(2) + un*temp2b
    rhob = rhob + temp2*a2neg*gb(2)
    temp2b = rho*a2neg*gb(2)
    gb(2) = 0.D0
    tempb4 = (ut*a1neg-b1)*gb(1)
    tempb3 = rho*a2neg*gb(1)
    a1negb = a1negb + temp1*temp2b + ut*tempb3 + ut*temp1b
    b1b = b1b - ut*temp2b - tempb3 - temp1b
    temp1b = a1neg*temp2b
    pr_by_rhob = pr_by_rhob + temp1b
    a2negb = a2negb + rho*tempb4
    gb(1) = 0.D0
    result1b = -(0.5d0*a2negb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0

    ! CALL DERF_B(s2, s2b, result1b)
    s2b = s2b + (2.0d0/dsqrt(pi))*dexp(-s2**2)*result1b

    CALL POPREAL8(s2)
    result1b = -(0.5d0*a1negb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0

    ! CALL DERF_B(s1, s1b, result1b)
    s1b = s1b + (2.0d0/dsqrt(pi))*dexp(-s1**2)*result1b

    CALL POPREAL8(s1)
    temp6 = DSQRT(pi*beta)
    tempb6 = 0.5d0*b2b/temp6
    s2b = s2b - DEXP(-(s2**2))*2*s2*tempb6
    unb = unb + temp0*s2b + 2*un*u_sqrb
    IF (pi*beta .EQ. 0.0) THEN
      betab = 0.0
    ELSE
      betab = -(DEXP(-(s2**2))*pi*tempb6/(2.D0*DSQRT(pi*beta)*temp6))
    END IF
    temp5 = DSQRT(pi*beta)
    tempb7 = 0.5d0*b1b/temp5
    s1b = s1b - DEXP(-(s1**2))*2*s1*tempb7
    utb = utb + 2*ut*temp1b + 2*ut*u_sqrb + temp*s1b + a1neg*tempb3 - b1&
&     *temp2b
    IF (.NOT.pi*beta .EQ. 0.0) betab = betab - DEXP(-(s1**2))*pi*tempb7/&
&       (2.D0*DSQRT(pi*beta)*temp5)
    IF (.NOT.beta .EQ. 0.0) betab = betab + un*s2b/(2.D0*DSQRT(beta))
    IF (.NOT.beta .EQ. 0.0) betab = betab + ut*s1b/(2.D0*DSQRT(beta))
    tempb5 = 0.5d0*betab/pr
    rhob = rhob + tempb5 - pr*pr_by_rhob/rho**2 + a2neg*tempb4
    prb = pr_by_rhob/rho - rho*tempb5/pr
    u1b = tx*utb + nx*unb
    u2b = ty*utb + ny*unb
  END SUBROUTINE FLUX_QUAD_GXI_B

  SUBROUTINE FLUX_QUAD_GXI(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1neg, a2neg
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    ! DOUBLE PRECISION :: DERF
    ! INTRINSIC DSQRT
    ! INTRINSIC DEXP
    ! EXTERNAL DERF
    DOUBLE PRECISION :: result1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.0d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..
    g(1) = rho*a2neg*(ut*a1neg-b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    g(2) = rho*a2neg*temp2
    temp1 = ut*a1neg - b1
    temp2 = un*a2neg - b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1neg - b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2neg*(temp2-temp3) - temp4
  END SUBROUTINE FLUX_QUAD_GXI

!  Differentiation of flux_quad_gxii in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: g
!   with respect to varying inputs: g u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXII_B(g, gb, nx, ny, u1, u1b, u2, u2b, rho, rhob&
&   , pr, prb)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utb, unb
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betab
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1b, b1b, s2b, b2b
    DOUBLE PRECISION :: a1pos, a2neg
    DOUBLE PRECISION :: a1posb, a2negb
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    ! DOUBLE PRECISION :: DERF
    ! INTRINSIC DSQRT
    ! INTRINSIC DEXP
    ! EXTERNAL DERF
    ! EXTERNAL DERF_B
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: temp5
    DOUBLE PRECISION :: temp6
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: tempb2
    DOUBLE PRECISION :: tempb3
    DOUBLE PRECISION :: tempb4
    DOUBLE PRECISION :: tempb5
    DOUBLE PRECISION :: tempb6
    DOUBLE PRECISION :: tempb7
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.d0+result1)
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1pos + b1
    temp = DSQRT(beta)
    temp0 = DSQRT(beta)
    tempb = rho*a2neg*gb(4)
    rhob = (temp2+temp3)*a2neg*gb(4)
    a2negb = (temp2+temp3)*rho*gb(4)
    temp2b = tempb
    temp3b = tempb
    temp4b = -gb(4)
    gb(4) = 0.D0
    tempb0 = 0.5d0*b2*temp1*temp4b
    tempb1 = 0.5d0*rho*un*temp4b
    b2b = temp1*tempb1
    temp1b = b2*tempb1
    utb = a1pos*temp1b
    temp1 = 6.0d0*pr_by_rho + u_sqr
    b1b = 0.5d0*temp1*temp3b + temp1b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    a1posb = 0.5d0*ut*temp1*temp2b + ut*temp1b
    temp1b = 0.5d0*b1*temp3b
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    tempb2 = 0.5d0*a1pos*temp2b
    temp1b = ut*tempb2
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    temp2 = un*a2neg - b2
    temp1b = temp2*rho*gb(3)
    utb = utb + a1pos*temp1b + temp1*tempb2
    temp1 = ut*a1pos + b1
    rhob = rhob + temp2*temp1*gb(3) + un*tempb0
    temp2b = rho*temp1*gb(3)
    unb = a2neg*temp2b + rho*tempb0
    gb(3) = 0.D0
    b2b = b2b - temp2b
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    a2negb = a2negb + temp2*rho*gb(2) + un*temp2b
    rhob = rhob + temp2*a2neg*gb(2)
    temp2b = rho*a2neg*gb(2)
    gb(2) = 0.D0
    tempb4 = (ut*a1pos+b1)*gb(1)
    tempb3 = rho*a2neg*gb(1)
    a1posb = a1posb + temp1*temp2b + ut*tempb3 + ut*temp1b
    b1b = b1b + ut*temp2b + tempb3 + temp1b
    temp1b = a1pos*temp2b
    pr_by_rhob = pr_by_rhob + temp1b
    a2negb = a2negb + rho*tempb4
    gb(1) = 0.D0
    result1b = -(0.5d0*a2negb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0

    ! CALL DERF_B(s2, s2b, result1b)
    s2b = s2b + (2.0d0/dsqrt(pi))*dexp(-s2**2)*result1b

    CALL POPREAL8(s2)
    result1b = 0.5d0*a1posb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0

    ! CALL DERF_B(s1, s1b, result1b)
    s1b = s1b + (2.0d0/dsqrt(pi))*dexp(-s1**2)*result1b

    CALL POPREAL8(s1)
    temp6 = DSQRT(pi*beta)
    tempb6 = 0.5d0*b2b/temp6
    s2b = s2b - DEXP(-(s2**2))*2*s2*tempb6
    unb = unb + temp0*s2b + 2*un*u_sqrb
    IF (pi*beta .EQ. 0.0) THEN
      betab = 0.0
    ELSE
      betab = -(DEXP(-(s2**2))*pi*tempb6/(2.D0*DSQRT(pi*beta)*temp6))
    END IF
    temp5 = DSQRT(pi*beta)
    tempb7 = 0.5d0*b1b/temp5
    s1b = s1b - DEXP(-(s1**2))*2*s1*tempb7
    utb = utb + 2*ut*temp1b + 2*ut*u_sqrb + temp*s1b + a1pos*tempb3 + b1&
&     *temp2b
    IF (.NOT.pi*beta .EQ. 0.0) betab = betab - DEXP(-(s1**2))*pi*tempb7/&
&       (2.D0*DSQRT(pi*beta)*temp5)
    IF (.NOT.beta .EQ. 0.0) betab = betab + un*s2b/(2.D0*DSQRT(beta))
    IF (.NOT.beta .EQ. 0.0) betab = betab + ut*s1b/(2.D0*DSQRT(beta))
    tempb5 = 0.5d0*betab/pr
    rhob = rhob + tempb5 - pr*pr_by_rhob/rho**2 + a2neg*tempb4
    prb = pr_by_rhob/rho - rho*tempb5/pr
    u1b = tx*utb + nx*unb
    u2b = ty*utb + ny*unb
  END SUBROUTINE FLUX_QUAD_GXII_B

  SUBROUTINE FLUX_QUAD_GXII(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1pos, a2neg
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    ! DOUBLE PRECISION :: DERF
    ! INTRINSIC DSQRT
    ! INTRINSIC DEXP
    ! EXTERNAL DERF
    DOUBLE PRECISION :: result1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.d0+result1)
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..
    g(1) = rho*a2neg*(ut*a1pos+b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    g(2) = rho*a2neg*temp2
    temp1 = ut*a1pos + b1
    temp2 = un*a2neg - b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1pos + b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2neg*(temp2+temp3) - temp4
  END SUBROUTINE FLUX_QUAD_GXII

!  Differentiation of flux_quad_gxiii in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: g
!   with respect to varying inputs: g u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXIII_B(g, gb, nx, ny, u1, u1b, u2, u2b, rho, &
&   rhob, pr, prb)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utb, unb
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betab
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1b, b1b, s2b, b2b
    DOUBLE PRECISION :: a1pos, a2pos
    DOUBLE PRECISION :: a1posb, a2posb
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    ! DOUBLE PRECISION :: DERF
    ! INTRINSIC DSQRT
    ! INTRINSIC DEXP
    ! EXTERNAL DERF
    ! EXTERNAL DERF_B
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: temp5
    DOUBLE PRECISION :: temp6
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: tempb2
    DOUBLE PRECISION :: tempb3
    DOUBLE PRECISION :: tempb4
    DOUBLE PRECISION :: tempb5
    DOUBLE PRECISION :: tempb6
    DOUBLE PRECISION :: tempb7
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.0d0+result1)
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1pos + b1
    temp = DSQRT(beta)
    temp0 = DSQRT(beta)
    tempb = rho*a2pos*gb(4)
    rhob = (temp2+temp3)*a2pos*gb(4)
    a2posb = (temp2+temp3)*rho*gb(4)
    temp2b = tempb
    temp3b = tempb
    temp4b = gb(4)
    gb(4) = 0.D0
    tempb0 = 0.5d0*b2*temp1*temp4b
    tempb1 = 0.5d0*rho*un*temp4b
    b2b = temp1*tempb1
    temp1b = b2*tempb1
    utb = a1pos*temp1b
    temp1 = 6.0d0*pr_by_rho + u_sqr
    b1b = 0.5d0*temp1*temp3b + temp1b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    a1posb = 0.5d0*ut*temp1*temp2b + ut*temp1b
    temp1b = 0.5d0*b1*temp3b
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    tempb2 = 0.5d0*a1pos*temp2b
    temp1b = ut*tempb2
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    temp2 = un*a2pos + b2
    temp1b = temp2*rho*gb(3)
    utb = utb + a1pos*temp1b + temp1*tempb2
    temp1 = ut*a1pos + b1
    rhob = rhob + temp2*temp1*gb(3) + un*tempb0
    temp2b = rho*temp1*gb(3)
    unb = a2pos*temp2b + rho*tempb0
    gb(3) = 0.D0
    b2b = b2b + temp2b
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    a2posb = a2posb + temp2*rho*gb(2) + un*temp2b
    rhob = rhob + temp2*a2pos*gb(2)
    temp2b = rho*a2pos*gb(2)
    gb(2) = 0.D0
    tempb4 = (ut*a1pos+b1)*gb(1)
    tempb3 = rho*a2pos*gb(1)
    a1posb = a1posb + temp1*temp2b + ut*tempb3 + ut*temp1b
    b1b = b1b + ut*temp2b + tempb3 + temp1b
    temp1b = a1pos*temp2b
    pr_by_rhob = pr_by_rhob + temp1b
    a2posb = a2posb + rho*tempb4
    gb(1) = 0.D0
    result1b = 0.5d0*a2posb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0

    ! CALL DERF_B(s2, s2b, result1b)
    s2b = s2b + (2.0d0/dsqrt(pi))*dexp(-s2**2)*result1b

    CALL POPREAL8(s2)
    result1b = 0.5d0*a1posb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0

    ! CALL DERF_B(s1, s1b, result1b)
    s1b = s1b + (2.0d0/dsqrt(pi))*dexp(-s1**2)*result1b

    CALL POPREAL8(s1)
    temp6 = DSQRT(pi*beta)
    tempb6 = 0.5d0*b2b/temp6
    s2b = s2b - DEXP(-(s2**2))*2*s2*tempb6
    unb = unb + temp0*s2b + 2*un*u_sqrb
    IF (pi*beta .EQ. 0.0) THEN
      betab = 0.0
    ELSE
      betab = -(DEXP(-(s2**2))*pi*tempb6/(2.D0*DSQRT(pi*beta)*temp6))
    END IF
    temp5 = DSQRT(pi*beta)
    tempb7 = 0.5d0*b1b/temp5
    s1b = s1b - DEXP(-(s1**2))*2*s1*tempb7
    utb = utb + 2*ut*temp1b + 2*ut*u_sqrb + temp*s1b + a1pos*tempb3 + b1&
&     *temp2b
    IF (.NOT.pi*beta .EQ. 0.0) betab = betab - DEXP(-(s1**2))*pi*tempb7/&
&       (2.D0*DSQRT(pi*beta)*temp5)
    IF (.NOT.beta .EQ. 0.0) betab = betab + un*s2b/(2.D0*DSQRT(beta))
    IF (.NOT.beta .EQ. 0.0) betab = betab + ut*s1b/(2.D0*DSQRT(beta))
    tempb5 = 0.5d0*betab/pr
    rhob = rhob + tempb5 - pr*pr_by_rhob/rho**2 + a2pos*tempb4
    prb = pr_by_rhob/rho - rho*tempb5/pr
    u1b = tx*utb + nx*unb
    u2b = ty*utb + ny*unb
  END SUBROUTINE FLUX_QUAD_GXIII_B

  SUBROUTINE FLUX_QUAD_GXIII(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1pos, a2pos
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    ! DOUBLE PRECISION :: DERF
    ! INTRINSIC DSQRT
    ! INTRINSIC DEXP
    ! EXTERNAL DERF
    DOUBLE PRECISION :: result1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.0d0+result1)
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..
    g(1) = rho*a2pos*(ut*a1pos+b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    g(2) = rho*a2pos*temp2
    temp1 = ut*a1pos + b1
    temp2 = un*a2pos + b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1pos + b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2pos*(temp2+temp3) + temp4
  END SUBROUTINE FLUX_QUAD_GXIII

!  Differentiation of flux_quad_gxiv in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: g
!   with respect to varying inputs: g u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXIV_B(g, gb, nx, ny, u1, u1b, u2, u2b, rho, rhob&
&   , pr, prb)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utb, unb
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betab
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1b, b1b, s2b, b2b
    DOUBLE PRECISION :: a1neg, a2pos
    DOUBLE PRECISION :: a1negb, a2posb
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    ! DOUBLE PRECISION :: DERF
    ! INTRINSIC DSQRT
    ! INTRINSIC DEXP
    ! EXTERNAL DERF
    ! EXTERNAL DERF_B
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: temp5
    DOUBLE PRECISION :: temp6
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: tempb2
    DOUBLE PRECISION :: tempb3
    DOUBLE PRECISION :: tempb4
    DOUBLE PRECISION :: tempb5
    DOUBLE PRECISION :: tempb6
    DOUBLE PRECISION :: tempb7
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1neg - b1
    temp = DSQRT(beta)
    temp0 = DSQRT(beta)
    tempb = rho*a2pos*gb(4)
    rhob = (temp2-temp3)*a2pos*gb(4)
    a2posb = (temp2-temp3)*rho*gb(4)
    temp2b = tempb
    temp3b = -tempb
    temp4b = gb(4)
    gb(4) = 0.D0
    tempb0 = 0.5d0*b2*temp1*temp4b
    tempb1 = 0.5d0*rho*un*temp4b
    b2b = temp1*tempb1
    temp1b = b2*tempb1
    utb = a1neg*temp1b
    temp1 = 6.0d0*pr_by_rho + u_sqr
    b1b = 0.5d0*temp1*temp3b - temp1b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    a1negb = 0.5d0*ut*temp1*temp2b + ut*temp1b
    temp1b = 0.5d0*b1*temp3b
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    tempb2 = 0.5d0*a1neg*temp2b
    temp1b = ut*tempb2
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    temp2 = un*a2pos + b2
    temp1b = temp2*rho*gb(3)
    utb = utb + a1neg*temp1b + temp1*tempb2
    temp1 = ut*a1neg - b1
    rhob = rhob + temp2*temp1*gb(3) + un*tempb0
    temp2b = rho*temp1*gb(3)
    unb = a2pos*temp2b + rho*tempb0
    gb(3) = 0.D0
    b2b = b2b + temp2b
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    a2posb = a2posb + temp2*rho*gb(2) + un*temp2b
    rhob = rhob + temp2*a2pos*gb(2)
    temp2b = rho*a2pos*gb(2)
    gb(2) = 0.D0
    tempb4 = (ut*a1neg-b1)*gb(1)
    tempb3 = rho*a2pos*gb(1)
    a1negb = a1negb + temp1*temp2b + ut*tempb3 + ut*temp1b
    b1b = b1b - ut*temp2b - tempb3 - temp1b
    temp1b = a1neg*temp2b
    pr_by_rhob = pr_by_rhob + temp1b
    a2posb = a2posb + rho*tempb4
    gb(1) = 0.D0
    result1b = 0.5d0*a2posb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0

    ! CALL DERF_B(s2, s2b, result1b)
    s2b = s2b + (2.0d0/dsqrt(pi))*dexp(-s2**2)*result1b

    CALL POPREAL8(s2)
    result1b = -(0.5d0*a1negb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0

    ! CALL DERF_B(s1, s1b, result1b)
    s1b = s1b + (2.0d0/dsqrt(pi))*dexp(-s1**2)*result1b

    CALL POPREAL8(s1)
    temp6 = DSQRT(pi*beta)
    tempb6 = 0.5d0*b2b/temp6
    s2b = s2b - DEXP(-(s2**2))*2*s2*tempb6
    unb = unb + temp0*s2b + 2*un*u_sqrb
    IF (pi*beta .EQ. 0.0) THEN
      betab = 0.0
    ELSE
      betab = -(DEXP(-(s2**2))*pi*tempb6/(2.D0*DSQRT(pi*beta)*temp6))
    END IF
    temp5 = DSQRT(pi*beta)
    tempb7 = 0.5d0*b1b/temp5
    s1b = s1b - DEXP(-(s1**2))*2*s1*tempb7
    utb = utb + 2*ut*temp1b + 2*ut*u_sqrb + temp*s1b + a1neg*tempb3 - b1&
&     *temp2b
    IF (.NOT.pi*beta .EQ. 0.0) betab = betab - DEXP(-(s1**2))*pi*tempb7/&
&       (2.D0*DSQRT(pi*beta)*temp5)
    IF (.NOT.beta .EQ. 0.0) betab = betab + un*s2b/(2.D0*DSQRT(beta))
    IF (.NOT.beta .EQ. 0.0) betab = betab + ut*s1b/(2.D0*DSQRT(beta))
    tempb5 = 0.5d0*betab/pr
    rhob = rhob + tempb5 - pr*pr_by_rhob/rho**2 + a2pos*tempb4
    prb = pr_by_rhob/rho - rho*tempb5/pr
    u1b = tx*utb + nx*unb
    u2b = ty*utb + ny*unb
  END SUBROUTINE FLUX_QUAD_GXIV_B

  SUBROUTINE FLUX_QUAD_GXIV(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1neg, a2pos
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    ! DOUBLE PRECISION :: DERF
    ! INTRINSIC DSQRT
    ! INTRINSIC DEXP
    ! EXTERNAL DERF
    DOUBLE PRECISION :: result1
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    s1 = ut*DSQRT(beta)
    s2 = un*DSQRT(beta)
    b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
    b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..
    g(1) = rho*a2pos*(ut*a1neg-b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    g(2) = rho*a2pos*temp2
    temp1 = ut*a1neg - b1
    temp2 = un*a2pos + b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1neg - b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2pos*(temp2-temp3) + temp4
  END SUBROUTINE FLUX_QUAD_GXIV

!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
!  Differentiation of flux_quad_gxi in forward (tangent) mode:
!   variations   of useful results: g
!   with respect to varying inputs: u
!   RW status of diff variables: g:out u:in
!
  SUBROUTINE FLUX_QUAD_GXI_D(g, gd, u, ud, nx, ny)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr, u(4)
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd, ud(4)
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: a1neg, a2neg
    DOUBLE PRECISION :: a1negd, a2negd
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
!  INTRINSIC DSQRT
!  INTRINSIC DEXP
!  EXTERNAL DERF
!  EXTERNAL DERF_D
!  REAL :: DERF
!  REAL :: DERF_D
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: arg1
    DOUBLE PRECISION :: arg1d
    REAL*8 :: result10
    REAL*8 :: result10d
    ! DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    ! EXTERNAL DERF
!
!
    tx = ny
    ty = -nx
    rhod = ud(1)
    rho = u(1)
    u1d = (ud(2)*u(1)-u(2)*ud(1))/u(1)**2
    u1 = u(2)/u(1)
    u2d = (ud(3)*u(1)-u(3)*ud(1))/u(1)**2
    u2 = u(3)/u(1)
    prd = (ud(4)-0.5d0*(2.0d0*u(2)*ud(2)+2*u(3)*ud(3))/u(1)+0.5d0*ud(1)*&
&     (u(2)**2+u(3)**2)/u(1)**2)/2.5d0
    pr = (u(4)-0.5d0/u(1)*(u(2)**2+u(3)**2))/2.5d0
!
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
!
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    IF (beta .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!  result10d = DERF_D(s1, s1d, result10)
    result10d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    result10 = DERF(s1)
    a1negd = -(0.5d0*result10d)
    a1neg = 0.5d0*(1.0d0-result10)
!  result10d = DERF_D(s2, s2d, result10)
    result10d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    result10 = DERF(s2)
    a2negd = -(0.5d0*result10d)
    a2neg = 0.5d0*(1.0d0-result10)
!
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!
!	Expressions for the split fluxes ..
!
    gd = 0.d0
    gd(1) = (rhod*a2neg+rho*a2negd)*(ut*a1neg-b1) + rho*a2neg*(utd*a1neg&
&     +ut*a1negd-b1d)
    g(1) = rho*a2neg*(ut*a1neg-b1)
!
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp1 = pr_by_rho + ut*ut
    temp2d = temp1d*a1neg + temp1*a1negd - utd*b1 - ut*b1d
    temp2 = temp1*a1neg - ut*b1
    gd(2) = (rhod*a2neg+rho*a2negd)*temp2 + rho*a2neg*temp2d
    g(2) = rho*a2neg*temp2
!
    temp1d = utd*a1neg + ut*a1negd - b1d
    temp1 = ut*a1neg - b1
    temp2d = und*a2neg + un*a2negd - b2d
    temp2 = un*a2neg - b2
    gd(3) = (rhod*temp1+rho*temp1d)*temp2 + rho*temp1*temp2d
    g(3) = rho*temp1*temp2
!
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1neg+ut*temp1*a1negd)
    temp2 = 0.5d0*ut*temp1*a1neg
!
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(b1d*temp1+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
!
    temp1d = utd*a1neg + ut*a1negd - b1d
    temp1 = ut*a1neg - b1
    temp4d = 0.5d0*((rhod*un+rho*und)*b2*temp1+rho*un*(b2d*temp1+b2*&
&     temp1d))
    temp4 = 0.5d0*rho*un*b2*temp1
!
    gd(4) = (rhod*a2neg+rho*a2negd)*(temp2-temp3) + rho*a2neg*(temp2d-&
&     temp3d) - temp4d
    g(4) = rho*a2neg*(temp2-temp3) - temp4
  END SUBROUTINE FLUX_QUAD_GXI_D

!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
!  Differentiation of flux_quad_gxii in forward (tangent) mode:
!   variations   of useful results: g
!   with respect to varying inputs: u
!   RW status of diff variables: g:out u:in
!
!
!
  SUBROUTINE FLUX_QUAD_GXII_D(g, gd, u, ud, nx, ny)
    IMPLICIT NONE
!
!
!
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr, u(4)
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd, ud(4)
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: a1pos, a2neg
    DOUBLE PRECISION :: a1posd, a2negd
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
!  INTRINSIC DSQRT
!  INTRINSIC DEXP
!  EXTERNAL DERF
!  EXTERNAL DERF_D
!  REAL :: DERF
!  REAL :: DERF_D
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: arg1
    DOUBLE PRECISION :: arg1d
    REAL*8 :: result10
    REAL*8 :: result10d
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    ! EXTERNAL DERF
!
!
    tx = ny
    ty = -nx
    rhod = ud(1)
    rho = u(1)
    u1d = (ud(2)*u(1)-u(2)*ud(1))/u(1)**2
    u1 = u(2)/u(1)
    u2d = (ud(3)*u(1)-u(3)*ud(1))/u(1)**2
    u2 = u(3)/u(1)
    prd = (ud(4)-0.5d0*(2.0d0*u(2)*ud(2)+2.0d0*u(3)*ud(3))/u(1)+0.5d0*ud&
&     (1)*(u(2)**2+u(3)**2)/u(1)**2)/2.5d0
    pr = (u(4)-0.5d0/u(1)*(u(2)**2+u(3)**2))/2.5d0
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
!
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    IF (beta .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!  result10d = DERF_D(s1, s1d, result10)
    result10d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    result10 = DERF(s1)
    a1posd = 0.5d0*result10d
    a1pos = 0.5d0*(1.0d0+result10)
!  result10d = DERF_D(s2, s2d, result10)
    result10d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    result10 = DERF(s2)
    a2negd = -(0.5d0*result10d)
    a2neg = 0.5d0*(1.0d0-result10)
!
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!
!	Expressions for the split fluxes ..
!
    gd = 0.d0
    gd(1) = (rhod*a2neg+rho*a2negd)*(ut*a1pos+b1) + rho*a2neg*(utd*a1pos&
&     +ut*a1posd+b1d)
    g(1) = rho*a2neg*(ut*a1pos+b1)
!
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp1 = pr_by_rho + ut*ut
    temp2d = temp1d*a1pos + temp1*a1posd + utd*b1 + ut*b1d
    temp2 = temp1*a1pos + ut*b1
    gd(2) = (rhod*a2neg+rho*a2negd)*temp2 + rho*a2neg*temp2d
    g(2) = rho*a2neg*temp2
!
    temp1d = utd*a1pos + ut*a1posd + b1d
    temp1 = ut*a1pos + b1
    temp2d = und*a2neg + un*a2negd - b2d
    temp2 = un*a2neg - b2
    gd(3) = (rhod*temp1+rho*temp1d)*temp2 + rho*temp1*temp2d
    g(3) = rho*temp1*temp2
!
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1pos+ut*temp1*a1posd)
    temp2 = 0.5d0*ut*temp1*a1pos
!
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(b1d*temp1+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
!
    temp1d = utd*a1pos + ut*a1posd + b1d
    temp1 = ut*a1pos + b1
    temp4d = 0.5d0*((rhod*un+rho*und)*b2*temp1+rho*un*(b2d*temp1+b2*&
&     temp1d))
    temp4 = 0.5d0*rho*un*b2*temp1
!
    gd(4) = (rhod*a2neg+rho*a2negd)*(temp2+temp3) + rho*a2neg*(temp2d+&
&     temp3d) - temp4d
    g(4) = rho*a2neg*(temp2+temp3) - temp4
  END SUBROUTINE FLUX_QUAD_GXII_D

!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
!  Differentiation of flux_quad_gxiii in forward (tangent) mode:
!   variations   of useful results: g
!   with respect to varying inputs: u
!   RW status of diff variables: g:out u:in
!
!
!
  SUBROUTINE FLUX_QUAD_GXIII_D(g, gd, u, ud, nx, ny)
    IMPLICIT NONE
!
!
!
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr, u(4)
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd, ud(4)
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: a1pos, a2pos
    DOUBLE PRECISION :: a1posd, a2posd
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: DERF
!  INTRINSIC DSQRT
!  INTRINSIC DEXP
!  EXTERNAL DERF
!  EXTERNAL DERF_D
!  REAL :: DERF
!  REAL :: DERF_D
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: arg1
    DOUBLE PRECISION :: arg1d
    REAL*8 :: result10
    REAL*8 :: result10d
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    ! EXTERNAL DERF
!
!
    tx = ny
    ty = -nx
    rhod = ud(1)
    rho = u(1)
    u1d = (ud(2)*u(1)-u(2)*ud(1))/u(1)**2
    u1 = u(2)/u(1)
    u2d = (ud(3)*u(1)-u(3)*ud(1))/u(1)**2
    u2 = u(3)/u(1)
    prd = (ud(4)-0.5d0*(2.0d0*u(2)*ud(2)+2.0d0*u(3)*ud(3))/u(1)+0.5d0*ud&
&     (1)*(u(2)**2+u(3)**2)/u(1)**2)/2.5d0
    pr = (u(4)-0.5d0/u(1)*(u(2)**2+u(3)**2))/2.5d0
!
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
!
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    IF (beta .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!  result10d = DERF_D(s1, s1d, result10)
    result10d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    result10 = DERF(s1)
    a1posd = 0.5d0*result10d
    a1pos = 0.5d0*(1.0d0+result10)
!  result10d = DERF_D(s2, s2d, result10)
    result10d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    result10 = DERF(s2)
    a2posd = 0.5d0*result10d
    a2pos = 0.5d0*(1.0d0+result10)
!
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!
!	Expressions for the split fluxes ..
!
    gd = 0.d0
    gd(1) = (rhod*a2pos+rho*a2posd)*(ut*a1pos+b1) + rho*a2pos*(utd*a1pos&
&     +ut*a1posd+b1d)
    g(1) = rho*a2pos*(ut*a1pos+b1)
!
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp1 = pr_by_rho + ut*ut
    temp2d = temp1d*a1pos + temp1*a1posd + utd*b1 + ut*b1d
    temp2 = temp1*a1pos + ut*b1
    gd(2) = (rhod*a2pos+rho*a2posd)*temp2 + rho*a2pos*temp2d
    g(2) = rho*a2pos*temp2
!
    temp1d = utd*a1pos + ut*a1posd + b1d
    temp1 = ut*a1pos + b1
    temp2d = und*a2pos + un*a2posd + b2d
    temp2 = un*a2pos + b2
    gd(3) = (rhod*temp1+rho*temp1d)*temp2 + rho*temp1*temp2d
    g(3) = rho*temp1*temp2
!
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1pos+ut*temp1*a1posd)
    temp2 = 0.5d0*ut*temp1*a1pos
!
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(b1d*temp1+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
!
    temp1d = utd*a1pos + ut*a1posd + b1d
    temp1 = ut*a1pos + b1
    temp4d = 0.5d0*((rhod*un+rho*und)*b2*temp1+rho*un*(b2d*temp1+b2*&
&     temp1d))
    temp4 = 0.5d0*rho*un*b2*temp1
!
    gd(4) = (rhod*a2pos+rho*a2posd)*(temp2+temp3) + rho*a2pos*(temp2d+&
&     temp3d) + temp4d
    g(4) = rho*a2pos*(temp2+temp3) + temp4
  END SUBROUTINE FLUX_QUAD_GXIII_D

!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
!  Differentiation of flux_quad_gxiv in forward (tangent) mode:
!   variations   of useful results: g
!   with respect to varying inputs: u
!   RW status of diff variables: g:out u:in
!
!
!
  SUBROUTINE FLUX_QUAD_GXIV_D(g, gd, u, ud, nx, ny)
    IMPLICIT NONE
!
!
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr, u(4)
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd, ud(4)
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: a1neg, a2pos
    DOUBLE PRECISION :: a1negd, a2posd
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
!  INTRINSIC DSQRT
!  INTRINSIC DEXP
!  EXTERNAL DERF
!  EXTERNAL DERF_D
!  REAL :: DERF
!  REAL :: DERF_D
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: arg1
    DOUBLE PRECISION :: arg1d
    REAL*8 :: result10
    REAL*8 :: result10d
    DOUBLE PRECISION :: DERF
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    ! EXTERNAL DERF
!
!
    tx = ny
    ty = -nx
    rhod = ud(1)
    rho = u(1)
    u1d = (ud(2)*u(1)-u(2)*ud(1))/u(1)**2
    u1 = u(2)/u(1)
    u2d = (ud(3)*u(1)-u(3)*ud(1))/u(1)**2
    u2 = u(3)/u(1)
    prd = (ud(4)-0.5d0*(2.0d0*u(2)*ud(2)+2.0d0*u(3)*ud(3))/u(1)+0.5d0*ud&
&     (1)*(u(2)**2+u(3)**2)/u(1)**2)/2.5d0
    pr = (u(4)-0.5d0/u(1)*(u(2)**2+u(3)**2))/2.5d0
!
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
!
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    IF (beta .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0d0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!  result10d = DERF_D(s1, s1d, result10)
    result10d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    result10 = DERF(s1)
    a1negd = -(0.5d0*result10d)
    a1neg = 0.5d0*(1.0d0-result10)
!  result10d = DERF_D(s2, s2d, result10)
    result10d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    result10 = DERF(s2)
    a2posd = 0.5d0*result10d
    a2pos = 0.5d0*(1.0d0+result10)
!
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!
!	Expressions for the split fluxes ..
!
    gd = 0.d0
    gd(1) = (rhod*a2pos+rho*a2posd)*(ut*a1neg-b1) + rho*a2pos*(utd*a1neg&
&     +ut*a1negd-b1d)
    g(1) = rho*a2pos*(ut*a1neg-b1)
!
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp1 = pr_by_rho + ut*ut
    temp2d = temp1d*a1neg + temp1*a1negd - utd*b1 - ut*b1d
    temp2 = temp1*a1neg - ut*b1
    gd(2) = (rhod*a2pos+rho*a2posd)*temp2 + rho*a2pos*temp2d
    g(2) = rho*a2pos*temp2
!
    temp1d = utd*a1neg + ut*a1negd - b1d
    temp1 = ut*a1neg - b1
    temp2d = und*a2pos + un*a2posd + b2d
    temp2 = un*a2pos + b2
    gd(3) = (rhod*temp1+rho*temp1d)*temp2 + rho*temp1*temp2d
    g(3) = rho*temp1*temp2
!
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1neg+ut*temp1*a1negd)
    temp2 = 0.5d0*ut*temp1*a1neg
!
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(b1d*temp1+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
!
    temp1d = utd*a1neg + ut*a1negd - b1d
    temp1 = ut*a1neg - b1
    temp4d = 0.5d0*((rhod*un+rho*und)*b2*temp1+rho*un*(b2d*temp1+b2*&
&     temp1d))
    temp4 = 0.5d0*rho*un*b2*temp1
!
    gd(4) = (rhod*a2pos+rho*a2posd)*(temp2-temp3) + rho*a2pos*(temp2d-&
&     temp3d) + temp4d
    g(4) = rho*a2pos*(temp2-temp3) + temp4
  END SUBROUTINE FLUX_QUAD_GXIV_D

END MODULE QUADRANT_FLUXES_MOD_DIFF
