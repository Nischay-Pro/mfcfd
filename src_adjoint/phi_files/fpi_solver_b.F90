!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE FPI_SOLVER_MOD_DIFF
  USE DATA_STRUCTURE_MOD_DIFF
  USE FLUX_RESIDUAL_MOD_DIFF
  USE STATE_UPDATE_MOD_DIFF
  USE Q_VARIABLES_MOD_DIFF
  USE OBJECTIVE_FUNCTION_MOD_DIFF
  USE STAGNATION_VALUES_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of fpi_solver in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: cost_func *(point.delta) *(point.prim)
!                *(point.prim_old) *(point.q) *(point.flux_res)
!                *(point.dq) *(point.ddq) *(point.temp) *(point.phi1)
!                *(point.phi2)
!   with respect to varying inputs: *(point.delta) *(point.prim)
!                *(point.prim_old) *(point.q) *(point.flux_res)
!                *(point.dq) *(point.ddq) *(point.temp) *(point.phi1)
!                *(point.phi2)
!   Plus diff mem management of: point.delta:in point.prim:in point.prim_old:in
!                point.q:in point.flux_res:in point.dq:in point.ddq:in
!                point.temp:in point.phi1:in point.phi2:in
  SUBROUTINE FPI_SOLVER_B(t)
    IMPLICIT NONE
    INTEGER :: t, i, rk, ierr,z ,nbh,k
    INTRINSIC DSQRT
    INTRINSIC DLOG10
    DO i=1,max_points
      point%prim_old(:, i) = point%prim(:, i)
    END DO
    CALL FUNC_DELTA()
! Perform 4-stage, 3-order SSPRK update
    DO rk=1,rks
      CALL PUSHREAL8ARRAY(point%q, 4*max_points)
      CALL EVAL_Q_VARIABLES()
      CALL PUSHREAL8ARRAY(point%dq, 2*4*max_points)
      CALL EVAL_Q_DERIVATIVES()
      DO i=1,inner_iterations+1
        CALL PUSHREAL8ARRAY(point%ddq, 3*4*max_points)
        CALL EVAL_Q_DOUBLE_DERIVATIVES()
        CALL EVAL_Q_INNER_LOOP()
        CALL EVAL_UPDATE_INNERLOOP()
      END DO
      CALL PUSHREAL8ARRAY(point%flux_res, 4*max_points)
      CALL CAL_FLUX_RESIDUAL()
      CALL PUSHREAL8ARRAY(point%prim, 4*max_points)
      CALL STATE_UPDATE(rk)
    END DO
    CALL OBJECTIVE_FUNCTION_J_B()
    DO rk=rks,1,-1
      ! z = 78
      ! write(*,*) pointb%phi1(:,z), ' is Phi1'
      ! write(*,*) pointb%phi1(:,z), ' is Phi2'
      ! write(*,*) pointb%prim(:,z), ' is Prim'
      ! write(*,*) pointb%temp(:,:,z), ' is Temp'
      ! write(*,*) pointb%delta(z), ' is Delta'
      ! write(*,*) pointb%prim_old(:,z), ' is Prim_Old'
      ! DO k=1,point%nbhs(z)
      !     nbh = point%conn(z, k)
      !     write(*,*) pointb%temp(:,:,nbh), ' is Temp'
      !     write(*,*) pointb%delta(nbh), ' is Delta'
      !     write(*,*) pointb%prim_old(:,nbh), ' is Prim_Old'
      !     write(*,*) pointb%phi1(:,nbh), ' is Phi1-k'
      !     write(*,*) pointb%prim(:,nbh), ' is Prim-k'
      !     write(*,*) pointb%q(:,nbh), ' is Q'
      !     write(*,*) pointb%dq(:,:,nbh), ' is DQ'
      !     write(*,*) pointb%ddq(:,:,nbh), ' is DDQ'
      !     write(*,*) pointb%flux_res(:,nbh), ' is Flux Res'
      ! END DO
      CALL POPREAL8ARRAY(point%prim, 4*max_points)
      CALL STATE_UPDATE_B(rk)
      CALL POPREAL8ARRAY(point%flux_res, 4*max_points)
      CALL CAL_FLUX_RESIDUAL_B()
      DO i=inner_iterations+1,1,-1
        CALL EVAL_UPDATE_INNERLOOP_B()
        CALL EVAL_Q_INNER_LOOP_B()
        CALL POPREAL8ARRAY(point%ddq, 3*4*max_points)
        CALL EVAL_Q_DOUBLE_DERIVATIVES_B()
      END DO
      CALL POPREAL8ARRAY(point%dq, 2*4*max_points)
      CALL EVAL_Q_DERIVATIVES_B()
      CALL POPREAL8ARRAY(point%q, 4*max_points)
      CALL EVAL_Q_VARIABLES_B()
    END DO
    CALL FUNC_DELTA_B()
    DO i=max_points,1,-1
      pointb%prim(:, i) = pointb%prim(:, i) + pointb%prim_old(:, i)
      pointb%prim_old(:, i) = 0.0_8
    END DO
  END SUBROUTINE FPI_SOLVER_B

  SUBROUTINE FPI_SOLVER(t)
    IMPLICIT NONE
    INTEGER :: t, i, rk, ierr, z
    INTRINSIC DSQRT
    INTRINSIC DLOG10
    DO i=1,max_points
      point%prim_old(:, i) = point%prim(:, i)
    END DO
    CALL FUNC_DELTA()
! Perform 4-stage, 3-order SSPRK update
    DO rk=1,rks

      ! write(*,*) '<<<<<<<<<<<<<<<<<<<<<<<<<<'
      ! z = 78

      ! write(*,*) point%q(:,z), ' is Q'
      ! write(*,*) point%prim(:,z), ' is Prim'
      ! write(*,*) point%temp(:,:,z), ' is Temp'
      ! write(*,*) point%prim_old(:,z), ' is Prim_Old'
      ! write(*,*) point%dq(:,:,z), ' is DQ'
      ! write(*,*) point%ddq(:,:,z), ' is DDQ'
      ! write(*,*) point%flux_res(:,z), ' is Flux Res'

      CALL EVAL_Q_VARIABLES()
      CALL EVAL_Q_DERIVATIVES()
!                        if(inner_iterations /= 0) then
!                                do i = 1, inner_iterations
      DO i=1,inner_iterations+1
        CALL EVAL_Q_DOUBLE_DERIVATIVES()
        CALL EVAL_Q_INNER_LOOP()
        CALL EVAL_UPDATE_INNERLOOP()
      END DO

      ! write(*,*) '==========================='
      ! write(*,*) point%q(:,z), ' is Q'
      ! write(*,*) point%prim(:,z), ' is Prim'
      ! write(*,*) point%temp(:,:,z), ' is Temp'
      ! write(*,*) point%prim_old(:,z), ' is Prim_Old'
      ! write(*,*) point%dq(:,:,z), ' is DQ'
      ! write(*,*) point%ddq(:,:,z), ' is DDQ'
      ! write(*,*) point%flux_res(:,z), ' is Flux Res'
      ! write(*,*) '>>>>>>>>>>>>>>>>>>>>>>>>>>>'
!                        end if
      CALL CAL_FLUX_RESIDUAL()
      CALL STATE_UPDATE(rk)
    END DO
    CALL OBJECTIVE_FUNCTION()
    CALL STAGNATION_PRESSURE()
    CALL OBJECTIVE_FUNCTION_J()
    res_new = DSQRT(sum_res_sqr)/max_points
    IF (t .LE. 2 .AND. restart .EQ. 0) THEN
      res_old = res_new
      residue = 0.d0
    ELSE
      residue = DLOG10(res_new/res_old)
    END IF
  END SUBROUTINE FPI_SOLVER

END MODULE FPI_SOLVER_MOD_DIFF
