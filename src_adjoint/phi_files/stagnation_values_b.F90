!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE STAGNATION_VALUES_MOD_DIFF
  USE DATA_STRUCTURE_MOD_DIFF
  IMPLICIT NONE

CONTAINS
  SUBROUTINE STAGNATION_PRESSURE()
    IMPLICIT NONE
    INTEGER :: i, indexmin, indexmax
    REAL*8 :: p0_inf, gammapower, pmin, pmax, p0, mach_t, angle
    REAL*8 :: prim(4)
    INTRINSIC SQRT
    gammapower = gamma/(gamma-1)
    p0_inf = pr_inf*(1+(gamma-1)/2*mach*mach)**gammapower
    DO i=1,max_points
      prim = point%prim(:, i)
      angle = SQRT(gamma*prim(4)/prim(1))
      mach_t = SQRT(prim(2)**2+prim(3)**2)/angle
      p0 = prim(4)*(1+(gamma-1)/2*mach_t*mach_t)**gammapower
      IF (i .EQ. 1) THEN
        pmin = p0
        indexmin = i
        indexmax = i
        pmax = p0
      ELSE IF (p0 .LT. pmin) THEN
        pmin = p0
        indexmin = i
      ELSE IF (p0 .GT. pmax) THEN
        pmax = p0
        indexmax = i
      END IF
    END DO
    WRITE(*, *) 'Stagnation values are ', pmin, ' ', pmax, ' ', pmin/&
&   p0_inf, ' ', pmax/p0_inf, ' ', indexmin, ' ', indexmax
  END SUBROUTINE STAGNATION_PRESSURE

!  Differentiation of objective_function_j in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: cost_func point.prim
!   with respect to varying inputs: point.prim
  SUBROUTINE OBJECTIVE_FUNCTION_J_B()
    IMPLICIT NONE
    INTEGER :: i
    REAL*8 :: p0_inf, gammapower, p0, p0_sum, constant, angle, mach_t
    REAL*8 :: p0b, p0_sumb, angleb, mach_tb
    REAL*8 :: prim(4)
    REAL*8 :: primb(4)
    INTRINSIC SQRT
    REAL*8 :: temp
    REAL*8 :: temp0
    REAL*8 :: temp1
    REAL*8 :: temp2
    REAL*8 :: tempb
    REAL*8 :: tempb0
    gammapower = gamma/(gamma-1)
    p0_inf = pr_inf*(1+(gamma-1)/2*mach*mach)**gammapower
    constant = 1/(p0_inf**2*max_points)
    DO i=1,max_points
      prim = point%prim(:, i)
      CALL PUSHREAL8(angle)
      angle = SQRT(gamma*prim(4)/prim(1))
      CALL PUSHREAL8(mach_t)
      mach_t = SQRT(prim(2)**2+prim(3)**2)/angle
    END DO
    p0_sumb = constant*cost_funcb
    DO i=max_points,1,-1
      prim = point%prim(:, i)
      p0 = prim(4)*(1+(gamma-1)/2*mach_t*mach_t)**gammapower
      p0b = -(2*(p0_inf-p0)*p0_sumb)
      primb = 0.0_8
      temp2 = (gamma-1)*mach_t**2/2 + 1
      primb(4) = primb(4) + temp2**gammapower*p0b
      IF (temp2 .LE. 0.0 .AND. (gammapower .EQ. 0.0 .OR. gammapower .NE.&
&         INT(gammapower))) THEN
        mach_tb = 0.0
      ELSE
        mach_tb = (gamma-1)*gammapower*temp2**(gammapower-1)*prim(4)*&
&         mach_t*p0b
      END IF
      CALL POPREAL8(mach_t)
      tempb = mach_tb/angle
      temp0 = prim(2)**2 + prim(3)**2
      temp1 = SQRT(temp0)
      IF (.NOT.temp0 .EQ. 0.0) primb(2) = primb(2) + 2*prim(2)*tempb/(&
&         2.0*temp1)
      IF (.NOT.temp0 .EQ. 0.0) primb(3) = primb(3) + 2*prim(3)*tempb/(&
&         2.0*temp1)
      angleb = -(temp1*tempb/angle)
      CALL POPREAL8(angle)
      temp = prim(4)/prim(1)
      IF (gamma*temp .EQ. 0.0) THEN
        tempb0 = 0.0
      ELSE
        tempb0 = gamma*angleb/(2.0*SQRT(gamma*temp)*prim(1))
      END IF
      primb(4) = primb(4) + tempb0
      primb(1) = primb(1) - temp*tempb0
      pointb%prim(:, i) = pointb%prim(:, i) + primb
    END DO
  END SUBROUTINE OBJECTIVE_FUNCTION_J_B

  SUBROUTINE OBJECTIVE_FUNCTION_J()
    IMPLICIT NONE
    INTEGER :: i
    REAL*8 :: p0_inf, gammapower, p0, p0_sum, constant, angle, mach_t
    REAL*8 :: prim(4)
    INTRINSIC SQRT
    gammapower = gamma/(gamma-1)
    p0_inf = pr_inf*(1+(gamma-1)/2*mach*mach)**gammapower
    constant = 1/(p0_inf**2*max_points)
    DO i=1,max_points
      prim = point%prim(:, i)
      angle = SQRT(gamma*prim(4)/prim(1))
      mach_t = SQRT(prim(2)**2+prim(3)**2)/angle
      p0 = prim(4)*(1+(gamma-1)/2*mach_t*mach_t)**gammapower
      p0_sum = p0_sum + (p0_inf-p0)**2
    END DO
    cost_func = p0_sum*constant
    WRITE(*, *) 'Objective Function (J)', cost_func
  END SUBROUTINE OBJECTIVE_FUNCTION_J

END MODULE STAGNATION_VALUES_MOD_DIFF

