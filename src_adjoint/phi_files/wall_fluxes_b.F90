!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE WALL_FLUXES_MOD_DIFF
!
!	First written on 14.10.2016
!	updated on Dec 29, 2016
!	updated on 19.08.2017
!	
  USE DATA_STRUCTURE_MOD_DIFF
  USE QUADRANT_FLUXES_MOD_DIFF
  USE SPLIT_FLUXES_MOD_DIFF
  USE Q_VARIABLES_MOD_DIFF
  USE LIMITERS_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of wall_dgx_pos in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: point.q point.dq point.ddq
!                point.phi1 point.phi2 g
!   with respect to varying inputs: point.q point.dq point.ddq
!                point.phi1 point.phi2
!	This subroutine evaluates the wall flux derivative dGs_pos
  SUBROUTINE WALL_DGX_POS_B(g, gb, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: phi1_i(4), phi1_k(4)
    REAL*8 :: phi1_ib(4), phi1_kb(4)
    REAL*8 :: phi2_i(4), phi2_k(4)
    REAL*8 :: phi2_ib(4), phi2_kb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: temp0
    REAL*8 :: temp1
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    REAL*8, DIMENSION(4) :: tempb1
    REAL*8, DIMENSION(4) :: tempb2
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    phi1_i = point%phi1(:, i)
    phi2_i = point%phi2(:, i)
    DO j=1,point%xpos_nbhs(i)
      CALL PUSHINTEGER4(k)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      phi1_k = point%phi1(:, k)
      phi2_k = point%phi2(:, k)
      CALL PUSHREAL8(delx)
      delx = x_k - x_i
      CALL PUSHREAL8(dely)
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      CALL PUSHREAL8(dels_weights)
      dels_weights = dels*weights
      CALL PUSHREAL8(deln_weights)
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*phi1_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i)) - 1/6d0*phi2_i*(delx*delx*point%ddq(1, :&
&       , i)+2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :, &
&       i))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*phi1_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k)) - 1/6d0*phi2_k*(delx*delx*point%ddq(1, :&
&       , k)+2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :, &
&       k))
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    sum_delx_delfb = one_by_det*sum_dely_sqr*gb
    sum_dely_delfb = -(one_by_det*sum_delx_dely*gb)
    g_ib = 0.0_8
    g_kb = 0.0_8
    phi2_ib = 0.0_8
    phi1_ib = 0.0_8
    DO j=point%xpos_nbhs(i),1,-1
      g_kb = g_kb + dels_weights*sum_delx_delfb + deln_weights*&
&       sum_dely_delfb
      g_ib = g_ib - dels_weights*sum_delx_delfb - deln_weights*&
&       sum_dely_delfb
      CALL FLUX_QUAD_GXII_B(g_k, g_kb, nx, ny, u1, u1b, u2, u2b, rho, &
&                     rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_k, qtilde_kb, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL FLUX_QUAD_GXII_B(g_i, g_ib, nx, ny, u1, u1b, u2, u2b, rho, &
&                     rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_i, qtilde_ib, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      phi2_k = point%phi2(:, k)
      phi1_k = point%phi1(:, k)
      phi2_kb = 0.0_8
      phi1_kb = 0.0_8
      CALL POPREAL8ARRAY(qtilde_k, 4)
      tempb = -(0.5d0*phi1_k*qtilde_kb)
      temp1 = 2.0*delx*dely
      tempb0 = -(phi2_k*qtilde_kb/6d0)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      phi1_kb = -(0.5d0*(delx*point%dq(1, :, k)+dely*point%dq(2, :, k))*&
&       qtilde_kb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb
      phi2_kb = -((delx**2*point%ddq(1, :, k)+temp1*point%ddq(2, :, k)+&
&       dely**2*point%ddq(3, :, k))*qtilde_kb/6d0)
      pointb%ddq(1, :, k) = pointb%ddq(1, :, k) + delx**2*tempb0
      pointb%ddq(2, :, k) = pointb%ddq(2, :, k) + temp1*tempb0
      pointb%ddq(3, :, k) = pointb%ddq(3, :, k) + dely**2*tempb0
      CALL POPREAL8ARRAY(qtilde_i, 4)
      tempb1 = -(0.5d0*phi1_i*qtilde_ib)
      temp0 = 2.0*delx*dely
      tempb2 = -(phi2_i*qtilde_ib/6d0)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      phi1_ib = phi1_ib - 0.5d0*(delx*point%dq(1, :, i)+dely*point%dq(2&
&       , :, i))*qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb1
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb1
      phi2_ib = phi2_ib - (delx**2*point%ddq(1, :, i)+temp0*point%ddq(2&
&       , :, i)+dely**2*point%ddq(3, :, i))*qtilde_ib/6d0
      pointb%ddq(1, :, i) = pointb%ddq(1, :, i) + delx**2*tempb2
      pointb%ddq(2, :, i) = pointb%ddq(2, :, i) + temp0*tempb2
      pointb%ddq(3, :, i) = pointb%ddq(3, :, i) + dely**2*tempb2
      CALL POPREAL8(deln_weights)
      CALL POPREAL8(dels_weights)
      CALL POPREAL8(dely)
      CALL POPREAL8(delx)
      pointb%phi2(:, k) = pointb%phi2(:, k) + phi2_kb
      pointb%phi1(:, k) = pointb%phi1(:, k) + phi1_kb
      CALL POPINTEGER4(k)
    END DO
    pointb%phi2(:, i) = pointb%phi2(:, i) + phi2_ib
    pointb%phi1(:, i) = pointb%phi1(:, i) + phi1_ib
  END SUBROUTINE WALL_DGX_POS_B

!	This subroutine evaluates the wall flux derivative dGs_pos
  SUBROUTINE WALL_DGX_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi1_i(4), phi1_k(4)
    REAL*8 :: phi2_i(4), phi2_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    phi1_i = point%phi1(:, i)
    phi2_i = point%phi2(:, i)
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      phi1_k = point%phi1(:, k)
      phi2_k = point%phi2(:, k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*phi1_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i)) - 1/6d0*phi2_i*(delx*delx*point%ddq(1, :&
&       , i)+2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :, &
&       i))
      qtilde_k = point%q(:, k) - 0.5d0*phi1_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k)) - 1/6d0*phi2_k*(delx*delx*point%ddq(1, :&
&       , k)+2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :, &
&       k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXII(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXII(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGX_POS

!  Differentiation of wall_dgx_neg in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: point.q point.dq point.ddq
!                point.phi1 point.phi2 g
!   with respect to varying inputs: point.q point.dq point.ddq
!                point.phi1 point.phi2
!	This subroutine evaluates the wall flux derivative dGs_neg
  SUBROUTINE WALL_DGX_NEG_B(g, gb, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: dels, deln
!		real*8 :: sum_delx_delx, sum_dely_dely
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: phi1_i(4), phi1_k(4)
    REAL*8 :: phi1_ib(4), phi1_kb(4)
    REAL*8 :: phi2_i(4), phi2_k(4)
    REAL*8 :: phi2_ib(4), phi2_kb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    REAL*8 :: temp0
    REAL*8 :: temp1
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    REAL*8, DIMENSION(4) :: tempb1
    REAL*8, DIMENSION(4) :: tempb2
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    phi1_i = point%phi1(:, i)
    phi2_i = point%phi2(:, i)
    DO j=1,point%xneg_nbhs(i)
      CALL PUSHINTEGER4(k)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      phi1_k = point%phi1(:, k)
      phi2_k = point%phi2(:, k)
      CALL PUSHREAL8(delx)
      delx = x_k - x_i
      CALL PUSHREAL8(dely)
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      CALL PUSHREAL8(dels_weights)
      dels_weights = dels*weights
      CALL PUSHREAL8(deln_weights)
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*phi1_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i)) - 1/6d0*phi2_i*(delx*delx*point%ddq(1, :&
&       , i)+2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :, &
&       i))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*phi1_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k)) - 1/6d0*phi2_k*(delx*delx*point%ddq(1, :&
&       , k)+2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :, &
&       k))
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    sum_delx_delfb = one_by_det*sum_dely_sqr*gb
    sum_dely_delfb = -(one_by_det*sum_delx_dely*gb)
    g_ib = 0.0_8
    g_kb = 0.0_8
    phi2_ib = 0.0_8
    phi1_ib = 0.0_8
    DO j=point%xneg_nbhs(i),1,-1
      g_kb = g_kb + dels_weights*sum_delx_delfb + deln_weights*&
&       sum_dely_delfb
      g_ib = g_ib - dels_weights*sum_delx_delfb - deln_weights*&
&       sum_dely_delfb
      CALL FLUX_QUAD_GXI_B(g_k, g_kb, nx, ny, u1, u1b, u2, u2b, rho, &
&                    rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_k, qtilde_kb, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL FLUX_QUAD_GXI_B(g_i, g_ib, nx, ny, u1, u1b, u2, u2b, rho, &
&                    rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_i, qtilde_ib, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      phi2_k = point%phi2(:, k)
      phi1_k = point%phi1(:, k)
      phi2_kb = 0.0_8
      phi1_kb = 0.0_8
      CALL POPREAL8ARRAY(qtilde_k, 4)
      tempb = -(0.5d0*phi1_k*qtilde_kb)
      temp1 = 2.0*delx*dely
      tempb0 = -(phi2_k*qtilde_kb/6d0)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      phi1_kb = -(0.5d0*(delx*point%dq(1, :, k)+dely*point%dq(2, :, k))*&
&       qtilde_kb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb
      phi2_kb = -((delx**2*point%ddq(1, :, k)+temp1*point%ddq(2, :, k)+&
&       dely**2*point%ddq(3, :, k))*qtilde_kb/6d0)
      pointb%ddq(1, :, k) = pointb%ddq(1, :, k) + delx**2*tempb0
      pointb%ddq(2, :, k) = pointb%ddq(2, :, k) + temp1*tempb0
      pointb%ddq(3, :, k) = pointb%ddq(3, :, k) + dely**2*tempb0
      CALL POPREAL8ARRAY(qtilde_i, 4)
      tempb1 = -(0.5d0*phi1_i*qtilde_ib)
      temp0 = 2.0*delx*dely
      tempb2 = -(phi2_i*qtilde_ib/6d0)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      phi1_ib = phi1_ib - 0.5d0*(delx*point%dq(1, :, i)+dely*point%dq(2&
&       , :, i))*qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb1
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb1
      phi2_ib = phi2_ib - (delx**2*point%ddq(1, :, i)+temp0*point%ddq(2&
&       , :, i)+dely**2*point%ddq(3, :, i))*qtilde_ib/6d0
      pointb%ddq(1, :, i) = pointb%ddq(1, :, i) + delx**2*tempb2
      pointb%ddq(2, :, i) = pointb%ddq(2, :, i) + temp0*tempb2
      pointb%ddq(3, :, i) = pointb%ddq(3, :, i) + dely**2*tempb2
      CALL POPREAL8(deln_weights)
      CALL POPREAL8(dels_weights)
      CALL POPREAL8(dely)
      CALL POPREAL8(delx)
      pointb%phi2(:, k) = pointb%phi2(:, k) + phi2_kb
      pointb%phi1(:, k) = pointb%phi1(:, k) + phi1_kb
      CALL POPINTEGER4(k)
    END DO
    pointb%phi2(:, i) = pointb%phi2(:, i) + phi2_ib
    pointb%phi1(:, i) = pointb%phi1(:, i) + phi1_ib
  END SUBROUTINE WALL_DGX_NEG_B

!	This subroutine evaluates the wall flux derivative dGs_neg
  SUBROUTINE WALL_DGX_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: dels, deln
!		real*8 :: sum_delx_delx, sum_dely_dely
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi1_i(4), phi1_k(4)
    REAL*8 :: phi2_i(4), phi2_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    phi1_i = point%phi1(:, i)
    phi2_i = point%phi2(:, i)
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      phi1_k = point%phi1(:, k)
      phi2_k = point%phi2(:, k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*phi1_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i)) - 1/6d0*phi2_i*(delx*delx*point%ddq(1, :&
&       , i)+2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :, &
&       i))
      qtilde_k = point%q(:, k) - 0.5d0*phi1_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k)) - 1/6d0*phi2_k*(delx*delx*point%ddq(1, :&
&       , k)+2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :, &
&       k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXI(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXI(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGX_NEG

!  Differentiation of wall_dgy_neg in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: point.q point.dq point.ddq
!                point.phi1 point.phi2 g
!   with respect to varying inputs: point.q point.dq point.ddq
!                point.phi1 point.phi2
  SUBROUTINE WALL_DGY_NEG_B(g, gb, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: phi1_i(4), phi1_k(4)
    REAL*8 :: phi1_ib(4), phi1_kb(4)
    REAL*8 :: phi2_i(4), phi2_k(4)
    REAL*8 :: phi2_ib(4), phi2_kb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: temp0
    REAL*8 :: temp1
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    REAL*8, DIMENSION(4) :: tempb1
    REAL*8, DIMENSION(4) :: tempb2
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    phi1_i = point%phi1(:, i)
    phi2_i = point%phi2(:, i)
    DO j=1,point%yneg_nbhs(i)
      CALL PUSHINTEGER4(k)
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      phi1_k = point%phi1(:, k)
      phi2_k = point%phi2(:, k)
      CALL PUSHREAL8(delx)
      delx = x_k - x_i
      CALL PUSHREAL8(dely)
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      CALL PUSHREAL8(dels_weights)
      dels_weights = dels*weights
      CALL PUSHREAL8(deln_weights)
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*phi1_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i)) - 1/6d0*phi2_i*(delx*delx*point%ddq(1, :&
&       , i)+2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :, &
&       i))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*phi1_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k)) - 1/6d0*phi2_k*(delx*delx*point%ddq(1, :&
&       , k)+2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :, &
&       k))
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    sum_dely_delfb = one_by_det*sum_delx_sqr*gb
    sum_delx_delfb = -(one_by_det*sum_delx_dely*gb)
    g_ib = 0.0_8
    g_kb = 0.0_8
    phi2_ib = 0.0_8
    phi1_ib = 0.0_8
    DO j=point%yneg_nbhs(i),1,-1
      g_kb = g_kb + dels_weights*sum_delx_delfb + deln_weights*&
&       sum_dely_delfb
      g_ib = g_ib - dels_weights*sum_delx_delfb - deln_weights*&
&       sum_dely_delfb
      CALL FLUX_GYN_B(g_k, g_kb, nx, ny, u1, u1b, u2, u2b, rho, rhob, pr&
&               , prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_k, qtilde_kb, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL FLUX_GYN_B(g_i, g_ib, nx, ny, u1, u1b, u2, u2b, rho, rhob, pr&
&               , prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_i, qtilde_ib, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      phi2_k = point%phi2(:, k)
      phi1_k = point%phi1(:, k)
      phi2_kb = 0.0_8
      phi1_kb = 0.0_8
      CALL POPREAL8ARRAY(qtilde_k, 4)
      tempb = -(0.5d0*phi1_k*qtilde_kb)
      temp1 = 2.0*delx*dely
      tempb0 = -(phi2_k*qtilde_kb/6d0)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      phi1_kb = -(0.5d0*(delx*point%dq(1, :, k)+dely*point%dq(2, :, k))*&
&       qtilde_kb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb
      phi2_kb = -((delx**2*point%ddq(1, :, k)+temp1*point%ddq(2, :, k)+&
&       dely**2*point%ddq(3, :, k))*qtilde_kb/6d0)
      pointb%ddq(1, :, k) = pointb%ddq(1, :, k) + delx**2*tempb0
      pointb%ddq(2, :, k) = pointb%ddq(2, :, k) + temp1*tempb0
      pointb%ddq(3, :, k) = pointb%ddq(3, :, k) + dely**2*tempb0
      CALL POPREAL8ARRAY(qtilde_i, 4)
      tempb1 = -(0.5d0*phi1_i*qtilde_ib)
      temp0 = 2.0*delx*dely
      tempb2 = -(phi2_i*qtilde_ib/6d0)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      phi1_ib = phi1_ib - 0.5d0*(delx*point%dq(1, :, i)+dely*point%dq(2&
&       , :, i))*qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb1
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb1
      phi2_ib = phi2_ib - (delx**2*point%ddq(1, :, i)+temp0*point%ddq(2&
&       , :, i)+dely**2*point%ddq(3, :, i))*qtilde_ib/6d0
      pointb%ddq(1, :, i) = pointb%ddq(1, :, i) + delx**2*tempb2
      pointb%ddq(2, :, i) = pointb%ddq(2, :, i) + temp0*tempb2
      pointb%ddq(3, :, i) = pointb%ddq(3, :, i) + dely**2*tempb2
      CALL POPREAL8(deln_weights)
      CALL POPREAL8(dels_weights)
      CALL POPREAL8(dely)
      CALL POPREAL8(delx)
      pointb%phi2(:, k) = pointb%phi2(:, k) + phi2_kb
      pointb%phi1(:, k) = pointb%phi1(:, k) + phi1_kb
      CALL POPINTEGER4(k)
    END DO
    pointb%phi2(:, i) = pointb%phi2(:, i) + phi2_ib
    pointb%phi1(:, i) = pointb%phi1(:, i) + phi1_ib
  END SUBROUTINE WALL_DGY_NEG_B

  SUBROUTINE WALL_DGY_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi1_i(4), phi1_k(4)
    REAL*8 :: phi2_i(4), phi2_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    phi1_i = point%phi1(:, i)
    phi2_i = point%phi2(:, i)
    DO j=1,point%yneg_nbhs(i)
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      phi1_k = point%phi1(:, k)
      phi2_k = point%phi2(:, k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*phi1_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i)) - 1/6d0*phi2_i*(delx*delx*point%ddq(1, :&
&       , i)+2.0*delx*dely*point%ddq(2, :, i)+dely*dely*point%ddq(3, :, &
&       i))
      qtilde_k = point%q(:, k) - 0.5d0*phi1_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k)) - 1/6d0*phi2_k*(delx*delx*point%ddq(1, :&
&       , k)+2.0*delx*dely*point%ddq(2, :, k)+dely*dely*point%ddq(3, :, &
&       k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GYN(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GYN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGY_NEG

END MODULE WALL_FLUXES_MOD_DIFF

