!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
MODULE INTERIOR_FLUXES_MOD_DIFF
!	First written on 14.10.2016.
!	updated on Sep 23, 2017
!	
  USE DATA_STRUCTURE_MOD_DIFF
  USE SPLIT_FLUXES_MOD_DIFF
  USE Q_VARIABLES_MOD_DIFF
  USE LIMITERS_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of interior_dgx_pos in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: point.x point.y point.nx point.ny
!                point.q point.dq point.qm g
!   with respect to varying inputs: point.x point.y point.nx point.ny
!                point.q point.dq point.qm
!	This subroutine evaluates the interior flux derivative dGx_pos
  SUBROUTINE INTERIOR_DGX_POS_B(g, gb, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txb, tyb, nxb, nyb
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxb, delyb, detb, one_by_detb
    REAL*8 :: dels, deln
    REAL*8 :: delsb, delnb
!		
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: dist, weights
    REAL*8 :: distb, weightsb
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_ib(4), phi_kb(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsb, deln_weightsb
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxib(4), minib(4)
    INTRINSIC DSQRT
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    REAL*8 :: tempb1
    REAL*8, DIMENSION(4) :: tempb2
    REAL*8, DIMENSION(4) :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    INTEGER :: branch
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      CALL PUSHREAL8(dist)
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL PUSHREAL8ARRAY(phi_i, 4)
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL PUSHREAL8ARRAY(phi_k, 4)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
        CALL PUSHCONTROL2B(0)
      ELSE IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_i(r) = maxi(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_i(r) = mini(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_k(r) = maxi(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_k(r) = mini(r)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_i, 4)
      CALL FLUX_GXP(g_i, nx, ny, u1, u2, rho, pr)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_k, 4)
      CALL FLUX_GXP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    one_by_detb = SUM((sum_delx_delf*sum_dely_sqr-sum_dely_delf*&
&     sum_delx_dely)*gb)
    detb = -(one_by_detb/det**2)
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    tempb4 = one_by_det*gb
    sum_delx_delfb = sum_dely_sqr*tempb4
    sum_dely_sqrb = sum_delx_sqr*detb + SUM(sum_delx_delf*tempb4)
    sum_dely_delfb = -(sum_delx_dely*tempb4)
    sum_delx_delyb = -(2*sum_delx_dely*detb) - SUM(sum_dely_delf*tempb4)
    sum_delx_sqrb = sum_dely_sqr*detb
    txb = 0.0_8
    tyb = 0.0_8
    nxb = 0.0_8
    y_ib = 0.0_8
    nyb = 0.0_8
    g_ib = 0.0_8
    g_kb = 0.0_8
    x_ib = 0.0_8
    phi_ib = 0.0_8
    phi_kb = 0.0_8
    DO j=point%xpos_nbhs(i),1,-1
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      delx = x_k - x_i
      y_k = point%y(k)
      dely = y_k - y_i
      deln = delx*nx + dely*ny
      weights = dist**power
      deln_weights = deln*weights
      deln_weightsb = SUM((g_k-g_i)*sum_dely_delfb)
      dels = delx*tx + dely*ty
      dels_weights = dels*weights
      g_kb = g_kb + dels_weights*sum_delx_delfb + deln_weights*&
&       sum_dely_delfb
      g_ib = g_ib - dels_weights*sum_delx_delfb - deln_weights*&
&       sum_dely_delfb
      dels_weightsb = SUM((g_k-g_i)*sum_delx_delfb)
      CALL POPREAL8ARRAY(g_k, 4)
      CALL FLUX_GXP_B(g_k, g_kb, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_k, qtilde_kb, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPREAL8ARRAY(g_i, 4)
      CALL FLUX_GXP_B(g_i, g_ib, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_i, qtilde_ib, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        tempb3 = -(0.5d0*phi_i*qtilde_ib)
        tempb2 = -(0.5d0*phi_k*qtilde_kb)
        pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
        phi_kb = phi_kb - 0.5d0*(delx*point%dq(1, :, k)+dely*point%dq(2&
&         , :, k))*qtilde_kb
        delxb = SUM(point%dq(1, :, i)*tempb3) + SUM(point%dq(1, :, k)*&
&         tempb2)
        pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb2
        delyb = SUM(point%dq(2, :, i)*tempb3) + SUM(point%dq(2, :, k)*&
&         tempb2)
        pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb2
        pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
        phi_ib = phi_ib - 0.5d0*(delx*point%dq(1, :, i)+dely*point%dq(2&
&         , :, i))*qtilde_ib
        pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb3
        pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb3
        qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&         point%dq(2, :, k))
        CALL POPREAL8ARRAY(phi_k, 4)
        CALL VENKAT_LIMITER_B(qtilde_k, qtilde_kb, phi_k, phi_kb, k)
        qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&         point%dq(2, :, i))
        CALL POPREAL8ARRAY(phi_i, 4)
        CALL VENKAT_LIMITER_B(qtilde_i, qtilde_ib, phi_i, phi_ib, i)
      ELSE
        IF (branch .EQ. 1) THEN
          minib = 0.0_8
          maxib = 0.0_8
          DO r=4,1,-1
            CALL POPCONTROL1B(branch)
            IF (branch .NE. 0) THEN
              minib(r) = minib(r) + qtilde_kb(r)
              qtilde_kb(r) = 0.0_8
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              maxib(r) = maxib(r) + qtilde_kb(r)
              qtilde_kb(r) = 0.0_8
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              minib(r) = minib(r) + qtilde_ib(r)
              qtilde_ib(r) = 0.0_8
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              maxib(r) = maxib(r) + qtilde_ib(r)
              qtilde_ib(r) = 0.0_8
            END IF
          END DO
          CALL MIN_Q_VALUE_B(i, mini, minib)
          CALL MAX_Q_VALUE_B(i, maxi, maxib)
        END IF
        delxb = 0.0_8
        delyb = 0.0_8
      END IF
      deln_weightsb = deln_weightsb + deln*sum_dely_sqrb + dels*&
&       sum_delx_delyb
      dels_weightsb = dels_weightsb + dels*sum_delx_sqrb
      weightsb = dels*dels_weightsb + deln*deln_weightsb
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        distb = 0.0
      ELSE
        distb = power*dist**(power-1)*weightsb
      END IF
      IF (dels**2 + deln**2 .EQ. 0.0) THEN
        tempb1 = 0.0
      ELSE
        tempb1 = distb/(2.D0*DSQRT(dels**2+deln**2))
      END IF
      delnb = weights*deln_weightsb + 2*deln*tempb1 + deln_weights*&
&       sum_dely_sqrb
      delsb = dels_weights*sum_delx_sqrb + 2*dels*tempb1 + weights*&
&       dels_weightsb + deln_weights*sum_delx_delyb
      tempb0 = -(0.5d0*qtilde_ib)
      CALL POPREAL8ARRAY(qtilde_k, 4)
      tempb = -(0.5d0*qtilde_kb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      delxb = delxb + SUM(point%dq(1, :, i)*tempb0) + tx*delsb + nx*&
&       delnb + SUM(point%dq(1, :, k)*tempb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb
      delyb = delyb + SUM(point%dq(2, :, i)*tempb0) + ty*delsb + ny*&
&       delnb + SUM(point%dq(2, :, k)*tempb)
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb
      CALL POPREAL8ARRAY(qtilde_i, 4)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb0
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb0
      CALL POPREAL8(dist)
      nxb = nxb + delx*delnb
      nyb = nyb + dely*delnb
      txb = txb + delx*delsb
      tyb = tyb + dely*delsb
      y_kb = delyb
      y_ib = y_ib - delyb
      x_kb = delxb
      x_ib = x_ib - delxb
      pointb%y(k) = pointb%y(k) + y_kb
      pointb%x(k) = pointb%x(k) + x_kb
    END DO
    nxb = nxb - tyb
    nyb = nyb + txb
    pointb%ny(i) = pointb%ny(i) + nyb
    pointb%nx(i) = pointb%nx(i) + nxb
    pointb%y(i) = pointb%y(i) + y_ib
    pointb%x(i) = pointb%x(i) + x_ib
  END SUBROUTINE INTERIOR_DGX_POS_B

!	This subroutine evaluates the interior flux derivative dGx_pos
  SUBROUTINE INTERIOR_DGX_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
!		
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: maxi(4), mini(4)
    INTRINSIC DSQRT
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      ELSE IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) qtilde_i(r) = maxi(r)
          IF (qtilde_i(r) .LT. mini(r)) qtilde_i(r) = mini(r)
          IF (qtilde_k(r) .GT. maxi(r)) qtilde_k(r) = maxi(r)
          IF (qtilde_k(r) .LT. mini(r)) qtilde_k(r) = mini(r)
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GXP(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GXP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGX_POS

!  Differentiation of interior_dgx_neg in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: point.x point.y point.nx point.ny
!                point.q point.dq point.qm g
!   with respect to varying inputs: point.x point.y point.nx point.ny
!                point.q point.dq point.qm
!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGX_NEG_B(g, gb, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txb, tyb, nxb, nyb
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxb, delyb, detb, one_by_detb
    REAL*8 :: dels, deln
    REAL*8 :: delsb, delnb
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: dist, weights
    REAL*8 :: distb, weightsb
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_ib(4), phi_kb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxib(4), minib(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsb, deln_weightsb
    INTRINSIC DSQRT
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    REAL*8 :: tempb1
    REAL*8, DIMENSION(4) :: tempb2
    REAL*8, DIMENSION(4) :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    INTEGER :: branch
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      CALL PUSHREAL8(dist)
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL PUSHREAL8ARRAY(phi_i, 4)
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL PUSHREAL8ARRAY(phi_k, 4)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_i(r) = maxi(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_i(r) = mini(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_k(r) = maxi(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_k(r) = mini(r)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_i, 4)
      CALL FLUX_GXN(g_i, nx, ny, u1, u2, rho, pr)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_k, 4)
      CALL FLUX_GXN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    one_by_detb = SUM((sum_delx_delf*sum_dely_sqr-sum_dely_delf*&
&     sum_delx_dely)*gb)
    detb = -(one_by_detb/det**2)
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    tempb4 = one_by_det*gb
    sum_delx_delfb = sum_dely_sqr*tempb4
    sum_dely_sqrb = sum_delx_sqr*detb + SUM(sum_delx_delf*tempb4)
    sum_dely_delfb = -(sum_delx_dely*tempb4)
    sum_delx_delyb = -(2*sum_delx_dely*detb) - SUM(sum_dely_delf*tempb4)
    sum_delx_sqrb = sum_dely_sqr*detb
    txb = 0.0_8
    tyb = 0.0_8
    nxb = 0.0_8
    nyb = 0.0_8
    y_ib = 0.0_8
    g_ib = 0.0_8
    g_kb = 0.0_8
    x_ib = 0.0_8
    phi_ib = 0.0_8
    phi_kb = 0.0_8
    DO j=point%xneg_nbhs(i),1,-1
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      delx = x_k - x_i
      y_k = point%y(k)
      dely = y_k - y_i
      deln = delx*nx + dely*ny
      weights = dist**power
      deln_weights = deln*weights
      deln_weightsb = SUM((g_k-g_i)*sum_dely_delfb)
      dels = delx*tx + dely*ty
      dels_weights = dels*weights
      g_kb = g_kb + dels_weights*sum_delx_delfb + deln_weights*&
&       sum_dely_delfb
      g_ib = g_ib - dels_weights*sum_delx_delfb - deln_weights*&
&       sum_dely_delfb
      dels_weightsb = SUM((g_k-g_i)*sum_delx_delfb)
      CALL POPREAL8ARRAY(g_k, 4)
      CALL FLUX_GXN_B(g_k, g_kb, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_k, qtilde_kb, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPREAL8ARRAY(g_i, 4)
      CALL FLUX_GXN_B(g_i, g_ib, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_i, qtilde_ib, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        minib = 0.0_8
        maxib = 0.0_8
        DO r=4,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            minib(r) = minib(r) + qtilde_kb(r)
            qtilde_kb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            maxib(r) = maxib(r) + qtilde_kb(r)
            qtilde_kb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            minib(r) = minib(r) + qtilde_ib(r)
            qtilde_ib(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            maxib(r) = maxib(r) + qtilde_ib(r)
            qtilde_ib(r) = 0.0_8
          END IF
        END DO
        CALL MIN_Q_VALUE_B(i, mini, minib)
        CALL MAX_Q_VALUE_B(i, maxi, maxib)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        tempb3 = -(0.5d0*phi_i*qtilde_ib)
        tempb2 = -(0.5d0*phi_k*qtilde_kb)
        pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
        phi_kb = phi_kb - 0.5d0*(delx*point%dq(1, :, k)+dely*point%dq(2&
&         , :, k))*qtilde_kb
        delxb = SUM(point%dq(1, :, i)*tempb3) + SUM(point%dq(1, :, k)*&
&         tempb2)
        pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb2
        delyb = SUM(point%dq(2, :, i)*tempb3) + SUM(point%dq(2, :, k)*&
&         tempb2)
        pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb2
        pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
        phi_ib = phi_ib - 0.5d0*(delx*point%dq(1, :, i)+dely*point%dq(2&
&         , :, i))*qtilde_ib
        pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb3
        pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb3
        qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&         point%dq(2, :, k))
        CALL POPREAL8ARRAY(phi_k, 4)
        CALL VENKAT_LIMITER_B(qtilde_k, qtilde_kb, phi_k, phi_kb, k)
        qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&         point%dq(2, :, i))
        CALL POPREAL8ARRAY(phi_i, 4)
        CALL VENKAT_LIMITER_B(qtilde_i, qtilde_ib, phi_i, phi_ib, i)
      ELSE
        delxb = 0.0_8
        delyb = 0.0_8
      END IF
      deln_weightsb = deln_weightsb + deln*sum_dely_sqrb + dels*&
&       sum_delx_delyb
      dels_weightsb = dels_weightsb + dels*sum_delx_sqrb
      weightsb = dels*dels_weightsb + deln*deln_weightsb
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        distb = 0.0
      ELSE
        distb = power*dist**(power-1)*weightsb
      END IF
      IF (dels**2 + deln**2 .EQ. 0.0) THEN
        tempb1 = 0.0
      ELSE
        tempb1 = distb/(2.D0*DSQRT(dels**2+deln**2))
      END IF
      delnb = weights*deln_weightsb + 2*deln*tempb1 + deln_weights*&
&       sum_dely_sqrb
      delsb = dels_weights*sum_delx_sqrb + 2*dels*tempb1 + weights*&
&       dels_weightsb + deln_weights*sum_delx_delyb
      tempb0 = -(0.5d0*qtilde_ib)
      CALL POPREAL8ARRAY(qtilde_k, 4)
      tempb = -(0.5d0*qtilde_kb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      delxb = delxb + SUM(point%dq(1, :, i)*tempb0) + tx*delsb + nx*&
&       delnb + SUM(point%dq(1, :, k)*tempb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb
      delyb = delyb + SUM(point%dq(2, :, i)*tempb0) + ty*delsb + ny*&
&       delnb + SUM(point%dq(2, :, k)*tempb)
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb
      CALL POPREAL8ARRAY(qtilde_i, 4)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb0
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb0
      CALL POPREAL8(dist)
      nxb = nxb + delx*delnb
      nyb = nyb + dely*delnb
      txb = txb + delx*delsb
      tyb = tyb + dely*delsb
      y_kb = delyb
      y_ib = y_ib - delyb
      x_kb = delxb
      x_ib = x_ib - delxb
      pointb%y(k) = pointb%y(k) + y_kb
      pointb%x(k) = pointb%x(k) + x_kb
    END DO
    nxb = nxb - tyb
    nyb = nyb + txb
    pointb%ny(i) = pointb%ny(i) + nyb
    pointb%nx(i) = pointb%nx(i) + nxb
    pointb%y(i) = pointb%y(i) + y_ib
    pointb%x(i) = pointb%x(i) + x_ib
  END SUBROUTINE INTERIOR_DGX_NEG_B

!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGX_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) qtilde_i(r) = maxi(r)
          IF (qtilde_i(r) .LT. mini(r)) qtilde_i(r) = mini(r)
          IF (qtilde_k(r) .GT. maxi(r)) qtilde_k(r) = maxi(r)
          IF (qtilde_k(r) .LT. mini(r)) qtilde_k(r) = mini(r)
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GXN(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GXN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGX_NEG

!  Differentiation of interior_dgy_pos in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: point.x point.y point.nx point.ny
!                point.q point.dq point.qm g
!   with respect to varying inputs: point.x point.y point.nx point.ny
!                point.q point.dq point.qm
!	This subroutine evaluates the interior flux derivative dGx_neg
!
!
  SUBROUTINE INTERIOR_DGY_POS_B(g, gb, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txb, tyb, nxb, nyb
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxb, delyb, detb, one_by_detb
    REAL*8 :: dels, deln
    REAL*8 :: delsb, delnb
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: dist, weights
    REAL*8 :: distb, weightsb
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_ib(4), phi_kb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxib(4), minib(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsb, deln_weightsb
    INTRINSIC DSQRT
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    REAL*8 :: tempb1
    REAL*8, DIMENSION(4) :: tempb2
    REAL*8, DIMENSION(4) :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    INTEGER :: branch
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%ypos_nbhs(i)
      k = point%ypos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      CALL PUSHREAL8(dist)
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL PUSHREAL8ARRAY(phi_i, 4)
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL PUSHREAL8ARRAY(phi_k, 4)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_i(r) = maxi(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_i(r) = mini(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_k(r) = maxi(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_k(r) = mini(r)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_i, 4)
      CALL FLUX_GYP(g_i, nx, ny, u1, u2, rho, pr)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_k, 4)
      CALL FLUX_GYP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    one_by_detb = SUM((sum_dely_delf*sum_delx_sqr-sum_delx_delf*&
&     sum_delx_dely)*gb)
    detb = -(one_by_detb/det**2)
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    tempb4 = one_by_det*gb
    sum_dely_delfb = sum_delx_sqr*tempb4
    sum_delx_sqrb = sum_dely_sqr*detb + SUM(sum_dely_delf*tempb4)
    sum_delx_delfb = -(sum_delx_dely*tempb4)
    sum_delx_delyb = -(2*sum_delx_dely*detb) - SUM(sum_delx_delf*tempb4)
    sum_dely_sqrb = sum_delx_sqr*detb
    txb = 0.0_8
    tyb = 0.0_8
    nxb = 0.0_8
    nyb = 0.0_8
    y_ib = 0.0_8
    g_ib = 0.0_8
    g_kb = 0.0_8
    x_ib = 0.0_8
    phi_ib = 0.0_8
    phi_kb = 0.0_8
    DO j=point%ypos_nbhs(i),1,-1
      k = point%ypos_conn(i, j)
      x_k = point%x(k)
      delx = x_k - x_i
      y_k = point%y(k)
      dely = y_k - y_i
      deln = delx*nx + dely*ny
      weights = dist**power
      deln_weights = deln*weights
      deln_weightsb = SUM((g_k-g_i)*sum_dely_delfb)
      dels = delx*tx + dely*ty
      dels_weights = dels*weights
      g_kb = g_kb + dels_weights*sum_delx_delfb + deln_weights*&
&       sum_dely_delfb
      g_ib = g_ib - dels_weights*sum_delx_delfb - deln_weights*&
&       sum_dely_delfb
      dels_weightsb = SUM((g_k-g_i)*sum_delx_delfb)
      CALL POPREAL8ARRAY(g_k, 4)
      CALL FLUX_GYP_B(g_k, g_kb, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_k, qtilde_kb, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPREAL8ARRAY(g_i, 4)
      CALL FLUX_GYP_B(g_i, g_ib, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_i, qtilde_ib, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        minib = 0.0_8
        maxib = 0.0_8
        DO r=4,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            minib(r) = minib(r) + qtilde_kb(r)
            qtilde_kb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            maxib(r) = maxib(r) + qtilde_kb(r)
            qtilde_kb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            minib(r) = minib(r) + qtilde_ib(r)
            qtilde_ib(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            maxib(r) = maxib(r) + qtilde_ib(r)
            qtilde_ib(r) = 0.0_8
          END IF
        END DO
        CALL MIN_Q_VALUE_B(i, mini, minib)
        CALL MAX_Q_VALUE_B(i, maxi, maxib)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        tempb3 = -(0.5d0*phi_i*qtilde_ib)
        tempb2 = -(0.5d0*phi_k*qtilde_kb)
        pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
        phi_kb = phi_kb - 0.5d0*(delx*point%dq(1, :, k)+dely*point%dq(2&
&         , :, k))*qtilde_kb
        delxb = SUM(point%dq(1, :, i)*tempb3) + SUM(point%dq(1, :, k)*&
&         tempb2)
        pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb2
        delyb = SUM(point%dq(2, :, i)*tempb3) + SUM(point%dq(2, :, k)*&
&         tempb2)
        pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb2
        pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
        phi_ib = phi_ib - 0.5d0*(delx*point%dq(1, :, i)+dely*point%dq(2&
&         , :, i))*qtilde_ib
        pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb3
        pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb3
        qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&         point%dq(2, :, k))
        CALL POPREAL8ARRAY(phi_k, 4)
        CALL VENKAT_LIMITER_B(qtilde_k, qtilde_kb, phi_k, phi_kb, k)
        qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&         point%dq(2, :, i))
        CALL POPREAL8ARRAY(phi_i, 4)
        CALL VENKAT_LIMITER_B(qtilde_i, qtilde_ib, phi_i, phi_ib, i)
      ELSE
        delxb = 0.0_8
        delyb = 0.0_8
      END IF
      deln_weightsb = deln_weightsb + deln*sum_dely_sqrb + dels*&
&       sum_delx_delyb
      dels_weightsb = dels_weightsb + dels*sum_delx_sqrb
      weightsb = dels*dels_weightsb + deln*deln_weightsb
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        distb = 0.0
      ELSE
        distb = power*dist**(power-1)*weightsb
      END IF
      IF (dels**2 + deln**2 .EQ. 0.0) THEN
        tempb1 = 0.0
      ELSE
        tempb1 = distb/(2.D0*DSQRT(dels**2+deln**2))
      END IF
      delnb = weights*deln_weightsb + 2*deln*tempb1 + deln_weights*&
&       sum_dely_sqrb
      delsb = dels_weights*sum_delx_sqrb + 2*dels*tempb1 + weights*&
&       dels_weightsb + deln_weights*sum_delx_delyb
      tempb0 = -(0.5d0*qtilde_ib)
      CALL POPREAL8ARRAY(qtilde_k, 4)
      tempb = -(0.5d0*qtilde_kb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      delxb = delxb + SUM(point%dq(1, :, i)*tempb0) + tx*delsb + nx*&
&       delnb + SUM(point%dq(1, :, k)*tempb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb
      delyb = delyb + SUM(point%dq(2, :, i)*tempb0) + ty*delsb + ny*&
&       delnb + SUM(point%dq(2, :, k)*tempb)
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb
      CALL POPREAL8ARRAY(qtilde_i, 4)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb0
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb0
      CALL POPREAL8(dist)
      nxb = nxb + delx*delnb
      nyb = nyb + dely*delnb
      txb = txb + delx*delsb
      tyb = tyb + dely*delsb
      y_kb = delyb
      y_ib = y_ib - delyb
      x_kb = delxb
      x_ib = x_ib - delxb
      pointb%y(k) = pointb%y(k) + y_kb
      pointb%x(k) = pointb%x(k) + x_kb
    END DO
    nxb = nxb - tyb
    nyb = nyb + txb
    pointb%ny(i) = pointb%ny(i) + nyb
    pointb%nx(i) = pointb%nx(i) + nxb
    pointb%y(i) = pointb%y(i) + y_ib
    pointb%x(i) = pointb%x(i) + x_ib
  END SUBROUTINE INTERIOR_DGY_POS_B

!	This subroutine evaluates the interior flux derivative dGx_neg
!
!
  SUBROUTINE INTERIOR_DGY_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%ypos_nbhs(i)
      k = point%ypos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) qtilde_i(r) = maxi(r)
          IF (qtilde_i(r) .LT. mini(r)) qtilde_i(r) = mini(r)
          IF (qtilde_k(r) .GT. maxi(r)) qtilde_k(r) = maxi(r)
          IF (qtilde_k(r) .LT. mini(r)) qtilde_k(r) = mini(r)
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GYP(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GYP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGY_POS

!  Differentiation of interior_dgy_neg in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: point.x point.y point.nx point.ny
!                point.q point.dq point.qm g
!   with respect to varying inputs: point.x point.y point.nx point.ny
!                point.q point.dq point.qm
!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGY_NEG_B(g, gb, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txb, tyb, nxb, nyb
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxb, delyb, detb, one_by_detb
    REAL*8 :: dels, deln
    REAL*8 :: delsb, delnb
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: dist, weights
    REAL*8 :: distb, weightsb
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_ib(4), phi_kb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxib(4), minib(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsb, deln_weightsb
    INTRINSIC DSQRT
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    REAL*8 :: tempb1
    REAL*8, DIMENSION(4) :: tempb2
    REAL*8, DIMENSION(4) :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    INTEGER :: branch
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%yneg_nbhs(i)
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      CALL PUSHREAL8(dist)
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL PUSHREAL8ARRAY(phi_i, 4)
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL PUSHREAL8ARRAY(phi_k, 4)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_i(r) = maxi(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_i(r) = mini(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_k(r) = maxi(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_k(r) = mini(r)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_i, 4)
      CALL FLUX_GYN(g_i, nx, ny, u1, u2, rho, pr)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_k, 4)
      CALL FLUX_GYN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    one_by_detb = SUM((sum_dely_delf*sum_delx_sqr-sum_delx_delf*&
&     sum_delx_dely)*gb)
    detb = -(one_by_detb/det**2)
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    tempb4 = one_by_det*gb
    sum_dely_delfb = sum_delx_sqr*tempb4
    sum_delx_sqrb = sum_dely_sqr*detb + SUM(sum_dely_delf*tempb4)
    sum_delx_delfb = -(sum_delx_dely*tempb4)
    sum_delx_delyb = -(2*sum_delx_dely*detb) - SUM(sum_delx_delf*tempb4)
    sum_dely_sqrb = sum_delx_sqr*detb
    txb = 0.0_8
    tyb = 0.0_8
    nxb = 0.0_8
    y_ib = 0.0_8
    nyb = 0.0_8
    g_ib = 0.0_8
    g_kb = 0.0_8
    x_ib = 0.0_8
    phi_ib = 0.0_8
    phi_kb = 0.0_8
    DO j=point%yneg_nbhs(i),1,-1
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      delx = x_k - x_i
      y_k = point%y(k)
      dely = y_k - y_i
      deln = delx*nx + dely*ny
      weights = dist**power
      deln_weights = deln*weights
      deln_weightsb = SUM((g_k-g_i)*sum_dely_delfb)
      dels = delx*tx + dely*ty
      dels_weights = dels*weights
      g_kb = g_kb + dels_weights*sum_delx_delfb + deln_weights*&
&       sum_dely_delfb
      g_ib = g_ib - dels_weights*sum_delx_delfb - deln_weights*&
&       sum_dely_delfb
      dels_weightsb = SUM((g_k-g_i)*sum_delx_delfb)
      CALL POPREAL8ARRAY(g_k, 4)
      CALL FLUX_GYN_B(g_k, g_kb, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_k, qtilde_kb, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPREAL8ARRAY(g_i, 4)
      CALL FLUX_GYN_B(g_i, g_ib, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_i, qtilde_ib, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        minib = 0.0_8
        maxib = 0.0_8
        DO r=4,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            minib(r) = minib(r) + qtilde_kb(r)
            qtilde_kb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            maxib(r) = maxib(r) + qtilde_kb(r)
            qtilde_kb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            minib(r) = minib(r) + qtilde_ib(r)
            qtilde_ib(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            maxib(r) = maxib(r) + qtilde_ib(r)
            qtilde_ib(r) = 0.0_8
          END IF
        END DO
        CALL MIN_Q_VALUE_B(i, mini, minib)
        CALL MAX_Q_VALUE_B(i, maxi, maxib)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        tempb3 = -(0.5d0*phi_i*qtilde_ib)
        tempb2 = -(0.5d0*phi_k*qtilde_kb)
        pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
        phi_kb = phi_kb - 0.5d0*(delx*point%dq(1, :, k)+dely*point%dq(2&
&         , :, k))*qtilde_kb
        delxb = SUM(point%dq(1, :, i)*tempb3) + SUM(point%dq(1, :, k)*&
&         tempb2)
        pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb2
        delyb = SUM(point%dq(2, :, i)*tempb3) + SUM(point%dq(2, :, k)*&
&         tempb2)
        pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb2
        pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
        phi_ib = phi_ib - 0.5d0*(delx*point%dq(1, :, i)+dely*point%dq(2&
&         , :, i))*qtilde_ib
        pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb3
        pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb3
        qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&         point%dq(2, :, k))
        CALL POPREAL8ARRAY(phi_k, 4)
        CALL VENKAT_LIMITER_B(qtilde_k, qtilde_kb, phi_k, phi_kb, k)
        qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&         point%dq(2, :, i))
        CALL POPREAL8ARRAY(phi_i, 4)
        CALL VENKAT_LIMITER_B(qtilde_i, qtilde_ib, phi_i, phi_ib, i)
      ELSE
        delxb = 0.0_8
        delyb = 0.0_8
      END IF
      deln_weightsb = deln_weightsb + deln*sum_dely_sqrb + dels*&
&       sum_delx_delyb
      dels_weightsb = dels_weightsb + dels*sum_delx_sqrb
      weightsb = dels*dels_weightsb + deln*deln_weightsb
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        distb = 0.0
      ELSE
        distb = power*dist**(power-1)*weightsb
      END IF
      IF (dels**2 + deln**2 .EQ. 0.0) THEN
        tempb1 = 0.0
      ELSE
        tempb1 = distb/(2.D0*DSQRT(dels**2+deln**2))
      END IF
      delnb = weights*deln_weightsb + 2*deln*tempb1 + deln_weights*&
&       sum_dely_sqrb
      delsb = dels_weights*sum_delx_sqrb + 2*dels*tempb1 + weights*&
&       dels_weightsb + deln_weights*sum_delx_delyb
      tempb0 = -(0.5d0*qtilde_ib)
      CALL POPREAL8ARRAY(qtilde_k, 4)
      tempb = -(0.5d0*qtilde_kb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      delxb = delxb + SUM(point%dq(1, :, i)*tempb0) + tx*delsb + nx*&
&       delnb + SUM(point%dq(1, :, k)*tempb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb
      delyb = delyb + SUM(point%dq(2, :, i)*tempb0) + ty*delsb + ny*&
&       delnb + SUM(point%dq(2, :, k)*tempb)
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb
      CALL POPREAL8ARRAY(qtilde_i, 4)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb0
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb0
      CALL POPREAL8(dist)
      nxb = nxb + delx*delnb
      nyb = nyb + dely*delnb
      txb = txb + delx*delsb
      tyb = tyb + dely*delsb
      y_kb = delyb
      y_ib = y_ib - delyb
      x_kb = delxb
      x_ib = x_ib - delxb
      pointb%y(k) = pointb%y(k) + y_kb
      pointb%x(k) = pointb%x(k) + x_kb
    END DO
    nxb = nxb - tyb
    nyb = nyb + txb
    pointb%ny(i) = pointb%ny(i) + nyb
    pointb%nx(i) = pointb%nx(i) + nxb
    pointb%y(i) = pointb%y(i) + y_ib
    pointb%x(i) = pointb%x(i) + x_ib
  END SUBROUTINE INTERIOR_DGY_NEG_B

!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGY_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%yneg_nbhs(i)
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) qtilde_i(r) = maxi(r)
          IF (qtilde_i(r) .LT. mini(r)) qtilde_i(r) = mini(r)
          IF (qtilde_k(r) .GT. maxi(r)) qtilde_k(r) = maxi(r)
          IF (qtilde_k(r) .LT. mini(r)) qtilde_k(r) = mini(r)
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GYN(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GYN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGY_NEG

END MODULE INTERIOR_FLUXES_MOD_DIFF

