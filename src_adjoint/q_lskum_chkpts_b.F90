!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
MODULE Q_LSKUM_MOD_CHKPTS_DIFF
#include <petsc/finclude/petscsys.h>

!
!
  USE DATA_STRUCTURE_MOD_DIFF
  USE PETSC_DATA_STRUCTURE_MOD
  USE POINT_NORMALS_MOD_DIFF
  USE GENERATE_CONNECTIVITY_MOD_DIFF
  USE FPI_SOLVER_MOD_DIFF
  IMPLICIT NONE
!
!	
CONTAINS
!
!
  SUBROUTINE Q_LSKUM_CHKPTS_B()
    IMPLICIT NONE
!						
!		
    INTEGER :: t, i, r, ijk, k
    INTEGER :: ii1
    integer :: pflag = 1
    real :: SF
!
!
!     Declaration for running the revolve algorithm ...
!    Parameters ..
!
      REAL*8 :: TAKSHT,ADVAN,FSTURN,YUTURN
      PARAMETER (TAKSHT=1,ADVAN=2,FSTURN=3,YUTURN=4)
      REAL*8 :: RESTRE,TRMATE,ERROR
      PARAMETER (RESTRE=5,TRMATE=6,ERROR=7)
!
!  .. Local Scalars ..                                                       
!                                                                               
      INTEGER :: CAPO,CHECK,FINE,INFO,SNAPS,STEPS,WHATDO
      INTEGER :: OLDCAPO,new_itime, ITIME, ITIMS, ITIM
! 
!     .. External Functions ..                                                  
!                                                                               
      INTEGER :: REVOLV, ADJUST, PFS
      EXTERNAL REVOLV, ADJUST
!                                                                               
      intrinsic cpu_time 
      real*8 :: start_time, end_time
!

      real*8, allocatable :: prim_stor(:, :, :), qm_stor(:, :, :, :)
      real*8, allocatable :: q_stor(:, :, :), dq_stor(:, :, :, :)
      real*8, allocatable :: fluxres_stor(:, :, :), delta_stor(:, :)
      real*8, allocatable :: primold_stor(:, :, :)
      PetscErrorCode :: ierr

      ! Allocate store variables

      allocate( prim_stor(0:chkpts, 4, max_points))
      allocate( primold_stor(0:chkpts, 4, max_points))
      allocate( q_stor(0:chkpts, 4, max_points))
      allocate( fluxres_stor(0:chkpts, 4, max_points))
      allocate( dq_stor(0:chkpts, 2, 4, max_points))
      allocate( qm_stor(0:chkpts, 2, 4, max_points))
      allocate( delta_stor(0:chkpts, max_points))
!                                                                               
!       End of the declaraion for the revolve algorithm ..          
!
!       Some initialisations for the revolve alogorithm ..                      
      if(restart == 0)itr = 0
      ITIMS = 1
      ITIME = max_iters
      new_itime = ITIME - ITIMS + 1 
      CAPO = 0
      STEPS = new_itime
      FINE = STEPS + CAPO
      CHECK = -1
!      SNAPS = ADJUST(STEPS)                                                    
!
!     Here SNAPS are the no. of checkpoints assigned ..
!
      SNAPS = chkpts
      INFO = 5

      if(rank==0)OPEN(UNIT=301,FILE="residue",FORM="FORMATTED",STATUS="REPLACE",ACTION="WRITE")
      if(rank==0)OPEN(UNIT=302,FILE="residue_b",FORM="FORMATTED",STATUS="REPLACE",ACTION="WRITE")

!
!
!
    CALL COMPUTE_NORMALS()
    CALL GENERATE_CONNECTIVITY()
    call set_obj()
    if(rank == 0) then
            write(*,*)'%%%%-Normals and connectivity generated-%%%'
            write(*,*)
    end if
!
!   The revolve algorithm starts here ..
!
!
   10 CONTINUE
      OLDCAPO = CAPO
      WHATDO = REVOLV(CHECK,CAPO,FINE,SNAPS,INFO,SF,PFS)

!  
!                                                                             
!       The below if condition stores the check-points ..                       
!                                                                               
      IF ((WHATDO.EQ.TAKSHT) .AND. (INFO.GT.1)) THEN
!                                                                               
            do i=1,max_points
                  delta_stor(check, i) = point%delta(i)
                  do r = 1, 4
                    q_stor(check, r, i) = point%q(r,i)
                    prim_stor(check, r, i) = point%prim(r,i)
                    primold_stor(check, r, i) = point%prim_old(r,i)
                    fluxres_stor(check, r, i) = point%flux_res(r,i)
                    do k = 1, 2
                      dq_stor(check, k, r, i) = point%dq(k , r , i)
                      qm_stor(check, k, r, i) = point%qm(k , r , i)
                    end do
                  enddo
            enddo
     END IF
!
!
!   The below if condition runs the forward mode without 
!   storing the intermediate values ..
!                                                                                                                                                  
      IF ((WHATDO.EQ.ADVAN) .AND. (INFO.GT.2)) THEN
!          WRITE (*,FMT=9010) CAPO
!
          do ijk=OLDCAPO, CAPO-1
                  ITIM = ijk+ITIMS
                  ITIM = ITIM + itr
                  if(rank == 0 .and. ITIM == itr+1) then
                          write (*,*)
                          write (*,*) 'prediction of needed forward steps :', PFS
                          write (*,*) 'slowdown factor :', SF
                          write (*,*)
                  end if
                  CALL FPI_SOLVER(ITIM)
                  if (rank==0 .and. pflag == 1) then
                       write(*,'(a12,i8,a15,e30.20)')'iterations:',ITIM,'residue:',residue
                       write(301, *) itim, residue
                  end if
          end do
      END IF
!
!
!   The below if condition runs the first reverse step.
!   This requires the initialisation of the adjoint vectors ..
!
!
      IF ((WHATDO.EQ.FSTURN) .AND. (INFO.GT.2)) THEN
!
           ITIM = CAPO + ITIMS
           ITIM = ITIM + itr

           pointb%x = 0.0_8
           pointb%y = 0.0_8
           pointb%nx = 0.0_8
           pointb%ny = 0.0_8
           pointb%prim = 0.0_8
           pointb%prim_old = 0.0_8
           pointb%flux_res = 0.0_8
           pointb%q = 0.0_8
           pointb%dq = 0.0_8
           pointb%qm = 0.0_8
           pointb%vorticity_sqr = 0.0_8
           pointb%delta = 0.0_8

           if(rank == 0) then
                write(*,*)
                write(*,*)'%%%%%%%%-Adjoint computations begin-%%%%%%%'
                write(*,*)
           end if
           
           pflag = 0
!
           CALL FPI_SOLVER_B(ITIM)
           if (rank==0) then
             write(*,*)'adjoint iterations:',itim, 'adjoint residue:', adj_res
             write(302, *) itim, adj_res
           end if

           total_enstrophyb = 0.0_8
           cdb = 0.0_8
           clb = 0.0_8
           clcdb = 0.0_8
           cmb = 0.0_8
           total_entropyb = 0.0_8
!
      END IF
!
!
!      The below if condition runs the subsequent reverse steps .. 
!                                                                                                                                                  
      IF ((WHATDO.EQ.YUTURN) .AND. (INFO.GT.2)) THEN
!
           ITIM = CAPO + ITIMS
           ITIM = ITIM + itr
           CALL FPI_SOLVER_B(ITIM)
           if (rank==0) then
             write(*,*)'adjoint iterations:',itim, 'adjoint residue:', adj_res
             write(302, *) itim, adj_res
           end if

           total_enstrophyb = 0.0_8
           cdb = 0.0_8
           clb = 0.0_8
           clcdb = 0.0_8
           cmb = 0.0_8
           total_entropyb = 0.0_8
!
      END IF
!
!
!           The below if condition restores the state vectors 
!             at the check points ..  
!                                                                                                                                                  
      IF ((WHATDO.EQ.RESTRE) .AND. (INFO.GT.2)) THEN
!
            do i=1,max_points
                  point%delta(i) = delta_stor(check, i)
                  do r = 1, 4
                    point%q(r,i) = q_stor(check, r, i)
                    point%prim(r,i) = prim_stor(check, r, i)
                    point%prim_old(r,i) = primold_stor(check, r, i)
                    point%flux_res(r,i) = fluxres_stor(check, r, i)
                    do k = 1, 2
                      point%dq(k, r, i) = dq_stor(check, k, r, i)
                      point%qm(k, r, i) = qm_stor(check, k, r, i)
                    end do
                  enddo
            enddo
      
      END IF
!
!
      IF (WHATDO.EQ.ERROR) THEN
          WRITE (*,FMT=*) ' irregular termination of treeverse'
          IF (INFO.EQ.10) THEN
              WRITE (*,FMT=*) ' number of checkpoints stored exceeds CHEKUP,'
              WRITE (*,FMT=*) ' increase constant CHEKUP and recompile'
          END IF
!
          IF (INFO.EQ.11) THEN
              WRITE (*,FMT=*) ' number of checkpoints stored = ', CHECK + 1,' exceeds SNAPS,'
              WRITE (*,FMT=*) ' ensure SNAPS > 0 and ', 'increase initial FINE'
          END IF

          IF (INFO.EQ.12) WRITE (*,FMT=*) ' error occurs in NUMFRW'
          IF (INFO.EQ.13) THEN
              WRITE (*,FMT=*) ' enhancement of FINE, SNAPS = ', CHECK + 1,'checkpoints stored, increase SNAPS'
          END IF
          IF (INFO.EQ.14) THEN
              WRITE (*,FMT=*) ' number of SNAPS = ',SNAPS, ' exceeds CHEKUP,'
              WRITE (*,FMT=*) ' increase constant CHEKUP and recompile'
          END IF
          IF (INFO.EQ.15) THEN
              WRITE (*,FMT=*) ' number of reps exceeds REPSUP, '
              WRITE (*,FMT=*) ' increase constant REPSUP and recompile'
          END IF

      END IF
!                                       
!
      IF ((WHATDO.EQ.TRMATE) .OR. (WHATDO.EQ.ERROR)) THEN
          GO TO 20
      ELSE
          GO TO 10
      END IF
   20 CONTINUE
!
!
 9000 FORMAT (' takeshot at',I6)
 9010 FORMAT (' advance to',I7)
 9020 FORMAT (' firsturn at',I6)
 9030 FORMAT (' youturn at',I7)
 9040 FORMAT (' restore at',I7)
!                                                                                                                                                  
!                                                                                                                                                  
!       End of the revolve algorithm ..      
!
    CALL COMPUTE_NORMALS_B()
    call update_begin_xb_ghost()
    call update_end_xb_ghost()
    call update_begin_yb_ghost()
    call update_end_yb_ghost()

!    
  END SUBROUTINE Q_LSKUM_CHKPTS_B
!
  SUBROUTINE Q_LSKUM()
    IMPLICIT NONE
!
!							
!		
    INTEGER :: t, i
!
    CALL COMPUTE_NORMALS()
    CALL GENERATE_CONNECTIVITY()
!
!			
    DO t=1,max_iters
      CALL FPI_SOLVER(t)
    END DO
  END SUBROUTINE Q_LSKUM

  subroutine set_obj()
        implicit none

        if(obj_flag == 0) then
                SETERRA(PETSC_COMM_WORLD,1,'Choose an objective function')
        elseif(obj_flag == 1) then
                clb = 1.0
                if(rank == 0) then
                        write(*,*)'%%%%%%%%%-objective function = Cl-%%%%%%%%%'
                        write(*,*)
                end if
        elseif(obj_flag == 2) then
                cdb = 1.0
                if(rank == 0) then
                        write(*,*)'%%%%%%%%%-objective function = Cd-%%%%%%%%%'
                        write(*,*)
                end if
        elseif(obj_flag == 3) then
                cmb = 1.0
                if(rank == 0) then
                        write(*,*)'%%%%%%%%%-objective function = Cm-%%%%%%%%%'
                        write(*,*)
                end if
        elseif(obj_flag == 4) then
                total_entropyb = 1.0
                if(rank == 0) then
                        write(*,*)'%%%-objective function = total entropy-%%%%'
                        write(*,*)
                end if
        elseif(obj_flag == 5) then
                total_enstrophyb = 1.0
                if(rank == 0) then
                        write(*,*)'%%-objective function = total enstrophy-%%%'
                        write(*,*)
                end if
        elseif(obj_flag == 6) then
                clcdb = 1.0
                if(rank == 0) then
                        write(*,*)'%%%%%%%-objective function = Cl/Cd-%%%%%%%%'
                        write(*,*)
                end if
        else
                SETERRA(PETSC_COMM_WORLD,1,'Invalid objective function, check again')
        end if
  
  end subroutine

END MODULE Q_LSKUM_MOD_CHKPTS_DIFF
