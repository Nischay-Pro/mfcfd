!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
MODULE COMPUTE_FORCE_COEFFS_MOD_DIFF_DIFF
#include <petsc/finclude/petscsys.h>

  USE DATA_STRUCTURE_MOD_DIFF
  USE PETSC_DATA_STRUCTURE_MOD
  IMPLICIT NONE

CONTAINS
!  Differentiation of compute_cl_cd_cm_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: pointd.prim cmd cdd point.x
!                point.y point.nx point.ny point.prim cld
!   with respect to varying inputs: pointd.prim point.x point.y
!                point.nx point.ny point.prim
!  Differentiation of compute_cl_cd_cm in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: clcd cd cl cm
!   with respect to varying inputs: theta point.prim
  SUBROUTINE COMPUTE_CL_CD_CM_D_B()
    IMPLICIT NONE
    INTEGER :: i, j, k
    INTEGER :: l, m, r
    REAL*8 :: cp, temp
    REAL*8 :: cpb
    REAL*8 :: cpd
    REAL*8 :: cpdb
    REAL*8 :: lx, ly, mx, my, rx, ry
    REAL*8 :: lxb, lyb, mxb, myb, rxb, ryb
    REAL*8 :: ds1, ds2, ds
    REAL*8 :: ds1b, ds2b, dsb
    REAL*8, DIMENSION(shapes) :: h, v, pitch_mom
    REAL*8, DIMENSION(shapes) :: hb, vb
    REAL*8, DIMENSION(shapes) :: hd, vd, pitch_momd
    REAL*8, DIMENSION(shapes) :: hdb, vdb, pitch_momdb
    REAL*8 :: nx, ny
    REAL*8 :: nxb, nyb
    INTRINSIC DSQRT
    INTRINSIC DCOS
    INTRINSIC DSIN
    REAL*8 :: tempb
    REAL*8 :: tempb0
    REAL*8 :: tempb1
    REAL*8 :: tempb2
    REAL*8 :: tempb3
    REAL*8 :: tempb4
    REAL*8 :: tempb5
    REAL*8 :: tempb6
    temp = 0.5d0*rho_inf*mach*mach
    DO j=1,shape_points
      m = shape_points_index(j)
      r = point%right(m)
      l = point%left(m)
      lx = point%x(l)
      ly = point%y(l)
      mx = point%x(m)
      my = point%y(m)
      rx = point%x(r)
      ry = point%y(r)
      ds1 = (mx-lx)**2 + (my-ly)**2
      CALL PUSHREAL8(ds1)
      ds1 = DSQRT(ds1)
      ds2 = (rx-mx)**2 + (ry-my)**2
      CALL PUSHREAL8(ds2)
      ds2 = DSQRT(ds2)
      CALL PUSHREAL8(ds)
      ds = 0.5d0*(ds1+ds2)
      CALL PUSHREAL8(cpd)
      cpd = pointd%prim(4, m)
      CALL PUSHREAL8(cp)
      cp = point%prim(4, m) - pr_inf
      cpd = -(cpd/temp)
      cp = -(cp/temp)
    END DO
    pitch_momdb = 0.0_8
    pitch_momdb = cmdb
    hb = 0.0_8
    vb = 0.0_8
    hdb = 0.0_8
    vdb = 0.0_8
    hdb = DCOS(theta)*cddb - DSIN(theta)*cldb
    hb = -(DCOS(theta)*thetad*cldb) - DSIN(theta)*thetad*cddb
    vdb = DCOS(theta)*cldb + DSIN(theta)*cddb
    vb = DCOS(theta)*thetad*cddb - DSIN(theta)*thetad*cldb
    DO j=shape_points,1,-1
      m = shape_points_index(j)
      my = point%y(m)
      nx = point%nx(m)
      ny = point%ny(m)
      mx = point%x(m)
      tempb = my*cpd*pitch_momdb(point%flag_2(m))
      tempb0 = nx*ds*pitch_momdb(point%flag_2(m))
      tempb1 = -((mx-0.25d0)*cpd*pitch_momdb(point%flag_2(m)))
      tempb2 = -(ny*ds*pitch_momdb(point%flag_2(m)))
      nxb = ds*cp*hb(point%flag_2(m)) + cpd*ds*hdb(point%flag_2(m)) + ds&
&       *tempb
      dsb = cp*ny*vb(point%flag_2(m)) + cp*nx*hb(point%flag_2(m)) + cpd*&
&       nx*hdb(point%flag_2(m)) + cpd*ny*vdb(point%flag_2(m)) + ny*&
&       tempb1 + nx*tempb
      myb = cpd*tempb0
      cpdb = ny*ds*vdb(point%flag_2(m)) + nx*ds*hdb(point%flag_2(m)) + (&
&       mx-0.25d0)*tempb2 + my*tempb0
      nyb = ds*cp*vb(point%flag_2(m)) + cpd*ds*vdb(point%flag_2(m)) + ds&
&       *tempb1
      mxb = cpd*tempb2
      cpb = ds*nx*hb(point%flag_2(m)) + ds*ny*vb(point%flag_2(m))
      cpb = -(cpb/temp)
      cpdb = -(cpdb/temp)
      CALL POPREAL8(cp)
      pointb%prim(4, m) = pointb%prim(4, m) + cpb
      CALL POPREAL8(cpd)
      pointdb%prim(4, m) = pointdb%prim(4, m) + cpdb
      pointb%ny(m) = pointb%ny(m) + nyb
      pointb%nx(m) = pointb%nx(m) + nxb
      CALL POPREAL8(ds)
      ds1b = 0.5d0*dsb
      ds2b = 0.5d0*dsb
      r = point%right(m)
      rx = point%x(r)
      ry = point%y(r)
      CALL POPREAL8(ds2)
      IF (ds2 .EQ. 0.0) THEN
        ds2b = 0.0
      ELSE
        ds2b = ds2b/(2.D0*DSQRT(ds2))
      END IF
      tempb3 = 2*(rx-mx)*ds2b
      tempb4 = 2*(ry-my)*ds2b
      rxb = tempb3
      ryb = tempb4
      l = point%left(m)
      lx = point%x(l)
      ly = point%y(l)
      CALL POPREAL8(ds1)
      IF (ds1 .EQ. 0.0) THEN
        ds1b = 0.0
      ELSE
        ds1b = ds1b/(2.D0*DSQRT(ds1))
      END IF
      tempb5 = 2*(mx-lx)*ds1b
      mxb = mxb + tempb5 - tempb3
      tempb6 = 2*(my-ly)*ds1b
      myb = myb + tempb6 - tempb4
      lxb = -tempb5
      lyb = -tempb6
      pointb%y(r) = pointb%y(r) + ryb
      pointb%x(r) = pointb%x(r) + rxb
      pointb%y(m) = pointb%y(m) + myb
      pointb%x(m) = pointb%x(m) + mxb
      pointb%y(l) = pointb%y(l) + lyb
      pointb%x(l) = pointb%x(l) + lxb
    END DO
  END SUBROUTINE COMPUTE_CL_CD_CM_D_B

!  Differentiation of compute_cl_cd_cm in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: clcd cd cl cm
!   with respect to varying inputs: theta point.prim
  SUBROUTINE COMPUTE_CL_CD_CM_D()
    IMPLICIT NONE
    INTEGER :: i, j, k
    INTEGER :: l, m, r
    REAL*8 :: cp, temp
    REAL*8 :: cpd
    REAL*8 :: lx, ly, mx, my, rx, ry
    REAL*8 :: ds1, ds2, ds
    REAL*8, DIMENSION(shapes) :: h, v, pitch_mom
    REAL*8, DIMENSION(shapes) :: hd, vd, pitch_momd
    real*8, dimension(shapes) :: lcl, lcd, lcm
    real*8, dimension(shapes) :: lcld, lcdd, lcmd
    REAL*8 :: nx, ny
    INTRINSIC DSQRT
    INTRINSIC DCOS
    INTRINSIC DSIN
    PetscErrorCode :: ierr
    temp = 0.5d0*rho_inf*mach*mach
    h = 0.d0
    v = 0.d0
    pitch_mom = 0.0d0
    hd = 0.0_8
    vd = 0.0_8
    pitch_momd = 0.0_8
    DO j=1,shape_points
      m = shape_points_index(j)
      r = point%right(m)
      l = point%left(m)
      lx = point%x(l)
      ly = point%y(l)
      mx = point%x(m)
      my = point%y(m)
      rx = point%x(r)
      ry = point%y(r)
      ds1 = (mx-lx)**2 + (my-ly)**2
      ds1 = DSQRT(ds1)
      ds2 = (rx-mx)**2 + (ry-my)**2
      ds2 = DSQRT(ds2)
      ds = 0.5d0*(ds1+ds2)
      nx = point%nx(m)
      ny = point%ny(m)
      cpd = pointd%prim(4, m)
      cp = point%prim(4, m) - pr_inf
      cpd = -(cpd/temp)
      cp = -(cp/temp)
      hd(point%flag_2(m)) = hd(point%flag_2(m)) + nx*ds*cpd
      h(point%flag_2(m)) = h(point%flag_2(m)) + cp*nx*ds
      vd(point%flag_2(m)) = vd(point%flag_2(m)) + ny*ds*cpd
      v(point%flag_2(m)) = v(point%flag_2(m)) + cp*ny*ds
      pitch_momd(point%flag_2(m)) = pitch_momd(point%flag_2(m)) + nx*ds*&
&       my*cpd - ny*ds*(mx-0.25d0)*cpd
      pitch_mom(point%flag_2(m)) = pitch_mom(point%flag_2(m)) + (-(cp*ny&
&       *ds*(mx-0.25d0))+cp*nx*ds*my)
    END DO
    lcld = vd*DCOS(theta) - v*thetad*DSIN(theta) - hd*DSIN(theta) - h*&
&     thetad*DCOS(theta)
    lcl = v*DCOS(theta) - h*DSIN(theta)
    lcdd = hd*DCOS(theta) - h*thetad*DSIN(theta) + vd*DSIN(theta) + v*&
&     thetad*DCOS(theta)
    lcd = h*DCOS(theta) + v*DSIN(theta)
    clcdd = (cld*cd-cl*cdd)/cd**2
    clcd = cl/cd
    lcmd = pitch_momd
    lcm = pitch_mom

    call MPI_Reduce(lcl, cl , shapes, MPI_DOUBLE, MPI_SUM, 0, &
            & PETSC_COMM_WORLD, ierr)
    call MPI_Reduce(lcld, cld , shapes, MPI_DOUBLE, MPI_SUM, 0, &
            & PETSC_COMM_WORLD, ierr)
    call MPI_Reduce(lcd, cd , shapes, MPI_DOUBLE, MPI_SUM, 0, &
            & PETSC_COMM_WORLD, ierr)
    call MPI_Reduce(lcdd, cdd , shapes, MPI_DOUBLE, MPI_SUM, 0, &
            & PETSC_COMM_WORLD, ierr)
    call MPI_Reduce(lcm, cm , shapes, MPI_DOUBLE, MPI_SUM, 0, &
            & PETSC_COMM_WORLD, ierr)
    call MPI_Reduce(lcmd, cmd , shapes, MPI_DOUBLE, MPI_SUM, 0, &
            & PETSC_COMM_WORLD, ierr)

  END SUBROUTINE COMPUTE_CL_CD_CM_D

  SUBROUTINE COMPUTE_CL_CD_CM()
    IMPLICIT NONE
    INTEGER :: i, j, k
    INTEGER :: l, m, r
    REAL*8 :: cp, temp
    REAL*8 :: lx, ly, mx, my, rx, ry
    REAL*8 :: ds1, ds2, ds
    REAL*8, DIMENSION(shapes) :: h, v, pitch_mom
    REAL*8 :: nx, ny
    INTRINSIC DSQRT
    INTRINSIC DCOS
    INTRINSIC DSIN
    temp = 0.5d0*rho_inf*mach*mach
    h = 0.d0
    v = 0.d0
    pitch_mom = 0.0d0
    DO j=1,shape_points
      m = shape_points_index(j)
      r = point%right(m)
      l = point%left(m)
      lx = point%x(l)
      ly = point%y(l)
      mx = point%x(m)
      my = point%y(m)
      rx = point%x(r)
      ry = point%y(r)
      ds1 = (mx-lx)**2 + (my-ly)**2
      ds1 = DSQRT(ds1)
      ds2 = (rx-mx)**2 + (ry-my)**2
      ds2 = DSQRT(ds2)
      ds = 0.5d0*(ds1+ds2)
      nx = point%nx(m)
      ny = point%ny(m)
      cp = point%prim(4, m) - pr_inf
      cp = -(cp/temp)
      h(point%flag_2(m)) = h(point%flag_2(m)) + cp*nx*ds
      v(point%flag_2(m)) = v(point%flag_2(m)) + cp*ny*ds
      pitch_mom(point%flag_2(m)) = pitch_mom(point%flag_2(m)) + (-(cp*ny&
&       *ds*(mx-0.25d0))+cp*nx*ds*my)
    END DO
    cl = v*DCOS(theta) - h*DSIN(theta)
    cd = h*DCOS(theta) + v*DSIN(theta)
    clcd = cl/cd
    cm = pitch_mom
  END SUBROUTINE COMPUTE_CL_CD_CM

END MODULE COMPUTE_FORCE_COEFFS_MOD_DIFF_DIFF

