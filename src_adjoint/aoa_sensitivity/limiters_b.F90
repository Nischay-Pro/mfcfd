!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
MODULE LIMITERS_MOD_DIFF_DIFF
  USE DATA_STRUCTURE_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of max_q_value_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: pointd.q point.q maxi maxid
!   with respect to varying inputs: pointd.q point.q
!  Differentiation of max_q_value in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: maxi
!   with respect to varying inputs: point.q
!	The following two subroutines are used for min-max limiter ..
  SUBROUTINE MAX_Q_VALUE_D_B(i, maxi, maxib, maxid, maxidb)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: maxi(4)
    REAL*8 :: maxib(4)
    REAL*8 :: maxid(4)
    REAL*8 :: maxidb(4)
    INTEGER :: branch
    maxi = point%q(:, i)
    DO j=1,point%nbhs(i)
      CALL PUSHINTEGER4(k)
      k = point%conn(i, j)
      DO r=1,4
        IF (maxi(r) .LT. point%q(r, k)) THEN
          maxi(r) = point%q(r, k)
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
    END DO
    DO j=point%nbhs(i),1,-1
      DO r=4,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          pointb%q(r, k) = pointb%q(r, k) + maxib(r)
          maxib(r) = 0.0_8
          pointdb%q(r, k) = pointdb%q(r, k) + maxidb(r)
          maxidb(r) = 0.0_8
        END IF
      END DO
      CALL POPINTEGER4(k)
    END DO
    pointb%q(:, i) = pointb%q(:, i) + maxib
    pointdb%q(:, i) = pointdb%q(:, i) + maxidb
  END SUBROUTINE MAX_Q_VALUE_D_B

!  Differentiation of max_q_value in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: maxi
!   with respect to varying inputs: point.q
!	The following two subroutines are used for min-max limiter ..
  SUBROUTINE MAX_Q_VALUE_D(i, maxi, maxid)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: maxi(4)
    REAL*8 :: maxid(4)
    maxid = pointd%q(:, i)
    maxi = point%q(:, i)
    DO j=1,point%nbhs(i)
      k = point%conn(i, j)
      DO r=1,4
        IF (maxi(r) .LT. point%q(r, k)) THEN
          maxid(r) = pointd%q(r, k)
          maxi(r) = point%q(r, k)
        END IF
      END DO
    END DO
  END SUBROUTINE MAX_Q_VALUE_D

!	The following two subroutines are used for min-max limiter ..
  SUBROUTINE MAX_Q_VALUE(i, maxi)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: maxi(4)
    maxi = point%q(:, i)
    DO j=1,point%nbhs(i)
      k = point%conn(i, j)
      DO r=1,4
        IF (maxi(r) .LT. point%q(r, k)) maxi(r) = point%q(r, k)
      END DO
    END DO
  END SUBROUTINE MAX_Q_VALUE

!  Differentiation of min_q_value_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: pointd.q point.q minid mini
!   with respect to varying inputs: pointd.q point.q
!  Differentiation of min_q_value in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: mini
!   with respect to varying inputs: point.q
  SUBROUTINE MIN_Q_VALUE_D_B(i, mini, minib, minid, minidb)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: mini(4)
    REAL*8 :: minib(4)
    REAL*8 :: minid(4)
    REAL*8 :: minidb(4)
    INTEGER :: branch
    mini = point%q(:, i)
    DO j=1,point%nbhs(i)
      CALL PUSHINTEGER4(k)
      k = point%conn(i, j)
      DO r=1,4
        IF (mini(r) .GT. point%q(r, k)) THEN
          mini(r) = point%q(r, k)
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
    END DO
    DO j=point%nbhs(i),1,-1
      DO r=4,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          pointb%q(r, k) = pointb%q(r, k) + minib(r)
          minib(r) = 0.0_8
          pointdb%q(r, k) = pointdb%q(r, k) + minidb(r)
          minidb(r) = 0.0_8
        END IF
      END DO
      CALL POPINTEGER4(k)
    END DO
    pointb%q(:, i) = pointb%q(:, i) + minib
    pointdb%q(:, i) = pointdb%q(:, i) + minidb
  END SUBROUTINE MIN_Q_VALUE_D_B

!  Differentiation of min_q_value in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: mini
!   with respect to varying inputs: point.q
  SUBROUTINE MIN_Q_VALUE_D(i, mini, minid)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: mini(4)
    REAL*8 :: minid(4)
    minid = pointd%q(:, i)
    mini = point%q(:, i)
    DO j=1,point%nbhs(i)
      k = point%conn(i, j)
      DO r=1,4
        IF (mini(r) .GT. point%q(r, k)) THEN
          minid(r) = pointd%q(r, k)
          mini(r) = point%q(r, k)
        END IF
      END DO
    END DO
  END SUBROUTINE MIN_Q_VALUE_D

  SUBROUTINE MIN_Q_VALUE(i, mini)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: mini(4)
    mini = point%q(:, i)
    DO j=1,point%nbhs(i)
      k = point%conn(i, j)
      DO r=1,4
        IF (mini(r) .GT. point%q(r, k)) mini(r) = point%q(r, k)
      END DO
    END DO
  END SUBROUTINE MIN_Q_VALUE

!  Differentiation of venkat_limiter_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: pointd.q pointd.qm point.q
!                point.qm phi phid
!   with respect to varying inputs: pointd.q pointd.qm point.q
!                point.qm qtilded qtilde phi phid
!  Differentiation of venkat_limiter in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: phi
!   with respect to varying inputs: point.q point.qm qtilde phi
!	The following subroutines are used for venkatakrishnan limiter .. 	
  SUBROUTINE VENKAT_LIMITER_D_B(qtilde, qtildeb, qtilded, qtildedb, phi&
&   , phib, phid, phidb, k)
    IMPLICIT NONE
    INTEGER :: r, k
    REAL*8 :: qtilde(4), phi(4)
    REAL*8 :: qtildeb(4), phib(4)
    REAL*8 :: qtilded(4), phid(4)
    REAL*8 :: qtildedb(4), phidb(4)
    REAL*8 :: q, del_neg, del_pos
    REAL*8 :: qb, del_negb, del_posb
    REAL*8 :: qd, del_negd, del_posd
    REAL*8 :: qdb, del_negdb, del_posdb
    REAL*8 :: max_q, min_q, ds, epsi, num, den, temp
    REAL*8 :: numb, denb, tempb
    REAL*8 :: numd, dend, tempd
    REAL*8 :: numdb, dendb, tempdb
    INTRINSIC DABS
    DOUBLE PRECISION :: dabs0
    DOUBLE PRECISION :: dabs1
    REAL*8 :: tempb0
    REAL*8 :: tempb1
    REAL*8 :: tempb2
    REAL*8 :: tempb3
    INTEGER :: branch
    del_posd = 0.0_8
    DO r=1,4
      qd = pointd%q(r, k)
      q = point%q(r, k)
      del_negd = qtilded(r) - qd
      del_neg = qtilde(r) - q
      IF (del_neg .GE. 0.) THEN
        dabs0 = del_neg
      ELSE
        dabs0 = -del_neg
      END IF
      IF (dabs0 .LE. 10e-6) THEN
        CALL PUSHCONTROL2B(3)
      ELSE
        IF (del_neg .GE. 0.) THEN
          dabs1 = del_neg
        ELSE
          dabs1 = -del_neg
        END IF
        IF (dabs1 .GT. 10e-6) THEN
          IF (del_neg .GT. 0.d0) THEN
            CALL PUSHREAL8(del_posd)
            del_posd = pointd%qm(1, r, k) - qd
            CALL PUSHREAL8(del_pos)
            del_pos = point%qm(1, r, k) - q
            CALL PUSHCONTROL2B(0)
          ELSE IF (del_neg .LT. 0.d0) THEN
            CALL PUSHREAL8(del_posd)
            del_posd = pointd%qm(2, r, k) - qd
            CALL PUSHREAL8(del_pos)
            del_pos = point%qm(2, r, k) - q
            CALL PUSHCONTROL2B(1)
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
          epsi = vl_const*point%min_dist(k)
          epsi = epsi**3.0d0
! Numerator .. 
          CALL PUSHREAL8(numd)
          numd = del_posd*del_pos + del_pos*del_posd
          CALL PUSHREAL8(num)
          num = del_pos*del_pos + epsi*epsi
          CALL PUSHREAL8(numd)
          numd = numd*del_neg + num*del_negd + 2.0d0*((del_negd*del_neg+&
&           del_neg*del_negd)*del_pos+del_neg**2*del_posd)
          CALL PUSHREAL8(num)
          num = num*del_neg + 2.0d0*del_neg*del_neg*del_pos
! Denominator ..
          CALL PUSHREAL8(dend)
          dend = del_posd*del_pos + del_pos*del_posd + 2.0d0*(del_negd*&
&           del_neg+del_neg*del_negd)
          CALL PUSHREAL8(den)
          den = del_pos*del_pos + 2.0d0*del_neg*del_neg
          dend = dend + del_negd*del_pos + del_neg*del_posd
          den = den + del_neg*del_pos + epsi*epsi
          CALL PUSHREAL8(dend)
          dend = dend*del_neg + den*del_negd
          CALL PUSHREAL8(den)
          den = den*del_neg
          temp = num/den
          IF (temp .LT. 1.d0) THEN
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END IF
    END DO
    qtildedb = 0.0_8
    qtildeb = 0.0_8
    del_posb = 0.0_8
    del_posdb = 0.0_8
    DO r=4,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          qdb = 0.0_8
          qb = 0.0_8
          del_negb = 0.0_8
          del_negdb = 0.0_8
          GOTO 100
        ELSE
          phib(r) = 0.0_8
          phidb(r) = 0.0_8
          tempb = 0.0_8
          tempdb = 0.0_8
        END IF
      ELSE IF (branch .EQ. 2) THEN
        tempb = phib(r)
        phib(r) = 0.0_8
        tempdb = phidb(r)
        phidb(r) = 0.0_8
      ELSE
        phib(r) = 0.0_8
        phidb(r) = 0.0_8
        qdb = 0.0_8
        qb = 0.0_8
        del_negb = 0.0_8
        del_negdb = 0.0_8
        GOTO 100
      END IF
      tempb0 = tempdb/den**2
      numb = tempb/den - dend*tempb0
      denb = (numd-(numd*den-num*dend)*2/den)*tempb0 - num*tempb/den**2
      numdb = den*tempb0
      dendb = -(num*tempb0)
      q = point%q(r, k)
      del_neg = qtilde(r) - q
      CALL POPREAL8(den)
      qd = pointd%q(r, k)
      del_negd = qtilded(r) - qd
      CALL POPREAL8(dend)
      del_negb = dend*dendb + den*denb
      denb = del_negd*dendb + del_neg*denb
      del_negdb = den*dendb
      dendb = del_neg*dendb
      del_posb = del_posb + (2*del_posd+del_negd)*dendb + 2.0d0*del_neg&
&       **2*numb + (2*del_pos+del_neg)*denb
      CALL POPREAL8(den)
      CALL POPREAL8(dend)
      tempb1 = 2.0d0*dendb
      CALL POPREAL8(num)
      CALL POPREAL8(numd)
      tempb3 = 2.0d0*numdb
      tempb2 = del_pos*tempb3
      del_negb = del_negb + del_posd*dendb + 2*del_negd*tempb1 + numd*&
&       numdb + 2*del_negd*tempb2 + del_posd*2*del_neg*tempb3 + (del_pos&
&       *2.0d0*2*del_neg+num)*numb + (2.0d0*2*del_neg+del_pos)*denb
      del_negdb = del_negdb + 2*del_neg*tempb1 + 2*del_neg*tempb2 + num*&
&       numdb + del_pos*dendb
      numb = del_negd*numdb + del_neg*numb
      numdb = del_neg*numdb
      del_posdb = del_posdb + 2*del_pos*numdb + del_neg**2*tempb3 + (2*&
&       del_pos+del_neg)*dendb
      del_posb = del_posb + 2*del_pos*numb + 2*del_posd*numdb + (&
&       del_negd*del_neg+del_neg*del_negd)*tempb3
      CALL POPREAL8(num)
      CALL POPREAL8(numd)
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(del_pos)
        pointb%qm(1, r, k) = pointb%qm(1, r, k) + del_posb
        qb = -del_posb
        CALL POPREAL8(del_posd)
        pointdb%qm(1, r, k) = pointdb%qm(1, r, k) + del_posdb
        qdb = -del_posdb
        del_posb = 0.0_8
        del_posdb = 0.0_8
      ELSE IF (branch .EQ. 1) THEN
        CALL POPREAL8(del_pos)
        pointb%qm(2, r, k) = pointb%qm(2, r, k) + del_posb
        qb = -del_posb
        CALL POPREAL8(del_posd)
        pointdb%qm(2, r, k) = pointdb%qm(2, r, k) + del_posdb
        qdb = -del_posdb
        del_posb = 0.0_8
        del_posdb = 0.0_8
      ELSE
        qdb = 0.0_8
        qb = 0.0_8
      END IF
 100  qtildeb(r) = qtildeb(r) + del_negb
      qb = qb - del_negb
      qtildedb(r) = qtildedb(r) + del_negdb
      qdb = qdb - del_negdb
      pointb%q(r, k) = pointb%q(r, k) + qb
      pointdb%q(r, k) = pointdb%q(r, k) + qdb
    END DO
  END SUBROUTINE VENKAT_LIMITER_D_B

!  Differentiation of venkat_limiter in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: phi
!   with respect to varying inputs: point.q point.qm qtilde phi
!	The following subroutines are used for venkatakrishnan limiter .. 	
  SUBROUTINE VENKAT_LIMITER_D(qtilde, qtilded, phi, phid, k)
    IMPLICIT NONE
    INTEGER :: r, k
    REAL*8 :: qtilde(4), phi(4)
    REAL*8 :: qtilded(4), phid(4)
    REAL*8 :: q, del_neg, del_pos
    REAL*8 :: qd, del_negd, del_posd
    REAL*8 :: max_q, min_q, ds, epsi, num, den, temp
    REAL*8 :: numd, dend, tempd
    INTRINSIC DABS
    DOUBLE PRECISION :: dabs0
    DOUBLE PRECISION :: dabs1
    del_posd = 0.0_8
    DO r=1,4
      qd = pointd%q(r, k)
      q = point%q(r, k)
      del_negd = qtilded(r) - qd
      del_neg = qtilde(r) - q
      IF (del_neg .GE. 0.) THEN
        dabs0 = del_neg
      ELSE
        dabs0 = -del_neg
      END IF
      IF (dabs0 .LE. 10e-6) THEN
        phid(r) = 0.0_8
        phi(r) = 1.d0
      ELSE
        IF (del_neg .GE. 0.) THEN
          dabs1 = del_neg
        ELSE
          dabs1 = -del_neg
        END IF
        IF (dabs1 .GT. 10e-6) THEN
          IF (del_neg .GT. 0.d0) THEN
            del_posd = pointd%qm(1, r, k) - qd
            del_pos = point%qm(1, r, k) - q
          ELSE IF (del_neg .LT. 0.d0) THEN
            del_posd = pointd%qm(2, r, k) - qd
            del_pos = point%qm(2, r, k) - q
          END IF
          epsi = vl_const*point%min_dist(k)
          epsi = epsi**3.0d0
! Numerator .. 
          numd = del_posd*del_pos + del_pos*del_posd
          num = del_pos*del_pos + epsi*epsi
          numd = numd*del_neg + num*del_negd + 2.0d0*((del_negd*del_neg+&
&           del_neg*del_negd)*del_pos+del_neg**2*del_posd)
          num = num*del_neg + 2.0d0*del_neg*del_neg*del_pos
! Denominator ..
          dend = del_posd*del_pos + del_pos*del_posd + 2.0d0*(del_negd*&
&           del_neg+del_neg*del_negd)
          den = del_pos*del_pos + 2.0d0*del_neg*del_neg
          dend = dend + del_negd*del_pos + del_neg*del_posd
          den = den + del_neg*del_pos + epsi*epsi
          dend = dend*del_neg + den*del_negd
          den = den*del_neg
          tempd = (numd*den-num*dend)/den**2
          temp = num/den
          IF (temp .LT. 1.d0) THEN
            phid(r) = tempd
            phi(r) = temp
          ELSE
            phid(r) = 0.0_8
            phi(r) = 1.d0
          END IF
        END IF
      END IF
    END DO
  END SUBROUTINE VENKAT_LIMITER_D

!	The following subroutines are used for venkatakrishnan limiter .. 	
  SUBROUTINE VENKAT_LIMITER(qtilde, phi, k)
    IMPLICIT NONE
    INTEGER :: r, k
    REAL*8 :: qtilde(4), phi(4)
    REAL*8 :: q, del_neg, del_pos
    REAL*8 :: max_q, min_q, ds, epsi, num, den, temp
    INTRINSIC DABS
    DOUBLE PRECISION :: dabs0
    DOUBLE PRECISION :: dabs1
    DO r=1,4
      q = point%q(r, k)
      del_neg = qtilde(r) - q
      IF (del_neg .GE. 0.) THEN
        dabs0 = del_neg
      ELSE
        dabs0 = -del_neg
      END IF
      IF (dabs0 .LE. 10e-6) THEN
        phi(r) = 1.d0
      ELSE
        IF (del_neg .GE. 0.) THEN
          dabs1 = del_neg
        ELSE
          dabs1 = -del_neg
        END IF
        IF (dabs1 .GT. 10e-6) THEN
          IF (del_neg .GT. 0.d0) THEN
            del_pos = point%qm(1, r, k) - q
          ELSE IF (del_neg .LT. 0.d0) THEN
            del_pos = point%qm(2, r, k) - q
          END IF
          epsi = vl_const*point%min_dist(k)
          epsi = epsi**3.0d0
! Numerator .. 
          num = del_pos*del_pos + epsi*epsi
          num = num*del_neg + 2.0d0*del_neg*del_neg*del_pos
! Denominator ..
          den = del_pos*del_pos + 2.0d0*del_neg*del_neg
          den = den + del_neg*del_pos + epsi*epsi
          den = den*del_neg
          temp = num/den
          IF (temp .LT. 1.d0) THEN
            phi(r) = temp
          ELSE
            phi(r) = 1.d0
          END IF
        END IF
      END IF
    END DO
  END SUBROUTINE VENKAT_LIMITER

END MODULE LIMITERS_MOD_DIFF_DIFF

