!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
MODULE Q_VARIABLES_MOD_DIFF_DIFF
  USE DATA_STRUCTURE_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of eval_q_variables_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: pointd.prim pointd.q point.prim
!                point.q
!   with respect to varying inputs: pointd.prim pointd.q point.prim
!                point.q
!  Differentiation of eval_q_variables in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: point.q
!   with respect to varying inputs: point.prim point.q
  SUBROUTINE EVAL_Q_VARIABLES_D_B()
    IMPLICIT NONE
    INTEGER :: k
    REAL*8 :: rho, u1, u2, pr, beta
    REAL*8 :: rhob, u1b, u2b, prb, betab
    REAL*8 :: rhod, u1d, u2d, prd, betad
    REAL*8 :: rhodb, u1db, u2db, prdb, betadb
    REAL*8 :: two_times_beta
    REAL*8 :: two_times_betab
    REAL*8 :: two_times_betad
    REAL*8 :: two_times_betadb
    INTRINSIC DLOG
    REAL*8 :: tempb
    REAL*8 :: tempb0
    REAL*8 :: tempb1
    REAL*8 :: tempb2
    DO k=max_points,1,-1
      u1d = pointd%prim(2, k)
      u2d = pointd%prim(3, k)
      two_times_betab = -pointb%q(4, k)
      pointb%q(4, k) = 0.0_8
      two_times_betadb = -pointdb%q(4, k)
      pointdb%q(4, k) = 0.0_8
      pr = point%prim(4, k)
      rho = point%prim(1, k)
      beta = 0.5d0*rho/pr
      two_times_beta = 2.0d0*beta
      u2 = point%prim(3, k)
      two_times_betab = two_times_betab + u2d*pointdb%q(3, k) + u2*&
&       pointb%q(3, k)
      rhod = pointd%prim(1, k)
      prd = pointd%prim(4, k)
      betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
      two_times_betad = 2.0d0*betad
      u2b = two_times_betad*pointdb%q(3, k) + two_times_beta*pointb%q(3&
&       , k)
      pointb%q(3, k) = 0.0_8
      two_times_betadb = two_times_betadb + u2*pointdb%q(3, k)
      u2db = two_times_beta*pointdb%q(3, k)
      pointdb%q(3, k) = 0.0_8
      u1 = point%prim(2, k)
      two_times_betab = two_times_betab + u1d*pointdb%q(2, k) + u1*&
&       pointb%q(2, k)
      u1b = two_times_betad*pointdb%q(2, k) + two_times_beta*pointb%q(2&
&       , k)
      pointb%q(2, k) = 0.0_8
      two_times_betadb = two_times_betadb + u1*pointdb%q(2, k)
      u1db = two_times_beta*pointdb%q(2, k)
      pointdb%q(2, k) = 0.0_8
      tempb = 2.5d0*pointdb%q(1, k)/beta
      betab = (2.5d0/beta-u2**2-u1**2)*pointb%q(1, k) - (u1d*u1+u1*u1d+&
&       u2d*u2+u2*u2d)*pointdb%q(1, k) - betad*tempb/beta + 2.0d0*&
&       two_times_betab
      betadb = tempb - (u1**2+u2**2)*pointdb%q(1, k) + 2.0d0*&
&       two_times_betadb
      tempb2 = -(beta*pointdb%q(1, k))
      u1b = u1b + 2*u1d*tempb2 - betad*2*u1*pointdb%q(1, k) - beta*2*u1*&
&       pointb%q(1, k)
      u2b = u2b + 2*u2d*tempb2 - betad*2*u2*pointdb%q(1, k) - beta*2*u2*&
&       pointb%q(1, k)
      u1db = u1db + 2*u1*tempb2
      u2db = u2db + 2*u2*tempb2
      tempb1 = 0.5d0*betab/pr
      tempb0 = betadb/pr**2
      rhob = tempb1 - 0.5d0*prd*tempb0 - rhod*pointdb%q(1, k)/rho**2 + &
&       pointb%q(1, k)/rho
      pointb%q(1, k) = 0.0_8
      rhodb = 0.5d0*pr*tempb0 + pointdb%q(1, k)/rho
      pointdb%q(1, k) = 0.0_8
      prb = (0.5d0*rhod-(0.5d0*(rhod*pr)-0.5d0*(rho*prd))*2/pr)*tempb0 -&
&       rho*tempb1/pr
      prdb = -(0.5d0*rho*tempb0)
      pointb%prim(4, k) = pointb%prim(4, k) + prb
      pointdb%prim(4, k) = pointdb%prim(4, k) + prdb
      pointb%prim(3, k) = pointb%prim(3, k) + u2b
      pointdb%prim(3, k) = pointdb%prim(3, k) + u2db
      pointb%prim(2, k) = pointb%prim(2, k) + u1b
      pointdb%prim(2, k) = pointdb%prim(2, k) + u1db
      pointb%prim(1, k) = pointb%prim(1, k) + rhob
      pointdb%prim(1, k) = pointdb%prim(1, k) + rhodb
    END DO
  END SUBROUTINE EVAL_Q_VARIABLES_D_B

!  Differentiation of eval_q_variables in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: point.q
!   with respect to varying inputs: point.prim point.q
  SUBROUTINE EVAL_Q_VARIABLES_D()
    IMPLICIT NONE
    INTEGER :: k
    REAL*8 :: rho, u1, u2, pr, beta
    REAL*8 :: rhod, u1d, u2d, prd, betad
    REAL*8 :: two_times_beta
    REAL*8 :: two_times_betad
    INTRINSIC DLOG
!
    DO k=1,max_points
      rhod = pointd%prim(1, k)
      rho = point%prim(1, k)
      u1d = pointd%prim(2, k)
      u1 = point%prim(2, k)
      u2d = pointd%prim(3, k)
      u2 = point%prim(3, k)
      prd = pointd%prim(4, k)
      pr = point%prim(4, k)
      betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
      beta = 0.5d0*rho/pr
      pointd%q(1, k) = rhod/rho + 2.5d0*betad/beta - betad*(u1*u1+u2*u2)&
&       - beta*(u1d*u1+u1*u1d+u2d*u2+u2*u2d)
      point%q(1, k) = DLOG(rho) + DLOG(beta)*2.5d0 - beta*(u1*u1+u2*u2)
      two_times_betad = 2.0d0*betad
      two_times_beta = 2.0d0*beta
      pointd%q(2, k) = two_times_betad*u1 + two_times_beta*u1d
      point%q(2, k) = two_times_beta*u1
      pointd%q(3, k) = two_times_betad*u2 + two_times_beta*u2d
      point%q(3, k) = two_times_beta*u2
      pointd%q(4, k) = -two_times_betad
      point%q(4, k) = -two_times_beta
    END DO
  END SUBROUTINE EVAL_Q_VARIABLES_D

  SUBROUTINE EVAL_Q_VARIABLES()
    IMPLICIT NONE
    INTEGER :: k
    REAL*8 :: rho, u1, u2, pr, beta
    REAL*8 :: two_times_beta
    INTRINSIC DLOG
!
    DO k=1,max_points
      rho = point%prim(1, k)
      u1 = point%prim(2, k)
      u2 = point%prim(3, k)
      pr = point%prim(4, k)
      beta = 0.5d0*rho/pr
      point%q(1, k) = DLOG(rho) + DLOG(beta)*2.5d0 - beta*(u1*u1+u2*u2)
      two_times_beta = 2.0d0*beta
      point%q(2, k) = two_times_beta*u1
      point%q(3, k) = two_times_beta*u2
      point%q(4, k) = -two_times_beta
    END DO
  END SUBROUTINE EVAL_Q_VARIABLES

!  Differentiation of eval_q_derivatives_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: pointd.q pointd.dq pointd.qm
!                point.x point.y point.q point.dq point.qm
!   with respect to varying inputs: pointd.q pointd.dq pointd.qm
!                point.x point.y point.q point.dq point.qm
!  Differentiation of eval_q_derivatives in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: point.dq point.qm
!   with respect to varying inputs: point.q point.dq point.qm
  SUBROUTINE EVAL_Q_DERIVATIVES_D_B()
    IMPLICIT NONE
    INTEGER :: i, k, r, nbh
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: delx, dely, dist, weights
    REAL*8 :: delxb, delyb, distb, weightsb
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delq(4), sum_dely_delq(4)
    REAL*8 :: sum_delx_delqb(4), sum_dely_delqb(4)
    REAL*8 :: sum_delx_delqd(4), sum_dely_delqd(4)
    REAL*8 :: sum_delx_delqdb(4), sum_dely_delqdb(4)
    REAL*8 :: det, delq, temp
    REAL*8 :: detb
    REAL*8 :: one_by_det
    REAL*8 :: one_by_detb
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    REAL*8 :: tempb1
    REAL*8 :: tempb2
    REAL*8 :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    REAL*8, DIMENSION(4) :: tempb5
    REAL*8, DIMENSION(4) :: tempb6
    REAL*8, DIMENSION(4) :: tempb7
    REAL*8, DIMENSION(4) :: tempb8
    REAL*8, DIMENSION(4) :: tempb9
    REAL*8, DIMENSION(4) :: tempb10
    INTEGER :: branch
    INTEGER :: ad_to
    DO i=1,local_points
      x_i = point%x(i)
      y_i = point%y(i)
      CALL PUSHREAL8(sum_delx_sqr)
      sum_delx_sqr = 0.d0
      CALL PUSHREAL8(sum_dely_sqr)
      sum_dely_sqr = 0.d0
      CALL PUSHREAL8(sum_delx_dely)
      sum_delx_dely = 0.d0
      CALL PUSHREAL8ARRAY(sum_delx_delq, 4)
      sum_delx_delq = 0.d0
      CALL PUSHREAL8ARRAY(sum_dely_delq, 4)
      sum_dely_delq = 0.d0
      CALL PUSHREAL8ARRAY(point%qm(1, :, i), 4)
      point%qm(1, :, i) = point%q(:, i)
      CALL PUSHREAL8ARRAY(point%qm(2, :, i), 4)
      point%qm(2, :, i) = point%q(:, i)
      CALL PUSHREAL8ARRAY(sum_delx_delqd, 4)
      sum_delx_delqd = 0.0_8
      CALL PUSHREAL8ARRAY(sum_dely_delqd, 4)
      sum_dely_delqd = 0.0_8
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        DO r=1,4
          IF (point%q(r, nbh) .GT. point%qm(1, r, i)) THEN
            CALL PUSHREAL8(point%qm(1, r, i))
            point%qm(1, r, i) = point%q(r, nbh)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (point%q(r, nbh) .LT. point%qm(2, r, i)) THEN
            CALL PUSHREAL8(point%qm(2, r, i))
            point%qm(2, r, i) = point%q(r, nbh)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        x_k = point%x(nbh)
        y_k = point%y(nbh)
        delx = x_k - x_i
        dely = y_k - y_i
        arg1 = delx*delx + dely*dely
        CALL PUSHREAL8(dist)
        dist = DSQRT(arg1)
        weights = dist**power
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        sum_delx_delqd = sum_delx_delqd + weights*delx*(pointd%q(:, nbh)&
&         -pointd%q(:, i))
        sum_delx_delq = sum_delx_delq + weights*delx*(point%q(:, nbh)-&
&         point%q(:, i))
        sum_dely_delqd = sum_dely_delqd + weights*dely*(pointd%q(:, nbh)&
&         -pointd%q(:, i))
        sum_dely_delq = sum_dely_delq + weights*dely*(point%q(:, nbh)-&
&         point%q(:, i))
      END DO
      CALL PUSHINTEGER4(k - 1)
    END DO
    DO i=local_points,1,-1
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      one_by_det = 1.0d0/det
      sum_delx_delqb = 0.0_8
      sum_dely_delqb = 0.0_8
      tempb7 = one_by_det*pointb%dq(2, :, i)
      one_by_detb = SUM((sum_delx_sqr*sum_dely_delqd-sum_delx_dely*&
&       sum_delx_delqd)*pointdb%dq(2, :, i)) + SUM((sum_dely_delq*&
&       sum_delx_sqr-sum_delx_delq*sum_delx_dely)*pointb%dq(2, :, i))
      pointb%dq(2, :, i) = 0.0_8
      sum_dely_delqdb = 0.0_8
      sum_delx_delqdb = 0.0_8
      tempb9 = one_by_det*pointdb%dq(2, :, i)
      pointdb%dq(2, :, i) = 0.0_8
      tempb8 = one_by_det*pointb%dq(1, :, i)
      sum_dely_delqb = sum_delx_sqr*tempb7 - sum_delx_dely*tempb8
      sum_delx_delqb = sum_dely_sqr*tempb8 - sum_delx_dely*tempb7
      one_by_detb = one_by_detb + SUM((sum_dely_sqr*sum_delx_delqd-&
&       sum_delx_dely*sum_dely_delqd)*pointdb%dq(1, :, i)) + SUM((&
&       sum_delx_delq*sum_dely_sqr-sum_dely_delq*sum_delx_dely)*pointb%&
&       dq(1, :, i))
      pointb%dq(1, :, i) = 0.0_8
      tempb10 = one_by_det*pointdb%dq(1, :, i)
      sum_dely_delqdb = sum_delx_sqr*tempb9 - sum_delx_dely*tempb10
      sum_delx_delqdb = sum_dely_sqr*tempb10 - sum_delx_dely*tempb9
      pointdb%dq(1, :, i) = 0.0_8
      detb = -(one_by_detb/det**2)
      sum_delx_sqrb = SUM(sum_dely_delqd*tempb9) + sum_dely_sqr*detb + &
&       SUM(sum_dely_delq*tempb7)
      sum_delx_delyb = -SUM(sum_delx_delqd*tempb9) - SUM(sum_dely_delqd*&
&       tempb10) - 2*sum_delx_dely*detb - SUM(sum_dely_delq*tempb8) - &
&       SUM(sum_delx_delq*tempb7)
      sum_dely_sqrb = SUM(sum_delx_delqd*tempb10) + sum_delx_sqr*detb + &
&       SUM(sum_delx_delq*tempb8)
      y_i = point%y(i)
      x_i = point%x(i)
      y_ib = 0.0_8
      x_ib = 0.0_8
      CALL POPINTEGER4(ad_to)
      DO k=ad_to,1,-1
        weights = dist**power
        nbh = point%conn(i, k)
        y_k = point%y(nbh)
        dely = y_k - y_i
        tempb = SUM((point%q(:, nbh)-point%q(:, i))*sum_dely_delqb)
        tempb0 = weights*dely*sum_dely_delqb
        pointb%q(:, nbh) = pointb%q(:, nbh) + tempb0
        pointb%q(:, i) = pointb%q(:, i) - tempb0
        tempb1 = SUM((pointd%q(:, nbh)-pointd%q(:, i))*sum_dely_delqdb)
        tempb4 = weights*dely*sum_dely_delqdb
        pointdb%q(:, nbh) = pointdb%q(:, nbh) + tempb4
        pointdb%q(:, i) = pointdb%q(:, i) - tempb4
        x_k = point%x(nbh)
        delx = x_k - x_i
        tempb3 = SUM((point%q(:, nbh)-point%q(:, i))*sum_delx_delqb)
        tempb5 = weights*delx*sum_delx_delqb
        pointb%q(:, nbh) = pointb%q(:, nbh) + tempb5
        pointb%q(:, i) = pointb%q(:, i) - tempb5
        tempb2 = SUM((pointd%q(:, nbh)-pointd%q(:, i))*sum_delx_delqdb)
        weightsb = dely*tempb1 + delx*tempb2 + dely**2*sum_dely_sqrb + &
&         delx**2*sum_delx_sqrb + delx*dely*sum_delx_delyb + delx*tempb3&
&         + dely*tempb
        tempb6 = weights*delx*sum_delx_delqdb
        pointdb%q(:, nbh) = pointdb%q(:, nbh) + tempb6
        pointdb%q(:, i) = pointdb%q(:, i) - tempb6
        IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(&
&           power))) THEN
          distb = 0.0
        ELSE
          distb = power*dist**(power-1)*weightsb
        END IF
        arg1 = delx*delx + dely*dely
        CALL POPREAL8(dist)
        IF (arg1 .EQ. 0.0) THEN
          arg1b = 0.0
        ELSE
          arg1b = distb/(2.D0*DSQRT(arg1))
        END IF
        delyb = weights*tempb1 + weights*2*dely*sum_dely_sqrb + 2*dely*&
&         arg1b + weights*delx*sum_delx_delyb + weights*tempb
        delxb = weights*tempb2 + weights*2*delx*sum_delx_sqrb + 2*delx*&
&         arg1b + weights*dely*sum_delx_delyb + weights*tempb3
        y_kb = delyb
        y_ib = y_ib - delyb
        x_kb = delxb
        x_ib = x_ib - delxb
        pointb%y(nbh) = pointb%y(nbh) + y_kb
        pointb%x(nbh) = pointb%x(nbh) + x_kb
        DO r=4,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            CALL POPREAL8(point%qm(2, r, i))
            pointb%q(r, nbh) = pointb%q(r, nbh) + pointb%qm(2, r, i)
            pointb%qm(2, r, i) = 0.0_8
            pointdb%q(r, nbh) = pointdb%q(r, nbh) + pointdb%qm(2, r, i)
            pointdb%qm(2, r, i) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(point%qm(1, r, i))
            pointb%q(r, nbh) = pointb%q(r, nbh) + pointb%qm(1, r, i)
            pointb%qm(1, r, i) = 0.0_8
            pointdb%q(r, nbh) = pointdb%q(r, nbh) + pointdb%qm(1, r, i)
            pointdb%qm(1, r, i) = 0.0_8
          END IF
        END DO
      END DO
      CALL POPREAL8ARRAY(sum_dely_delqd, 4)
      CALL POPREAL8ARRAY(sum_delx_delqd, 4)
      CALL POPREAL8ARRAY(point%qm(2, :, i), 4)
      pointb%q(:, i) = pointb%q(:, i) + pointb%qm(2, :, i)
      pointb%qm(2, :, i) = 0.0_8
      pointdb%q(:, i) = pointdb%q(:, i) + pointdb%qm(2, :, i)
      pointdb%qm(2, :, i) = 0.0_8
      CALL POPREAL8ARRAY(point%qm(1, :, i), 4)
      pointb%q(:, i) = pointb%q(:, i) + pointb%qm(1, :, i)
      pointb%qm(1, :, i) = 0.0_8
      pointdb%q(:, i) = pointdb%q(:, i) + pointdb%qm(1, :, i)
      pointdb%qm(1, :, i) = 0.0_8
      CALL POPREAL8ARRAY(sum_dely_delq, 4)
      CALL POPREAL8ARRAY(sum_delx_delq, 4)
      CALL POPREAL8(sum_delx_dely)
      CALL POPREAL8(sum_dely_sqr)
      CALL POPREAL8(sum_delx_sqr)
      pointb%y(i) = pointb%y(i) + y_ib
      pointb%x(i) = pointb%x(i) + x_ib
    END DO
  END SUBROUTINE EVAL_Q_DERIVATIVES_D_B

!  Differentiation of eval_q_derivatives in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: point.dq point.qm
!   with respect to varying inputs: point.q point.dq point.qm
  SUBROUTINE EVAL_Q_DERIVATIVES_D()
    IMPLICIT NONE
    INTEGER :: i, k, r, nbh
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: delx, dely, dist, weights
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delq(4), sum_dely_delq(4)
    REAL*8 :: sum_delx_delqd(4), sum_dely_delqd(4)
    REAL*8 :: det, delq, temp
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    REAL*8 :: arg1
    DO i=1,local_points
      x_i = point%x(i)
      y_i = point%y(i)
      sum_delx_sqr = 0.d0
      sum_dely_sqr = 0.d0
      sum_delx_dely = 0.d0
      sum_delx_delq = 0.d0
      sum_dely_delq = 0.d0
      pointd%qm(1, :, i) = pointd%q(:, i)
      point%qm(1, :, i) = point%q(:, i)
      pointd%qm(2, :, i) = pointd%q(:, i)
      point%qm(2, :, i) = point%q(:, i)
      sum_delx_delqd = 0.0_8
      sum_dely_delqd = 0.0_8
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        DO r=1,4
          IF (point%q(r, nbh) .GT. point%qm(1, r, i)) THEN
            pointd%qm(1, r, i) = pointd%q(r, nbh)
            point%qm(1, r, i) = point%q(r, nbh)
          END IF
          IF (point%q(r, nbh) .LT. point%qm(2, r, i)) THEN
            pointd%qm(2, r, i) = pointd%q(r, nbh)
            point%qm(2, r, i) = point%q(r, nbh)
          END IF
        END DO
        x_k = point%x(nbh)
        y_k = point%y(nbh)
        delx = x_k - x_i
        dely = y_k - y_i
        arg1 = delx*delx + dely*dely
        dist = DSQRT(arg1)
        weights = dist**power
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        sum_delx_delqd = sum_delx_delqd + weights*delx*(pointd%q(:, nbh)&
&         -pointd%q(:, i))
        sum_delx_delq = sum_delx_delq + weights*delx*(point%q(:, nbh)-&
&         point%q(:, i))
        sum_dely_delqd = sum_dely_delqd + weights*dely*(pointd%q(:, nbh)&
&         -pointd%q(:, i))
        sum_dely_delq = sum_dely_delq + weights*dely*(point%q(:, nbh)-&
&         point%q(:, i))
      END DO
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      one_by_det = 1.0d0/det
      pointd%dq(1, :, i) = one_by_det*(sum_dely_sqr*sum_delx_delqd-&
&       sum_delx_dely*sum_dely_delqd)
      point%dq(1, :, i) = (sum_delx_delq*sum_dely_sqr-sum_dely_delq*&
&       sum_delx_dely)*one_by_det
      pointd%dq(2, :, i) = one_by_det*(sum_delx_sqr*sum_dely_delqd-&
&       sum_delx_dely*sum_delx_delqd)
      point%dq(2, :, i) = (sum_dely_delq*sum_delx_sqr-sum_delx_delq*&
&       sum_delx_dely)*one_by_det
    END DO
  END SUBROUTINE EVAL_Q_DERIVATIVES_D

  SUBROUTINE EVAL_Q_DERIVATIVES()
    IMPLICIT NONE
    INTEGER :: i, k, r, nbh
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: delx, dely, dist, weights
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delq(4), sum_dely_delq(4)
    REAL*8 :: det, delq, temp
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    REAL*8 :: arg1
    DO i=1,local_points
      x_i = point%x(i)
      y_i = point%y(i)
      sum_delx_sqr = 0.d0
      sum_dely_sqr = 0.d0
      sum_delx_dely = 0.d0
      sum_delx_delq = 0.d0
      sum_dely_delq = 0.d0
      point%qm(1, :, i) = point%q(:, i)
      point%qm(2, :, i) = point%q(:, i)
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        DO r=1,4
          IF (point%q(r, nbh) .GT. point%qm(1, r, i)) point%qm(1, r, i)&
&            = point%q(r, nbh)
          IF (point%q(r, nbh) .LT. point%qm(2, r, i)) point%qm(2, r, i)&
&            = point%q(r, nbh)
        END DO
        x_k = point%x(nbh)
        y_k = point%y(nbh)
        delx = x_k - x_i
        dely = y_k - y_i
        arg1 = delx*delx + dely*dely
        dist = DSQRT(arg1)
        weights = dist**power
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        sum_delx_delq = sum_delx_delq + weights*delx*(point%q(:, nbh)-&
&         point%q(:, i))
        sum_dely_delq = sum_dely_delq + weights*dely*(point%q(:, nbh)-&
&         point%q(:, i))
      END DO
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      one_by_det = 1.0d0/det
      point%dq(1, :, i) = (sum_delx_delq*sum_dely_sqr-sum_dely_delq*&
&       sum_delx_dely)*one_by_det
      point%dq(2, :, i) = (sum_dely_delq*sum_delx_sqr-sum_delx_delq*&
&       sum_delx_dely)*one_by_det
    END DO
  END SUBROUTINE EVAL_Q_DERIVATIVES

!  Differentiation of qtilde_to_primitive_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: u1d rhod prd u1 u2 pr u2d rho
!   with respect to varying inputs: qtilded qtilde
!  Differentiation of qtilde_to_primitive in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u1 u2 pr rho
!   with respect to varying inputs: qtilde
  SUBROUTINE QTILDE_TO_PRIMITIVE_D_B(qtilde, qtildeb, qtilded, qtildedb&
&   , u1, u1b, u1d, u1db, u2, u2b, u2d, u2db, rho, rhob, rhod, rhodb, pr&
&   , prb, prd, prdb)
    IMPLICIT NONE
    REAL*8 :: qtilde(4), u1, u2, rho, pr
    REAL*8 :: qtildeb(4), u1b, u2b, rhob, prb
    REAL*8 :: qtilded(4), u1d, u2d, rhod, prd
    REAL*8 :: qtildedb(4), u1db, u2db, rhodb, prdb
    REAL*8 :: beta, temp, temp1, temp2
    REAL*8 :: betab, tempb, temp1b, temp2b
    REAL*8 :: betad, tempd, temp1d, temp2d
    REAL*8 :: betadb, tempdb, temp1db, temp2db
    REAL*8 :: q1, q2, q3, q4
    REAL*8 :: q1b, q2b, q3b, q4b
    REAL*8 :: q1d, q2d, q3d, q4d
    REAL*8 :: q1db, q2db, q3db, q4db
    INTRINSIC DLOG
    INTRINSIC DEXP
    REAL*8 :: tempb0
    REAL*8 :: tempb1
    REAL*8 :: tempb2
    q1d = qtilded(1)
    q1 = qtilde(1)
    q2d = qtilded(2)
    q2 = qtilde(2)
    q3d = qtilded(3)
    q3 = qtilde(3)
    q4d = qtilded(4)
    q4 = qtilde(4)
    betad = -(0.5d0*q4d)
    beta = -(q4*0.5d0)
    tempd = -(0.5d0*betad/beta**2)
    temp = 0.5d0/beta
    CALL PUSHREAL8(u1d)
    u1d = q2d*temp + q2*tempd
    CALL PUSHREAL8(u1)
    u1 = q2*temp
    CALL PUSHREAL8(u2d)
    u2d = q3d*temp + q3*tempd
    CALL PUSHREAL8(u2)
    u2 = q3*temp
    temp1d = q1d + betad*(u1*u1+u2*u2) + beta*(u1d*u1+u1*u1d+u2d*u2+u2*&
&     u2d)
    temp1 = q1 + beta*(u1*u1+u2*u2)
    temp2d = temp1d - betad/beta/(gamma-1)
    temp2 = temp1 - DLOG(beta)/(gamma-1)
    CALL PUSHREAL8(rhod)
    rhod = temp2d*DEXP(temp2)
    CALL PUSHREAL8(rho)
    rho = DEXP(temp2)
    rhob = rhob + tempd*prdb + temp*prb
    rhodb = rhodb + temp*prdb
    temp2b = temp2d*DEXP(temp2)*rhodb + DEXP(temp2)*rhob
    temp2db = DEXP(temp2)*rhodb
    temp1b = temp2b
    tempb0 = -(temp2db/((gamma-1)*beta))
    temp1db = temp2db
    q1b = temp1b
    tempb2 = beta*temp1db
    u1b = u1b + betad*2*u1*temp1db + 2*u1d*tempb2 + beta*2*u1*temp1b
    u2b = u2b + betad*2*u2*temp1db + 2*u2d*tempb2 + beta*2*u2*temp1b
    q1db = temp1db
    u1db = u1db + 2*u1*tempb2
    u2db = u2db + 2*u2*tempb2
    tempb = rhod*prdb + q3d*u2db + q2d*u1db + q2*u1b + q3*u2b + rho*prb
    tempdb = q3*u2db + q2*u1db + rho*prdb
    CALL POPREAL8(rho)
    CALL POPREAL8(rhod)
    q3b = tempd*u2db + temp*u2b
    q3db = temp*u2db
    q2b = tempd*u1db + temp*u1b
    q2db = temp*u1db
    tempb1 = -(0.5d0*tempdb/beta**2)
    betab = (u1d*u1+u1*u1d+u2d*u2+u2*u2d)*temp1db - betad*tempb0/beta - &
&     betad*2*tempb1/beta - 0.5d0*tempb/beta**2 + (u1**2+u2**2)*temp1b -&
&     temp2b/((gamma-1)*beta)
    betadb = (u1**2+u2**2)*temp1db + tempb1 + tempb0
    CALL POPREAL8(u2)
    CALL POPREAL8(u2d)
    CALL POPREAL8(u1)
    CALL POPREAL8(u1d)
    q4b = -(0.5d0*betab)
    q4db = -(0.5d0*betadb)
    qtildeb = 0.0_8
    qtildeb(4) = qtildeb(4) + q4b
    qtildedb = 0.0_8
    qtildedb(4) = qtildedb(4) + q4db
    qtildeb(3) = qtildeb(3) + q3b
    qtildedb(3) = qtildedb(3) + q3db
    qtildeb(2) = qtildeb(2) + q2b
    qtildedb(2) = qtildedb(2) + q2db
    qtildeb(1) = qtildeb(1) + q1b
    qtildedb(1) = qtildedb(1) + q1db
  END SUBROUTINE QTILDE_TO_PRIMITIVE_D_B

!  Differentiation of qtilde_to_primitive in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u1 u2 pr rho
!   with respect to varying inputs: qtilde
  SUBROUTINE QTILDE_TO_PRIMITIVE_D(qtilde, qtilded, u1, u1d, u2, u2d, &
&   rho, rhod, pr, prd)
    IMPLICIT NONE
    REAL*8 :: qtilde(4), u1, u2, rho, pr
    REAL*8 :: qtilded(4), u1d, u2d, rhod, prd
    REAL*8 :: beta, temp, temp1, temp2
    REAL*8 :: betad, tempd, temp1d, temp2d
    REAL*8 :: q1, q2, q3, q4
    REAL*8 :: q1d, q2d, q3d, q4d
    INTRINSIC DLOG
    INTRINSIC DEXP
    q1d = qtilded(1)
    q1 = qtilde(1)
    q2d = qtilded(2)
    q2 = qtilde(2)
    q3d = qtilded(3)
    q3 = qtilde(3)
    q4d = qtilded(4)
    q4 = qtilde(4)
    betad = -(0.5d0*q4d)
    beta = -(q4*0.5d0)
    tempd = -(0.5d0*betad/beta**2)
    temp = 0.5d0/beta
    u1d = q2d*temp + q2*tempd
    u1 = q2*temp
    u2d = q3d*temp + q3*tempd
    u2 = q3*temp
    temp1d = q1d + betad*(u1*u1+u2*u2) + beta*(u1d*u1+u1*u1d+u2d*u2+u2*&
&     u2d)
    temp1 = q1 + beta*(u1*u1+u2*u2)
    temp2d = temp1d - betad/beta/(gamma-1)
    temp2 = temp1 - DLOG(beta)/(gamma-1)
    rhod = temp2d*DEXP(temp2)
    rho = DEXP(temp2)
    prd = rhod*temp + rho*tempd
    pr = rho*temp
  END SUBROUTINE QTILDE_TO_PRIMITIVE_D

  SUBROUTINE QTILDE_TO_PRIMITIVE(qtilde, u1, u2, rho, pr)
    IMPLICIT NONE
    REAL*8 :: qtilde(4), u1, u2, rho, pr
    REAL*8 :: beta, temp, temp1, temp2
    REAL*8 :: q1, q2, q3, q4
    INTRINSIC DLOG
    INTRINSIC DEXP
    q1 = qtilde(1)
    q2 = qtilde(2)
    q3 = qtilde(3)
    q4 = qtilde(4)
    beta = -(q4*0.5d0)
    temp = 0.5d0/beta
    u1 = q2*temp
    u2 = q3*temp
    temp1 = q1 + beta*(u1*u1+u2*u2)
    temp2 = temp1 - DLOG(beta)/(gamma-1)
    rho = DEXP(temp2)
    pr = rho*temp
  END SUBROUTINE QTILDE_TO_PRIMITIVE

END MODULE Q_VARIABLES_MOD_DIFF_DIFF

