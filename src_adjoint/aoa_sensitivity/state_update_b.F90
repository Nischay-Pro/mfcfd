!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
MODULE STATE_UPDATE_MOD_DIFF_DIFF
  USE DATA_STRUCTURE_MOD_DIFF
  USE FLUX_RESIDUAL_MOD_DIFF_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of state_update_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: pointd.prim pointd.prim_old
!                pointd.flux_res point.nx point.ny point.prim point.prim_old
!                point.flux_res
!   with respect to varying inputs: pointd.prim pointd.prim_old
!                pointd.flux_res point.nx point.ny point.prim point.prim_old
!                point.flux_res
!  Differentiation of state_update in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: point.prim
!   with respect to varying inputs: q_inf point.prim point.prim_old
!                point.flux_res
  SUBROUTINE STATE_UPDATE_D_B(rk)
    IMPLICIT NONE
    INTEGER :: i, k, r, rk
    REAL*8 :: delt, u(4), temp, u_old(4)
    REAL*8 :: ub(4), tempb, u_oldb(4)
    REAL*8 :: ud(4), tempd, u_oldd(4)
    REAL*8 :: udb(4), tempdb, u_olddb(4)
    REAL*8 :: res_sqr
    REAL*8 :: nx, ny
    REAL*8 :: nxb, nyb
    REAL*8 :: u2_rot, u3_rot
    REAL*8 :: u2_rotb, u3_rotb
    REAL*8 :: u2_rotd, u3_rotd
    REAL*8 :: u2_rotdb, u3_rotdb
    REAL*8, PARAMETER :: obt=1.0d0/3.0d0
    REAL*8, PARAMETER :: tbt=2.0d0/3.0d0
    REAL*8 :: tempb0
    REAL*8 :: tempb1
    REAL*8 :: tempb2
    REAL*8 :: tempb3
    REAL*8 :: tempb4
    REAL*8 :: tempb5
    REAL*8 :: tempb6
    REAL*8 :: tempb7
    REAL*8 :: tempb8
    REAL*8 :: tempb9
    REAL*8 :: tempb10
    REAL*8 :: tempb11
    INTEGER :: branch
    ud = 0.0_8
    u_oldd = 0.0_8
    DO i=1,wall_points
      k = wall_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PUSHREAL8ARRAY(ud, 4)
      CALL PUSHREAL8ARRAY(u, 4)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim(:, k), pointd%prim(:, k)&
&                             , nx, ny, u, ud)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim_old(:, k), pointd%&
&                             prim_old(:, k), nx, ny, u_old, u_oldd)
      IF (rk .NE. 3) THEN
        ud = ud - 0.5d0*euler*pointd%flux_res(:, k)
        u = u - 0.5d0*euler*point%flux_res(:, k)
        CALL PUSHCONTROL1B(0)
      ELSE
        ud = tbt*u_oldd + obt*(ud-0.5d0*pointd%flux_res(:, k))
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
        CALL PUSHCONTROL1B(1)
      END IF
      ud(3) = 0.0_8
      u(3) = 0.d0
      CALL PUSHREAL8(u2_rotd)
      u2_rotd = ud(2)
      CALL PUSHREAL8(u2_rot)
      u2_rot = u(2)
      CALL PUSHREAL8(u3_rotd)
      u3_rotd = ud(3)
      CALL PUSHREAL8(u3_rot)
      u3_rot = u(3)
      ud(2) = ny*u2_rotd + nx*u3_rotd
      u(2) = u2_rot*ny + u3_rot*nx
      ud(3) = ny*u3_rotd - nx*u2_rotd
      u(3) = u3_rot*ny - u2_rot*nx
      CALL PUSHREAL8(pointd%prim(1, k))
      pointd%prim(1, k) = ud(1)
      CALL PUSHREAL8(point%prim(1, k))
      point%prim(1, k) = u(1)
      tempd = -(ud(1)/u(1)**2)
      temp = 1.0d0/u(1)
      CALL PUSHREAL8(pointd%prim(2, k))
      pointd%prim(2, k) = ud(2)*temp + u(2)*tempd
      CALL PUSHREAL8(point%prim(2, k))
      point%prim(2, k) = u(2)*temp
      CALL PUSHREAL8(pointd%prim(3, k))
      pointd%prim(3, k) = ud(3)*temp + u(3)*tempd
      CALL PUSHREAL8(point%prim(3, k))
      point%prim(3, k) = u(3)*temp
      CALL PUSHREAL8(pointd%prim(4, k))
      pointd%prim(4, k) = 0.4d0*ud(4) - 0.2d0*(tempd*(u(2)*u(2)+u(3)*u(3&
&       ))+temp*(ud(2)*u(2)+u(2)*ud(2)+ud(3)*u(3)+u(3)*ud(3)))
      CALL PUSHREAL8(point%prim(4, k))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,outer_points
      k = outer_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PUSHREAL8ARRAY(ud, 4)
      CALL PUSHREAL8ARRAY(u, 4)
      CALL CONSERVED_VECTOR_UBAR_D(point%prim(:, k), pointd%prim(:, k), &
&                            u, ud, nx, ny)
      CALL CONSERVED_VECTOR_UBAR_D(point%prim_old(:, k), pointd%prim_old&
&                            (:, k), u_old, u_oldd, nx, ny)
      IF (rk .NE. 3) THEN
        ud = ud - 0.5d0*euler*pointd%flux_res(:, k)
        u = u - 0.5d0*euler*point%flux_res(:, k)
        CALL PUSHCONTROL1B(0)
      ELSE
        ud = tbt*u_oldd + obt*(ud-0.5d0*pointd%flux_res(:, k))
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8(u2_rotd)
      u2_rotd = ud(2)
      CALL PUSHREAL8(u2_rot)
      u2_rot = u(2)
      CALL PUSHREAL8(u3_rotd)
      u3_rotd = ud(3)
      CALL PUSHREAL8(u3_rot)
      u3_rot = u(3)
      ud(2) = ny*u2_rotd + nx*u3_rotd
      u(2) = u2_rot*ny + u3_rot*nx
      ud(3) = ny*u3_rotd - nx*u2_rotd
      u(3) = u3_rot*ny - u2_rot*nx
      CALL PUSHREAL8(pointd%prim(1, k))
      pointd%prim(1, k) = ud(1)
      CALL PUSHREAL8(point%prim(1, k))
      point%prim(1, k) = u(1)
      tempd = -(ud(1)/u(1)**2)
      temp = 1.0d0/u(1)
      CALL PUSHREAL8(pointd%prim(2, k))
      pointd%prim(2, k) = ud(2)*temp + u(2)*tempd
      CALL PUSHREAL8(point%prim(2, k))
      point%prim(2, k) = u(2)*temp
      CALL PUSHREAL8(pointd%prim(3, k))
      pointd%prim(3, k) = ud(3)*temp + u(3)*tempd
      CALL PUSHREAL8(point%prim(3, k))
      point%prim(3, k) = u(3)*temp
      CALL PUSHREAL8(pointd%prim(4, k))
      pointd%prim(4, k) = 0.4d0*ud(4) - 0.2d0*(tempd*(u(2)*u(2)+u(3)*u(3&
&       ))+temp*(ud(2)*u(2)+u(2)*ud(2)+ud(3)*u(3)+u(3)*ud(3)))
      CALL PUSHREAL8(point%prim(4, k))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,interior_points
      k = interior_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PUSHREAL8ARRAY(ud, 4)
      CALL PUSHREAL8ARRAY(u, 4)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim(:, k), pointd%prim(:, k)&
&                             , nx, ny, u, ud)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim_old(:, k), pointd%&
&                             prim_old(:, k), nx, ny, u_old, u_oldd)
      IF (rk .NE. 3) THEN
        ud = ud - 0.5d0*euler*pointd%flux_res(:, k)
        u = u - 0.5d0*euler*point%flux_res(:, k)
        CALL PUSHCONTROL1B(0)
      ELSE
        ud = tbt*u_oldd + obt*(ud-0.5d0*pointd%flux_res(:, k))
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8(u2_rotd)
      u2_rotd = ud(2)
      CALL PUSHREAL8(u2_rot)
      u2_rot = u(2)
      CALL PUSHREAL8(u3_rotd)
      u3_rotd = ud(3)
      CALL PUSHREAL8(u3_rot)
      u3_rot = u(3)
      ud(2) = ny*u2_rotd + nx*u3_rotd
      u(2) = u2_rot*ny + u3_rot*nx
      ud(3) = ny*u3_rotd - nx*u2_rotd
      u(3) = u3_rot*ny - u2_rot*nx
      CALL PUSHREAL8(pointd%prim(1, k))
      pointd%prim(1, k) = ud(1)
      CALL PUSHREAL8(point%prim(1, k))
      point%prim(1, k) = u(1)
      tempd = -(ud(1)/u(1)**2)
      temp = 1.0d0/u(1)
      CALL PUSHREAL8(pointd%prim(2, k))
      pointd%prim(2, k) = ud(2)*temp + u(2)*tempd
      CALL PUSHREAL8(point%prim(2, k))
      point%prim(2, k) = u(2)*temp
      CALL PUSHREAL8(pointd%prim(3, k))
      pointd%prim(3, k) = ud(3)*temp + u(3)*tempd
      CALL PUSHREAL8(point%prim(3, k))
      point%prim(3, k) = u(3)*temp
      CALL PUSHREAL8(pointd%prim(4, k))
      pointd%prim(4, k) = 0.4d0*ud(4) - 0.2d0*(tempd*(u(2)*u(2)+u(3)*u(3&
&       ))+temp*(ud(2)*u(2)+u(2)*ud(2)+ud(3)*u(3)+u(3)*ud(3)))
      CALL PUSHREAL8(point%prim(4, k))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    ub = 0.0_8
    u_oldb = 0.0_8
    udb = 0.0_8
    u_olddb = 0.0_8
    DO i=interior_points,1,-1
      k = interior_points_index(i)
      temp = 1.0d0/u(1)
      CALL POPREAL8(point%prim(4, k))
      tempb8 = -(0.2d0*temp*pointb%prim(4, k))
      ub(4) = ub(4) + 0.4d0*pointb%prim(4, k)
      tempb = -(0.2d0*(u(2)**2+u(3)**2)*pointb%prim(4, k))
      ub(2) = ub(2) + 2*u(2)*tempb8
      ub(3) = ub(3) + 2*u(3)*tempb8
      pointb%prim(4, k) = 0.0_8
      tempd = -(ud(1)/u(1)**2)
      CALL POPREAL8(pointd%prim(4, k))
      tempb9 = -(0.2d0*pointdb%prim(4, k))
      tempb10 = temp*tempb9
      udb(4) = udb(4) + 0.4d0*pointdb%prim(4, k)
      ub(2) = ub(2) + 2*ud(2)*tempb10 + tempd*2*u(2)*tempb9
      udb(2) = udb(2) + 2*u(2)*tempb10
      pointdb%prim(4, k) = 0.0_8
      tempdb = u(3)*pointdb%prim(3, k) + (u(2)**2+u(3)**2)*tempb9
      ub(3) = ub(3) + temp*pointb%prim(3, k) + tempd*pointdb%prim(3, k) &
&       + 2*ud(3)*tempb10 + tempd*2*u(3)*tempb9
      tempb = tempb + u(3)*pointb%prim(3, k) + ud(3)*pointdb%prim(3, k) &
&       + (ud(2)*u(2)+u(2)*ud(2)+ud(3)*u(3)+u(3)*ud(3))*tempb9
      udb(3) = udb(3) + temp*pointdb%prim(3, k) + 2*u(3)*tempb10
      CALL POPREAL8(point%prim(3, k))
      pointb%prim(3, k) = 0.0_8
      CALL POPREAL8(pointd%prim(3, k))
      pointdb%prim(3, k) = 0.0_8
      CALL POPREAL8(point%prim(2, k))
      ub(2) = ub(2) + tempd*pointdb%prim(2, k) + temp*pointb%prim(2, k)
      tempb = tempb + ud(2)*pointdb%prim(2, k) + u(2)*pointb%prim(2, k)
      pointb%prim(2, k) = 0.0_8
      CALL POPREAL8(pointd%prim(2, k))
      udb(2) = udb(2) + temp*pointdb%prim(2, k)
      tempdb = tempdb + u(2)*pointdb%prim(2, k)
      pointdb%prim(2, k) = 0.0_8
      tempb11 = -(tempdb/u(1)**2)
      ub(1) = ub(1) + pointb%prim(1, k) - ud(1)*2*tempb11/u(1) - tempb/u&
&       (1)**2
      udb(1) = udb(1) + pointdb%prim(1, k) + tempb11
      CALL POPREAL8(point%prim(1, k))
      pointb%prim(1, k) = 0.0_8
      CALL POPREAL8(pointd%prim(1, k))
      pointdb%prim(1, k) = 0.0_8
      nx = point%nx(k)
      ny = point%ny(k)
      u3_rotb = ny*ub(3)
      nyb = u3_rotd*udb(3) + u3_rot*ub(3)
      u2_rotb = -(nx*ub(3))
      nxb = -(u2_rotd*udb(3)) - u2_rot*ub(3)
      ub(3) = 0.0_8
      u3_rotdb = ny*udb(3)
      u2_rotdb = -(nx*udb(3))
      udb(3) = 0.0_8
      u2_rotb = u2_rotb + ny*ub(2)
      nyb = nyb + u2_rotd*udb(2) + u2_rot*ub(2)
      u3_rotb = u3_rotb + nx*ub(2)
      nxb = nxb + u3_rotd*udb(2) + u3_rot*ub(2)
      ub(2) = 0.0_8
      u2_rotdb = u2_rotdb + ny*udb(2)
      u3_rotdb = u3_rotdb + nx*udb(2)
      udb(2) = 0.0_8
      CALL POPREAL8(u3_rot)
      ub(3) = ub(3) + u3_rotb
      CALL POPREAL8(u3_rotd)
      udb(3) = udb(3) + u3_rotdb
      CALL POPREAL8(u2_rot)
      ub(2) = ub(2) + u2_rotb
      CALL POPREAL8(u2_rotd)
      udb(2) = udb(2) + u2_rotdb
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        pointb%flux_res(:, k) = pointb%flux_res(:, k) - euler*0.5d0*ub
        pointdb%flux_res(:, k) = pointdb%flux_res(:, k) - euler*0.5d0*&
&         udb
      ELSE
        u_oldb = u_oldb + tbt*ub
        pointb%flux_res(:, k) = pointb%flux_res(:, k) - obt*0.5d0*ub
        ub = obt*ub
        u_olddb = u_olddb + tbt*udb
        pointdb%flux_res(:, k) = pointdb%flux_res(:, k) - obt*0.5d0*udb
        udb = obt*udb
      END IF
      CALL PRIMITIVE_TO_CONSERVED_D_B(point%prim_old(:, k), pointb%&
&                               prim_old(:, k), pointd%prim_old(:, k), &
&                               pointdb%prim_old(:, k), nx, nxb, ny, nyb&
&                               , u_old, u_oldb, u_oldd, u_olddb)
      CALL POPREAL8ARRAY(u, 4)
      CALL POPREAL8ARRAY(ud, 4)
      CALL PRIMITIVE_TO_CONSERVED_D_B(point%prim(:, k), pointb%prim(:, k&
&                               ), pointd%prim(:, k), pointdb%prim(:, k)&
&                               , nx, nxb, ny, nyb, u, ub, ud, udb)
      pointb%ny(k) = pointb%ny(k) + nyb
      pointb%nx(k) = pointb%nx(k) + nxb
    END DO
    DO i=outer_points,1,-1
      k = outer_points_index(i)
      temp = 1.0d0/u(1)
      CALL POPREAL8(point%prim(4, k))
      tempb4 = -(0.2d0*temp*pointb%prim(4, k))
      ub(4) = ub(4) + 0.4d0*pointb%prim(4, k)
      tempb = -(0.2d0*(u(2)**2+u(3)**2)*pointb%prim(4, k))
      ub(2) = ub(2) + 2*u(2)*tempb4
      ub(3) = ub(3) + 2*u(3)*tempb4
      pointb%prim(4, k) = 0.0_8
      tempd = -(ud(1)/u(1)**2)
      CALL POPREAL8(pointd%prim(4, k))
      tempb5 = -(0.2d0*pointdb%prim(4, k))
      tempb6 = temp*tempb5
      udb(4) = udb(4) + 0.4d0*pointdb%prim(4, k)
      ub(2) = ub(2) + 2*ud(2)*tempb6 + tempd*2*u(2)*tempb5
      udb(2) = udb(2) + 2*u(2)*tempb6
      pointdb%prim(4, k) = 0.0_8
      tempdb = u(3)*pointdb%prim(3, k) + (u(2)**2+u(3)**2)*tempb5
      ub(3) = ub(3) + temp*pointb%prim(3, k) + tempd*pointdb%prim(3, k) &
&       + 2*ud(3)*tempb6 + tempd*2*u(3)*tempb5
      tempb = tempb + u(3)*pointb%prim(3, k) + ud(3)*pointdb%prim(3, k) &
&       + (ud(2)*u(2)+u(2)*ud(2)+ud(3)*u(3)+u(3)*ud(3))*tempb5
      udb(3) = udb(3) + temp*pointdb%prim(3, k) + 2*u(3)*tempb6
      CALL POPREAL8(point%prim(3, k))
      pointb%prim(3, k) = 0.0_8
      CALL POPREAL8(pointd%prim(3, k))
      pointdb%prim(3, k) = 0.0_8
      CALL POPREAL8(point%prim(2, k))
      ub(2) = ub(2) + tempd*pointdb%prim(2, k) + temp*pointb%prim(2, k)
      tempb = tempb + ud(2)*pointdb%prim(2, k) + u(2)*pointb%prim(2, k)
      pointb%prim(2, k) = 0.0_8
      CALL POPREAL8(pointd%prim(2, k))
      udb(2) = udb(2) + temp*pointdb%prim(2, k)
      tempdb = tempdb + u(2)*pointdb%prim(2, k)
      pointdb%prim(2, k) = 0.0_8
      tempb7 = -(tempdb/u(1)**2)
      ub(1) = ub(1) + pointb%prim(1, k) - ud(1)*2*tempb7/u(1) - tempb/u(&
&       1)**2
      udb(1) = udb(1) + pointdb%prim(1, k) + tempb7
      CALL POPREAL8(point%prim(1, k))
      pointb%prim(1, k) = 0.0_8
      CALL POPREAL8(pointd%prim(1, k))
      pointdb%prim(1, k) = 0.0_8
      nx = point%nx(k)
      ny = point%ny(k)
      u3_rotb = ny*ub(3)
      nyb = u3_rotd*udb(3) + u3_rot*ub(3)
      u2_rotb = -(nx*ub(3))
      nxb = -(u2_rotd*udb(3)) - u2_rot*ub(3)
      ub(3) = 0.0_8
      u3_rotdb = ny*udb(3)
      u2_rotdb = -(nx*udb(3))
      udb(3) = 0.0_8
      u2_rotb = u2_rotb + ny*ub(2)
      nyb = nyb + u2_rotd*udb(2) + u2_rot*ub(2)
      u3_rotb = u3_rotb + nx*ub(2)
      nxb = nxb + u3_rotd*udb(2) + u3_rot*ub(2)
      ub(2) = 0.0_8
      u2_rotdb = u2_rotdb + ny*udb(2)
      u3_rotdb = u3_rotdb + nx*udb(2)
      udb(2) = 0.0_8
      CALL POPREAL8(u3_rot)
      ub(3) = ub(3) + u3_rotb
      CALL POPREAL8(u3_rotd)
      udb(3) = udb(3) + u3_rotdb
      CALL POPREAL8(u2_rot)
      ub(2) = ub(2) + u2_rotb
      CALL POPREAL8(u2_rotd)
      udb(2) = udb(2) + u2_rotdb
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        pointb%flux_res(:, k) = pointb%flux_res(:, k) - euler*0.5d0*ub
        pointdb%flux_res(:, k) = pointdb%flux_res(:, k) - euler*0.5d0*&
&         udb
      ELSE
        u_oldb = u_oldb + tbt*ub
        pointb%flux_res(:, k) = pointb%flux_res(:, k) - obt*0.5d0*ub
        ub = obt*ub
        u_olddb = u_olddb + tbt*udb
        pointdb%flux_res(:, k) = pointdb%flux_res(:, k) - obt*0.5d0*udb
        udb = obt*udb
      END IF
      CALL CONSERVED_VECTOR_UBAR_D_B(point%prim_old(:, k), pointb%&
&                              prim_old(:, k), pointd%prim_old(:, k), &
&                              pointdb%prim_old(:, k), u_old, u_oldb, &
&                              u_oldd, u_olddb, nx, nxb, ny, nyb)
      CALL POPREAL8ARRAY(u, 4)
      CALL POPREAL8ARRAY(ud, 4)
      CALL CONSERVED_VECTOR_UBAR_D_B(point%prim(:, k), pointb%prim(:, k)&
&                              , pointd%prim(:, k), pointdb%prim(:, k), &
&                              u, ub, ud, udb, nx, nxb, ny, nyb)
      pointb%ny(k) = pointb%ny(k) + nyb
      pointb%nx(k) = pointb%nx(k) + nxb
    END DO
    DO i=wall_points,1,-1
      k = wall_points_index(i)
      temp = 1.0d0/u(1)
      CALL POPREAL8(point%prim(4, k))
      tempb0 = -(0.2d0*temp*pointb%prim(4, k))
      ub(4) = ub(4) + 0.4d0*pointb%prim(4, k)
      tempb = -(0.2d0*(u(2)**2+u(3)**2)*pointb%prim(4, k))
      ub(2) = ub(2) + 2*u(2)*tempb0
      ub(3) = ub(3) + 2*u(3)*tempb0
      pointb%prim(4, k) = 0.0_8
      tempd = -(ud(1)/u(1)**2)
      CALL POPREAL8(pointd%prim(4, k))
      tempb1 = -(0.2d0*pointdb%prim(4, k))
      tempb2 = temp*tempb1
      udb(4) = udb(4) + 0.4d0*pointdb%prim(4, k)
      ub(2) = ub(2) + 2*ud(2)*tempb2 + tempd*2*u(2)*tempb1
      udb(2) = udb(2) + 2*u(2)*tempb2
      pointdb%prim(4, k) = 0.0_8
      tempdb = u(3)*pointdb%prim(3, k) + (u(2)**2+u(3)**2)*tempb1
      ub(3) = ub(3) + temp*pointb%prim(3, k) + tempd*pointdb%prim(3, k) &
&       + 2*ud(3)*tempb2 + tempd*2*u(3)*tempb1
      tempb = tempb + u(3)*pointb%prim(3, k) + ud(3)*pointdb%prim(3, k) &
&       + (ud(2)*u(2)+u(2)*ud(2)+ud(3)*u(3)+u(3)*ud(3))*tempb1
      udb(3) = udb(3) + temp*pointdb%prim(3, k) + 2*u(3)*tempb2
      CALL POPREAL8(point%prim(3, k))
      pointb%prim(3, k) = 0.0_8
      CALL POPREAL8(pointd%prim(3, k))
      pointdb%prim(3, k) = 0.0_8
      CALL POPREAL8(point%prim(2, k))
      ub(2) = ub(2) + tempd*pointdb%prim(2, k) + temp*pointb%prim(2, k)
      tempb = tempb + ud(2)*pointdb%prim(2, k) + u(2)*pointb%prim(2, k)
      pointb%prim(2, k) = 0.0_8
      CALL POPREAL8(pointd%prim(2, k))
      udb(2) = udb(2) + temp*pointdb%prim(2, k)
      tempdb = tempdb + u(2)*pointdb%prim(2, k)
      pointdb%prim(2, k) = 0.0_8
      tempb3 = -(tempdb/u(1)**2)
      ub(1) = ub(1) + pointb%prim(1, k) - ud(1)*2*tempb3/u(1) - tempb/u(&
&       1)**2
      udb(1) = udb(1) + pointdb%prim(1, k) + tempb3
      CALL POPREAL8(point%prim(1, k))
      pointb%prim(1, k) = 0.0_8
      CALL POPREAL8(pointd%prim(1, k))
      pointdb%prim(1, k) = 0.0_8
      nx = point%nx(k)
      ny = point%ny(k)
      u3_rotb = ny*ub(3)
      nyb = u3_rotd*udb(3) + u3_rot*ub(3)
      u2_rotb = -(nx*ub(3))
      nxb = -(u2_rotd*udb(3)) - u2_rot*ub(3)
      ub(3) = 0.0_8
      u3_rotdb = ny*udb(3)
      u2_rotdb = -(nx*udb(3))
      udb(3) = 0.0_8
      u2_rotb = u2_rotb + ny*ub(2)
      nyb = nyb + u2_rotd*udb(2) + u2_rot*ub(2)
      u3_rotb = u3_rotb + nx*ub(2)
      nxb = nxb + u3_rotd*udb(2) + u3_rot*ub(2)
      ub(2) = 0.0_8
      u2_rotdb = u2_rotdb + ny*udb(2)
      u3_rotdb = u3_rotdb + nx*udb(2)
      udb(2) = 0.0_8
      CALL POPREAL8(u3_rot)
      ub(3) = ub(3) + u3_rotb
      CALL POPREAL8(u3_rotd)
      udb(3) = udb(3) + u3_rotdb
      CALL POPREAL8(u2_rot)
      ub(2) = ub(2) + u2_rotb
      CALL POPREAL8(u2_rotd)
      udb(2) = udb(2) + u2_rotdb
      ub(3) = 0.0_8
      udb(3) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        pointb%flux_res(:, k) = pointb%flux_res(:, k) - euler*0.5d0*ub
        pointdb%flux_res(:, k) = pointdb%flux_res(:, k) - euler*0.5d0*&
&         udb
      ELSE
        u_oldb = u_oldb + tbt*ub
        pointb%flux_res(:, k) = pointb%flux_res(:, k) - obt*0.5d0*ub
        ub = obt*ub
        u_olddb = u_olddb + tbt*udb
        pointdb%flux_res(:, k) = pointdb%flux_res(:, k) - obt*0.5d0*udb
        udb = obt*udb
      END IF
      CALL PRIMITIVE_TO_CONSERVED_D_B(point%prim_old(:, k), pointb%&
&                               prim_old(:, k), pointd%prim_old(:, k), &
&                               pointdb%prim_old(:, k), nx, nxb, ny, nyb&
&                               , u_old, u_oldb, u_oldd, u_olddb)
      CALL POPREAL8ARRAY(u, 4)
      CALL POPREAL8ARRAY(ud, 4)
      CALL PRIMITIVE_TO_CONSERVED_D_B(point%prim(:, k), pointb%prim(:, k&
&                               ), pointd%prim(:, k), pointdb%prim(:, k)&
&                               , nx, nxb, ny, nyb, u, ub, ud, udb)
      pointb%ny(k) = pointb%ny(k) + nyb
      pointb%nx(k) = pointb%nx(k) + nxb
    END DO
  END SUBROUTINE STATE_UPDATE_D_B

!  Differentiation of state_update in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: point.prim
!   with respect to varying inputs: q_inf point.prim point.prim_old
!                point.flux_res
  SUBROUTINE STATE_UPDATE_D(rk)
    IMPLICIT NONE
    INTEGER :: i, k, r, rk
    REAL*8 :: delt, u(4), temp, u_old(4)
    REAL*8 :: ud(4), tempd, u_oldd(4)
    REAL*8 :: res_sqr
    REAL*8 :: nx, ny
    REAL*8 :: u2_rot, u3_rot
    REAL*8 :: u2_rotd, u3_rotd
    REAL*8, PARAMETER :: obt=1.0d0/3.0d0
    REAL*8, PARAMETER :: tbt=2.0d0/3.0d0
    max_res = 0.0d0
    sum_res_sqr = 0.0d0
    ud = 0.0_8
    u_oldd = 0.0_8
    DO i=1,wall_points
      k = wall_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim(:, k), pointd%prim(:, k)&
&                             , nx, ny, u, ud)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim_old(:, k), pointd%&
&                             prim_old(:, k), nx, ny, u_old, u_oldd)
      temp = u(1)
      IF (rk .NE. 3) THEN
        ud = ud - 0.5d0*euler*pointd%flux_res(:, k)
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        ud = tbt*u_oldd + obt*(ud-0.5d0*pointd%flux_res(:, k))
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      ud(3) = 0.0_8
      u(3) = 0.d0
      u2_rotd = ud(2)
      u2_rot = u(2)
      u3_rotd = ud(3)
      u3_rot = u(3)
      ud(2) = ny*u2_rotd + nx*u3_rotd
      u(2) = u2_rot*ny + u3_rot*nx
      ud(3) = ny*u3_rotd - nx*u2_rotd
      u(3) = u3_rot*ny - u2_rot*nx
      res_sqr = (u(1)-temp)*(u(1)-temp)
      IF (res_sqr .GT. max_res) THEN
        max_res = res_sqr
        max_res_point = k
      END IF
      sum_res_sqr = sum_res_sqr + res_sqr
      pointd%prim(1, k) = ud(1)
      point%prim(1, k) = u(1)
      tempd = -(ud(1)/u(1)**2)
      temp = 1.0d0/u(1)
      pointd%prim(2, k) = ud(2)*temp + u(2)*tempd
      point%prim(2, k) = u(2)*temp
      pointd%prim(3, k) = ud(3)*temp + u(3)*tempd
      point%prim(3, k) = u(3)*temp
      pointd%prim(4, k) = 0.4d0*ud(4) - 0.2d0*(tempd*(u(2)*u(2)+u(3)*u(3&
&       ))+temp*(ud(2)*u(2)+u(2)*ud(2)+ud(3)*u(3)+u(3)*ud(3)))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,outer_points
      k = outer_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL CONSERVED_VECTOR_UBAR_D(point%prim(:, k), pointd%prim(:, k), &
&                            u, ud, nx, ny)
      CALL CONSERVED_VECTOR_UBAR_D(point%prim_old(:, k), pointd%prim_old&
&                            (:, k), u_old, u_oldd, nx, ny)
      temp = u(1)
      IF (rk .NE. 3) THEN
        ud = ud - 0.5d0*euler*pointd%flux_res(:, k)
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        ud = tbt*u_oldd + obt*(ud-0.5d0*pointd%flux_res(:, k))
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u2_rotd = ud(2)
      u2_rot = u(2)
      u3_rotd = ud(3)
      u3_rot = u(3)
      ud(2) = ny*u2_rotd + nx*u3_rotd
      u(2) = u2_rot*ny + u3_rot*nx
      ud(3) = ny*u3_rotd - nx*u2_rotd
      u(3) = u3_rot*ny - u2_rot*nx
      pointd%prim(1, k) = ud(1)
      point%prim(1, k) = u(1)
      tempd = -(ud(1)/u(1)**2)
      temp = 1.0d0/u(1)
      pointd%prim(2, k) = ud(2)*temp + u(2)*tempd
      point%prim(2, k) = u(2)*temp
      pointd%prim(3, k) = ud(3)*temp + u(3)*tempd
      point%prim(3, k) = u(3)*temp
      pointd%prim(4, k) = 0.4d0*ud(4) - 0.2d0*(tempd*(u(2)*u(2)+u(3)*u(3&
&       ))+temp*(ud(2)*u(2)+u(2)*ud(2)+ud(3)*u(3)+u(3)*ud(3)))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,interior_points
      k = interior_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim(:, k), pointd%prim(:, k)&
&                             , nx, ny, u, ud)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim_old(:, k), pointd%&
&                             prim_old(:, k), nx, ny, u_old, u_oldd)
      temp = u(1)
      IF (rk .NE. 3) THEN
        ud = ud - 0.5d0*euler*pointd%flux_res(:, k)
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        ud = tbt*u_oldd + obt*(ud-0.5d0*pointd%flux_res(:, k))
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u2_rotd = ud(2)
      u2_rot = u(2)
      u3_rotd = ud(3)
      u3_rot = u(3)
      ud(2) = ny*u2_rotd + nx*u3_rotd
      u(2) = u2_rot*ny + u3_rot*nx
      ud(3) = ny*u3_rotd - nx*u2_rotd
      u(3) = u3_rot*ny - u2_rot*nx
      res_sqr = (u(1)-temp)*(u(1)-temp)
      IF (res_sqr .GT. max_res) THEN
        max_res = res_sqr
        max_res_point = k
      END IF
      sum_res_sqr = sum_res_sqr + res_sqr
      pointd%prim(1, k) = ud(1)
      point%prim(1, k) = u(1)
      tempd = -(ud(1)/u(1)**2)
      temp = 1.0d0/u(1)
      pointd%prim(2, k) = ud(2)*temp + u(2)*tempd
      point%prim(2, k) = u(2)*temp
      pointd%prim(3, k) = ud(3)*temp + u(3)*tempd
      point%prim(3, k) = u(3)*temp
      pointd%prim(4, k) = 0.4d0*ud(4) - 0.2d0*(tempd*(u(2)*u(2)+u(3)*u(3&
&       ))+temp*(ud(2)*u(2)+u(2)*ud(2)+ud(3)*u(3)+u(3)*ud(3)))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
  END SUBROUTINE STATE_UPDATE_D

  SUBROUTINE STATE_UPDATE(rk)
    IMPLICIT NONE
    INTEGER :: i, k, r, rk
    REAL*8 :: delt, u(4), temp, u_old(4)
    REAL*8 :: res_sqr
    REAL*8 :: nx, ny
    REAL*8 :: u2_rot, u3_rot
    REAL*8, PARAMETER :: obt=1.0d0/3.0d0
    REAL*8, PARAMETER :: tbt=2.0d0/3.0d0
    max_res = 0.0d0
    sum_res_sqr = 0.0d0
    DO i=1,wall_points
      k = wall_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PRIMITIVE_TO_CONSERVED(point%prim(:, k), nx, ny, u)
      CALL PRIMITIVE_TO_CONSERVED(point%prim_old(:, k), nx, ny, u_old)
      temp = u(1)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u(3) = 0.d0
      u2_rot = u(2)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      res_sqr = (u(1)-temp)*(u(1)-temp)
      IF (res_sqr .GT. max_res) THEN
        max_res = res_sqr
        max_res_point = k
      END IF
      sum_res_sqr = sum_res_sqr + res_sqr
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      point%prim(2, k) = u(2)*temp
      point%prim(3, k) = u(3)*temp
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,outer_points
      k = outer_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL CONSERVED_VECTOR_UBAR(point%prim(:, k), u, nx, ny)
      CALL CONSERVED_VECTOR_UBAR(point%prim_old(:, k), u_old, nx, ny)
      temp = u(1)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u2_rot = u(2)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      point%prim(2, k) = u(2)*temp
      point%prim(3, k) = u(3)*temp
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,interior_points
      k = interior_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PRIMITIVE_TO_CONSERVED(point%prim(:, k), nx, ny, u)
      CALL PRIMITIVE_TO_CONSERVED(point%prim_old(:, k), nx, ny, u_old)
      temp = u(1)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u2_rot = u(2)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      res_sqr = (u(1)-temp)*(u(1)-temp)
      IF (res_sqr .GT. max_res) THEN
        max_res = res_sqr
        max_res_point = k
      END IF
      sum_res_sqr = sum_res_sqr + res_sqr
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      point%prim(2, k) = u(2)*temp
      point%prim(3, k) = u(3)*temp
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
  END SUBROUTINE STATE_UPDATE

!  Differentiation of primitive_to_conserved_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: primd prim u ud nx ny
!   with respect to varying inputs: primd prim u ud nx ny
!  Differentiation of primitive_to_conserved in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u
!   with respect to varying inputs: prim u
  SUBROUTINE PRIMITIVE_TO_CONSERVED_D_B(prim, primb, primd, primdb, nx, &
&   nxb, ny, nyb, u, ub, ud, udb)
    IMPLICIT NONE
    REAL*8 :: rho, prim(4)
    REAL*8 :: rhob, primb(4)
    REAL*8 :: rhod, primd(4)
    REAL*8 :: rhodb, primdb(4)
    REAL*8 :: u(4), nx, ny
    REAL*8 :: ub(4), nxb, nyb
    REAL*8 :: ud(4)
    REAL*8 :: udb(4)
    REAL*8 :: temp1, temp2
    REAL*8 :: temp1b, temp2b
    REAL*8 :: temp1d, temp2d
    REAL*8 :: temp1db, temp2db
    REAL*8 :: temp
    REAL*8 :: temp0
    REAL*8 :: tempb
    REAL*8 :: tempb0
    REAL*8 :: tempb1
    REAL*8 :: tempb2
    rhod = primd(1)
    rho = prim(1)
    temp1d = rhod*prim(2) + rho*primd(2)
    temp1 = rho*prim(2)
    temp2d = rhod*prim(3) + rho*primd(3)
    temp2 = rho*prim(3)
    temp1b = nx*ub(3)
    nxb = nxb + temp1d*udb(3) + temp1*ub(3)
    temp2b = ny*ub(3)
    nyb = nyb + temp2d*udb(3) + temp2*ub(3)
    ub(3) = 0.0_8
    temp1db = nx*udb(3)
    temp2db = ny*udb(3)
    udb(3) = 0.0_8
    temp1b = temp1b + ny*ub(2)
    nyb = nyb + temp1d*udb(2) + temp1*ub(2)
    temp2b = temp2b - nx*ub(2)
    nxb = nxb - temp2d*udb(2) - temp2*ub(2)
    ub(2) = 0.0_8
    temp1db = temp1db + ny*udb(2)
    temp2db = temp2db - nx*udb(2)
    udb(2) = 0.0_8
    tempb = 0.5d0*ub(4)/rho
    primb(4) = primb(4) + 2.5d0*ub(4)
    ub(4) = 0.0_8
    tempb2 = udb(4)/rho**2
    temp = temp1d*temp1 + temp1*temp1d + temp2d*temp2 + temp2*temp2d
    tempb0 = 0.5d0*rho*tempb2
    temp0 = temp1**2 + temp2**2
    tempb1 = -(0.5d0*rhod*tempb2)
    temp1b = temp1b + 2*temp1d*tempb0 + 2*temp1*tempb1 + 2*temp1*tempb
    temp2b = temp2b + 2*temp2d*tempb0 + 2*temp2*tempb1 + 2*temp2*tempb
    primdb(4) = primdb(4) + 2.5d0*udb(4)
    temp1db = temp1db + 2*temp1*tempb0
    temp2db = temp2db + 2*temp2*tempb0
    rhob = (0.5d0*temp-(0.5d0*(temp*rho)-0.5d0*(temp0*rhod))*2/rho)*&
&     tempb2 + primd(3)*temp2db + primd(2)*temp1db + ub(1) + prim(2)*&
&     temp1b + prim(3)*temp2b - (temp1**2+temp2**2)*tempb/rho
    udb(4) = 0.0_8
    rhodb = prim(3)*temp2db + udb(1) + prim(2)*temp1db - 0.5d0*temp0*&
&     tempb2
    primb(3) = primb(3) + rhod*temp2db + rho*temp2b
    primdb(3) = primdb(3) + rho*temp2db
    primb(2) = primb(2) + rhod*temp1db + rho*temp1b
    primdb(2) = primdb(2) + rho*temp1db
    ub(1) = 0.0_8
    udb(1) = 0.0_8
    primb(1) = primb(1) + rhob
    primdb(1) = primdb(1) + rhodb
  END SUBROUTINE PRIMITIVE_TO_CONSERVED_D_B

!  Differentiation of primitive_to_conserved in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u
!   with respect to varying inputs: prim u
  SUBROUTINE PRIMITIVE_TO_CONSERVED_D(prim, primd, nx, ny, u, ud)
    IMPLICIT NONE
    REAL*8 :: rho, prim(4)
    REAL*8 :: rhod, primd(4)
    REAL*8 :: u(4), nx, ny
    REAL*8 :: ud(4)
    REAL*8 :: temp1, temp2
    REAL*8 :: temp1d, temp2d
    rhod = primd(1)
    rho = prim(1)
    ud(1) = rhod
    u(1) = rho
    temp1d = rhod*prim(2) + rho*primd(2)
    temp1 = rho*prim(2)
    temp2d = rhod*prim(3) + rho*primd(3)
    temp2 = rho*prim(3)
    ud(4) = 2.5d0*primd(4) + (0.5d0*(temp1d*temp1+temp1*temp1d+temp2d*&
&     temp2+temp2*temp2d)*rho-0.5d0*(temp1*temp1+temp2*temp2)*rhod)/rho&
&     **2
    u(4) = 2.5d0*prim(4) + 0.5d0*(temp1*temp1+temp2*temp2)/rho
    ud(2) = ny*temp1d - nx*temp2d
    u(2) = temp1*ny - temp2*nx
    ud(3) = nx*temp1d + ny*temp2d
    u(3) = temp1*nx + temp2*ny
  END SUBROUTINE PRIMITIVE_TO_CONSERVED_D

  SUBROUTINE PRIMITIVE_TO_CONSERVED(prim, nx, ny, u)
    IMPLICIT NONE
    REAL*8 :: rho, prim(4)
    REAL*8 :: u(4), nx, ny
    REAL*8 :: temp1, temp2
    rho = prim(1)
    u(1) = rho
    temp1 = rho*prim(2)
    temp2 = rho*prim(3)
    u(4) = 2.5d0*prim(4) + 0.5d0*(temp1*temp1+temp2*temp2)/rho
    u(2) = temp1*ny - temp2*nx
    u(3) = temp1*nx + temp2*ny
  END SUBROUTINE PRIMITIVE_TO_CONSERVED

  SUBROUTINE CONSERVED_TO_PRIMITIVE(u, prim)
    IMPLICIT NONE
    REAL*8 :: temp, u(4), prim(4)
    prim(1) = u(1)
    temp = 1.0d0/u(1)
    prim(2) = u(2)*temp
    prim(3) = u(3)*temp
    temp = u(4) - 0.5d0*temp*(u(2)*u(2)+u(3)*u(3))
    prim(4) = 0.4d0*temp
  END SUBROUTINE CONSERVED_TO_PRIMITIVE

!  Differentiation of func_delta_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: pointd.prim pointd.delta point.x
!                point.y point.prim point.delta
!   with respect to varying inputs: pointd.prim pointd.delta point.x
!                point.y point.prim point.delta
!  Differentiation of func_delta in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: point.delta
!   with respect to varying inputs: point.prim point.delta
!	This subroutine computes the delta_t (local time step) at a given point ..
  SUBROUTINE FUNC_DELTA_D_B()
    IMPLICIT NONE
    INTEGER :: i, k, r
    REAL*8 :: delta_t
    REAL*8 :: delta_tb
    REAL*8 :: delta_td
    REAL*8 :: delta_tdb
    REAL*8 :: min_dist
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: u1, u2, rho, pr, mod_u
    REAL*8 :: u1b, u2b, rhob, prb, mod_ub
    REAL*8 :: u1d, u2d, rhod, prd, mod_ud
    REAL*8 :: u1db, u2db, rhodb, prdb, mod_udb
    REAL*8 :: dist
    REAL*8 :: distb
    REAL*8 :: min_delt
    REAL*8 :: min_deltb
    REAL*8 :: min_deltd
    REAL*8 :: min_deltdb
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: result1db
    REAL*8 :: tempb
    REAL*8 :: tempb0
    DOUBLE PRECISION :: temp
    REAL*8 :: tempb1
    REAL*8 :: tempb2
    DOUBLE PRECISION :: temp0
    REAL*8 :: tempb3
    REAL*8 :: temp1
    REAL*8 :: tempb4
    REAL*8 :: tempb5
    REAL*8 :: tempb6
    REAL*8 :: tempb7
    INTEGER :: branch
    INTEGER :: ad_to
    DO i=1,local_points
      min_delt = 1.0d0
      DO r=1,point%nbhs(i)
        k = point%conn(i, r)
        CALL PUSHREAL8(rhod)
        rhod = pointd%prim(1, k)
        rho = point%prim(1, k)
        CALL PUSHREAL8(u1d)
        u1d = pointd%prim(2, k)
        u1 = point%prim(2, k)
        CALL PUSHREAL8(u2d)
        u2d = pointd%prim(3, k)
        u2 = point%prim(3, k)
        CALL PUSHREAL8(prd)
        prd = pointd%prim(4, k)
        pr = point%prim(4, k)
        x_i = point%x(i)
        y_i = point%y(i)
        x_k = point%x(k)
        y_k = point%y(k)
        CALL PUSHREAL8(dist)
        dist = (x_k-x_i)*(x_k-x_i) + (y_k-y_i)*(y_k-y_i)
        CALL PUSHREAL8(dist)
        dist = DSQRT(dist)
        arg1d = u1d*u1 + u1*u1d + u2d*u2 + u2*u2d
        arg1 = u1*u1 + u2*u2
        IF (arg1 .EQ. 0.0) THEN
          CALL PUSHREAL8(mod_ud)
          mod_ud = 0.0_8
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(mod_ud)
          mod_ud = arg1d/(2.d0*DSQRT(arg1))
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(mod_u)
        mod_u = DSQRT(arg1)
        arg1d = (prd*rho-pr*rhod)/rho**2
        arg1 = pr/rho
        IF (arg1 .EQ. 0.0) THEN
          CALL PUSHREAL8(result1d)
          result1d = 0.d0
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(result1d)
          result1d = arg1d/(2.d0*DSQRT(arg1))
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(result1)
        result1 = DSQRT(arg1)
        delta_t = dist/(mod_u+3.0d0*result1)
        delta_t = cfl*delta_t
        IF (min_delt .GT. delta_t) THEN
          min_delt = delta_t
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
      CALL PUSHINTEGER4(r - 1)
    END DO
    DO i=local_points,1,-1
      min_deltb = pointb%delta(i)
      pointb%delta(i) = 0.0_8
      min_deltdb = pointdb%delta(i)
      pointdb%delta(i) = 0.0_8
      CALL POPINTEGER4(ad_to)
      DO r=ad_to,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          delta_tb = 0.0_8
          delta_tdb = 0.0_8
        ELSE
          delta_tb = min_deltb
          delta_tdb = min_deltdb
          min_deltdb = 0.0_8
          min_deltb = 0.0_8
        END IF
        delta_tb = cfl*delta_tb
        delta_tdb = cfl*delta_tdb
        tempb4 = delta_tb/(mod_u+3.0d0*result1)
        tempb5 = -(dist*tempb4/(mod_u+3.0d0*result1))
        temp1 = mod_u + 3.0d0*result1
        tempb6 = -(delta_tdb/temp1**2)
        distb = (mod_ud+3.0d0*result1d)*tempb6 + tempb4
        tempb7 = -(dist*(mod_ud+3.0d0*result1d)*2*tempb6/temp1)
        mod_ub = tempb7 + tempb5
        result1b = 3.0d0*tempb7 + 3.0d0*tempb5
        mod_udb = dist*tempb6
        result1db = dist*3.0d0*tempb6
        k = point%conn(i, r)
        pr = point%prim(4, k)
        rho = point%prim(1, k)
        arg1 = pr/rho
        CALL POPREAL8(result1)
        IF (arg1 .EQ. 0.0) THEN
          arg1b = 0.0
        ELSE
          arg1b = result1b/(2.D0*DSQRT(arg1))
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(result1d)
          arg1db = 0.0_8
        ELSE
          rhod = pointd%prim(1, k)
          prd = pointd%prim(4, k)
          arg1d = (prd*rho-pr*rhod)/rho**2
          CALL POPREAL8(result1d)
          temp0 = DSQRT(arg1)
          tempb3 = result1db/(2.d0*temp0)
          arg1db = tempb3
          IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb3/(temp0*&
&             2.D0*DSQRT(arg1))
        END IF
        tempb2 = arg1db/rho**2
        prb = arg1b/rho - rhod*tempb2
        rhob = (prd-(prd*rho-pr*rhod)*2/rho)*tempb2 - pr*arg1b/rho**2
        prdb = rho*tempb2
        rhodb = -(pr*tempb2)
        u1 = point%prim(2, k)
        u2 = point%prim(3, k)
        arg1 = u1*u1 + u2*u2
        CALL POPREAL8(mod_u)
        IF (arg1 .EQ. 0.0) THEN
          arg1b = 0.0
        ELSE
          arg1b = mod_ub/(2.D0*DSQRT(arg1))
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(mod_ud)
          arg1db = 0.0_8
        ELSE
          u1d = pointd%prim(2, k)
          u2d = pointd%prim(3, k)
          arg1d = u1d*u1 + u1*u1d + u2d*u2 + u2*u2d
          CALL POPREAL8(mod_ud)
          temp = DSQRT(arg1)
          tempb1 = mod_udb/(2.d0*temp)
          arg1db = tempb1
          IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb1/(temp*&
&             2.D0*DSQRT(arg1))
        END IF
        u1b = 2*u1d*arg1db + 2*u1*arg1b
        u2b = 2*u2d*arg1db + 2*u2*arg1b
        u1db = 2*u1*arg1db
        u2db = 2*u2*arg1db
        y_i = point%y(i)
        y_k = point%y(k)
        x_i = point%x(i)
        x_k = point%x(k)
        CALL POPREAL8(dist)
        IF (dist .EQ. 0.0) THEN
          distb = 0.0
        ELSE
          distb = distb/(2.D0*DSQRT(dist))
        END IF
        CALL POPREAL8(dist)
        tempb = 2*(x_k-x_i)*distb
        tempb0 = 2*(y_k-y_i)*distb
        x_kb = tempb
        x_ib = -tempb
        y_kb = tempb0
        y_ib = -tempb0
        pointb%y(k) = pointb%y(k) + y_kb
        pointb%x(k) = pointb%x(k) + x_kb
        pointb%y(i) = pointb%y(i) + y_ib
        pointb%x(i) = pointb%x(i) + x_ib
        pointb%prim(4, k) = pointb%prim(4, k) + prb
        CALL POPREAL8(prd)
        pointdb%prim(4, k) = pointdb%prim(4, k) + prdb
        pointb%prim(3, k) = pointb%prim(3, k) + u2b
        CALL POPREAL8(u2d)
        pointdb%prim(3, k) = pointdb%prim(3, k) + u2db
        pointb%prim(2, k) = pointb%prim(2, k) + u1b
        CALL POPREAL8(u1d)
        pointdb%prim(2, k) = pointdb%prim(2, k) + u1db
        pointb%prim(1, k) = pointb%prim(1, k) + rhob
        CALL POPREAL8(rhod)
        pointdb%prim(1, k) = pointdb%prim(1, k) + rhodb
      END DO
    END DO
  END SUBROUTINE FUNC_DELTA_D_B

!  Differentiation of func_delta in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: point.delta
!   with respect to varying inputs: point.prim point.delta
!	This subroutine computes the delta_t (local time step) at a given point ..
  SUBROUTINE FUNC_DELTA_D()
    IMPLICIT NONE
    INTEGER :: i, k, r
    REAL*8 :: delta_t
    REAL*8 :: delta_td
    REAL*8 :: min_dist
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: u1, u2, rho, pr, mod_u
    REAL*8 :: u1d, u2d, rhod, prd, mod_ud
    REAL*8 :: dist
    REAL*8 :: min_delt
    REAL*8 :: min_deltd
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1d
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    DO i=1,local_points
      min_delt = 1.0d0
      min_deltd = 0.0_8
      DO r=1,point%nbhs(i)
        k = point%conn(i, r)
        rhod = pointd%prim(1, k)
        rho = point%prim(1, k)
        u1d = pointd%prim(2, k)
        u1 = point%prim(2, k)
        u2d = pointd%prim(3, k)
        u2 = point%prim(3, k)
        prd = pointd%prim(4, k)
        pr = point%prim(4, k)
        x_i = point%x(i)
        y_i = point%y(i)
        x_k = point%x(k)
        y_k = point%y(k)
        dist = (x_k-x_i)*(x_k-x_i) + (y_k-y_i)*(y_k-y_i)
        dist = DSQRT(dist)
        arg1d = u1d*u1 + u1*u1d + u2d*u2 + u2*u2d
        arg1 = u1*u1 + u2*u2
        IF (arg1 .EQ. 0.0) THEN
          mod_ud = 0.0_8
        ELSE
          mod_ud = arg1d/(2.d0*DSQRT(arg1))
        END IF
        mod_u = DSQRT(arg1)
        arg1d = (prd*rho-pr*rhod)/rho**2
        arg1 = pr/rho
        IF (arg1 .EQ. 0.0) THEN
          result1d = 0.d0
        ELSE
          result1d = arg1d/(2.d0*DSQRT(arg1))
        END IF
        result1 = DSQRT(arg1)
        delta_td = -(dist*(mod_ud+3.0d0*result1d)/(mod_u+3.0d0*result1)&
&         **2)
        delta_t = dist/(mod_u+3.0d0*result1)
        delta_td = cfl*delta_td
        delta_t = cfl*delta_t
        IF (min_delt .GT. delta_t) THEN
          min_deltd = delta_td
          min_delt = delta_t
        END IF
      END DO
      pointd%delta(i) = min_deltd
      point%delta(i) = min_delt
    END DO
  END SUBROUTINE FUNC_DELTA_D

!	This subroutine computes the delta_t (local time step) at a given point ..
  SUBROUTINE FUNC_DELTA()
    IMPLICIT NONE
    INTEGER :: i, k, r
    REAL*8 :: delta_t
    REAL*8 :: min_dist
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: u1, u2, rho, pr, mod_u
    REAL*8 :: dist
    REAL*8 :: min_delt
    INTRINSIC DSQRT
    REAL*8 :: arg1
    DOUBLE PRECISION :: result1
    DO i=1,local_points
      min_delt = 1.0d0
      DO r=1,point%nbhs(i)
        k = point%conn(i, r)
        rho = point%prim(1, k)
        u1 = point%prim(2, k)
        u2 = point%prim(3, k)
        pr = point%prim(4, k)
        x_i = point%x(i)
        y_i = point%y(i)
        x_k = point%x(k)
        y_k = point%y(k)
        dist = (x_k-x_i)*(x_k-x_i) + (y_k-y_i)*(y_k-y_i)
        dist = DSQRT(dist)
        arg1 = u1*u1 + u2*u2
        mod_u = DSQRT(arg1)
        arg1 = pr/rho
        result1 = DSQRT(arg1)
        delta_t = dist/(mod_u+3.0d0*result1)
        delta_t = cfl*delta_t
        IF (min_delt .GT. delta_t) min_delt = delta_t
      END DO
      point%delta(i) = min_delt
    END DO
  END SUBROUTINE FUNC_DELTA

!  Differentiation of conserved_vector_ubar_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: primd prim ubard nx ny ubar
!   with respect to varying inputs: primd prim ubard nx ny ubar
!  Differentiation of conserved_vector_ubar in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: ubar
!   with respect to varying inputs: q_inf prim ubar
  SUBROUTINE CONSERVED_VECTOR_UBAR_D_B(prim, primb, primd, primdb, ubar&
&   , ubarb, ubard, ubardb, nx, nxb, ny, nyb)
    IMPLICIT NONE
    REAL*8 :: u1_inf, u2_inf, u1_inf_rot, u2_inf_rot, e_inf
    REAL*8 :: u1_inf_rotb, u2_inf_rotb, e_infb
    REAL*8 :: u1_infd, u2_infd, u1_inf_rotd, u2_inf_rotd, e_infd
    REAL*8 :: u1_inf_rotdb, u2_inf_rotdb, e_infdb
    REAL*8 :: u1, u2, pr, rho, u1_rot, u2_rot, e
    REAL*8 :: u1b, u2b, prb, rhob, u1_rotb, u2_rotb, eb
    REAL*8 :: u1d, u2d, prd, rhod, u1_rotd, u2_rotd, ed
    REAL*8 :: u1db, u2db, prdb, rhodb, u1_rotdb, u2_rotdb, edb
    REAL*8 :: beta, s2, b2_inf, a2n_inf
    REAL*8 :: betab, s2b, b2_infb, a2n_infb
    REAL*8 :: betad, s2d, b2_infd, a2n_infd
    REAL*8 :: betadb, s2db, b2_infdb, a2n_infdb
    REAL*8 :: b2, a2p, temp1, temp2
    REAL*8 :: b2b, a2pb, temp1b, temp2b
    REAL*8 :: b2d, a2pd, temp1d, temp2d
    REAL*8 :: b2db, a2pdb, temp1db, temp2db
    REAL*8 :: ubar(4), prim(4)
    REAL*8 :: ubarb(4), primb(4)
    REAL*8 :: ubard(4), primd(4)
    REAL*8 :: ubardb(4), primdb(4)
    REAL*8 :: nx, ny, tx, ty
    REAL*8 :: nxb, nyb, txb, tyb
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: result1db
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    REAL*8 :: result10
    REAL*8 :: result10b
    REAL*8 :: result10d
    REAL*8 :: result10db
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    INTRINSIC EXP
    REAL*8 :: temp
    REAL*8 :: temp0
    REAL*8 :: temp3
    REAL*8 :: tempb
    REAL*8 :: tempb0
    REAL*8 :: tempb1
    REAL*8 :: tempb2
    REAL*8 :: tempb3
    REAL*8 :: temp4
    REAL*8 :: tempb4
    REAL*8 :: temp5
    REAL*8 :: tempb5
    REAL*8 :: temp6
    REAL*8 :: temp7
    REAL*8 :: temp8
    REAL*8 :: temp9
    REAL*8 :: temp10
    REAL*8 :: tempb6
    REAL*8 :: tempb7
    REAL*8 :: tempb8
    REAL*8 :: tempb9
    REAL*8 :: tempb10
    REAL*8 :: tempb11
    REAL*8 :: tempb12
    REAL*8 :: tempb13
    REAL*8 :: tempb14
    REAL*8 :: tempb15
    REAL*8 :: tempb16
    REAL*8 :: tempb17
    REAL*8 :: tempb18
    REAL*8 :: tempb19
    REAL*8 :: tempb20
    REAL*8 :: tempb21
    REAL*8 :: tempb22
    REAL*8 :: tempb23
    INTEGER :: branch
    u1_infd = q_infd(2)
    u1_inf = q_inf(2)
    u2_infd = q_infd(3)
    u2_inf = q_inf(3)
    tx = ny
    ty = -nx
    u1_inf_rotd = tx*u1_infd + ty*u2_infd
    u1_inf_rot = u1_inf*tx + u2_inf*ty
    u2_inf_rotd = nx*u1_infd + ny*u2_infd
    u2_inf_rot = u1_inf*nx + u2_inf*ny
    temp1d = u1_inf_rotd*u1_inf_rot + u1_inf_rot*u1_inf_rotd + &
&     u2_inf_rotd*u2_inf_rot + u2_inf_rot*u2_inf_rotd
    temp1 = u1_inf_rot*u1_inf_rot + u2_inf_rot*u2_inf_rot
    e_infd = 0.5d0*temp1d
    e_inf = pr_inf/(rho_inf*(gamma-1.0d0)) + 0.5d0*temp1
    beta = 0.5d0*rho_inf/pr_inf
    result1 = DSQRT(beta)
    s2d = result1*u2_inf_rotd
    s2 = u2_inf_rot*result1
    arg1 = pi*beta
    CALL PUSHREAL8(result1)
    result1 = DSQRT(arg1)
    b2_infd = (-((s2d*s2+s2*s2d)*DEXP(-(s2*s2))))/(2.0d0*result1)
    b2_inf = DEXP(-(s2*s2))/(2.0d0*result1)
!result1d = DERF_D(s2, s2d, result1)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    CALL PUSHREAL8(result1)
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2n_infd = -(0.5d0*result1d)
    a2n_inf = 0.5d0*(1.0d0-result1)
    rhod = primd(1)
    rho = prim(1)
    u1d = primd(2)
    u1 = prim(2)
    u2d = primd(3)
    u2 = prim(3)
    prd = primd(4)
    pr = prim(4)
    u1_rotd = tx*u1d + ty*u2d
    u1_rot = u1*tx + u2*ty
    u2_rotd = nx*u1d + ny*u2d
    u2_rot = u1*nx + u2*ny
    temp1d = u1_rotd*u1_rot + u1_rot*u1_rotd + u2_rotd*u2_rot + u2_rot*&
&     u2_rotd
    temp1 = u1_rot*u1_rot + u2_rot*u2_rot
    ed = (prd*rho*(gamma-1.0d0)-pr*(gamma-1.0d0)*rhod)/(rho*(gamma-1.0d0&
&     ))**2 + 0.5d0*temp1d
    e = pr/(rho*(gamma-1.0d0)) + 0.5d0*temp1
    betad = (rhod*2.0d0*pr-rho*2.0d0*prd)/(2.0d0*pr)**2
    beta = rho/(2.0d0*pr)
    IF (beta .EQ. 0.0) THEN
      CALL PUSHCONTROL1B(0)
      result10d = 0.0_8
    ELSE
      result10d = betad/(2.0*SQRT(beta))
      CALL PUSHCONTROL1B(1)
    END IF
    result10 = SQRT(beta)
    CALL PUSHREAL8(s2d)
    s2d = u2_rotd*result10 + u2_rot*result10d
    s2 = u2_rot*result10
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      CALL PUSHREAL8(result10d)
      result10d = 0.0_8
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result10d)
      result10d = arg1d/(2.0*SQRT(arg1))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result10)
    result10 = SQRT(arg1)
    b2d = (-((s2d*s2+s2*s2d)*EXP(-(s2*s2))*2.0d0*result10)-EXP(-(s2*s2))&
&     *2.0d0*result10d)/(2.0d0*result10)**2
    b2 = EXP(-(s2*s2))/(2.0d0*result10)
!result1d = DERF_D(s2, s2d, result1)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2pd = 0.5d0*result1d
    a2p = 0.5d0*(1.0d0+result1)
    temp1b = ubarb(4)
    temp2b = ubarb(4)
    ubarb(4) = 0.0_8
    temp1db = ubardb(4)
    temp2db = ubardb(4)
    ubardb(4) = 0.0_8
    tempb6 = 0.5d0*b2*temp2b
    eb = (rhod*a2p+rho*a2pd)*temp2db + rho*a2p*temp2b
    b2b = 0.5d0*rho*u2_rot*temp2b
    tempb7 = e*temp2db
    a2pb = rhod*tempb7 + ed*rho*temp2db + e*rho*temp2b
    tempb9 = 0.5d0*temp2db
    tempb8 = b2*tempb9
    rhob = a2pd*tempb7 + ed*a2p*temp2db + u2_rotd*tempb8 + b2d*u2_rot*&
&     tempb9 + u2_rot*tempb6 + e*a2p*temp2b
    edb = rho*a2p*temp2db
    tempb14 = -(rho_inf*0.5d0*temp1b)
    a2n_infb = rho_inf*e_inf*temp1b
    tempb15 = rho_inf*temp1db
    e_infb = a2n_infd*tempb15 + rho_inf*a2n_inf*temp1b
    tempb16 = -(rho_inf*0.5d0*temp1db)
    e_infdb = a2n_inf*tempb15
    temp1b = ubarb(3)
    temp2b = ubarb(3)
    ubarb(3) = 0.0_8
    temp1db = ubardb(3)
    temp2db = ubardb(3)
    ubardb(3) = 0.0_8
    tempb12 = rho*temp2b
    tempb10 = rhod*temp2db
    b2b = b2b + tempb12 + tempb10 + (rhod*u2_rot+rho*u2_rotd)*tempb9
    tempb11 = rho*temp2db
    u2_rotb = rhod*tempb8 + b2d*rho*tempb9 + a2p*tempb10 + a2pd*tempb11 &
&     + a2p*tempb12 + rho*tempb6
    a2pdb = u2_rot*tempb11 + rho*u1_rot*ubardb(2) + rho*tempb7
    u2_rotdb = a2p*tempb11 + rho*tempb8
    b2db = tempb11 + rho*u2_rot*tempb9
    a2pb = a2pb + u2_rot*tempb10 + u2_rotd*tempb11 + (rhod*u1_rot+rho*&
&     u1_rotd)*ubardb(2) + rho*u1_rot*ubarb(2) + u2_rot*tempb12
    tempb18 = rho_inf*temp1b
    b2_infb = u2_inf_rotd*tempb16 - tempb18 + u2_inf_rot*tempb14
    tempb17 = rho_inf*temp1db
    u2_inf_rotb = b2_infd*tempb16 + a2n_infd*tempb17 + a2n_inf*tempb18 +&
&     b2_inf*tempb14
    a2n_infb = a2n_infb + u2_inf_rot*tempb18 + rho_inf*u1_inf_rot*ubarb(&
&     2) + u2_inf_rotd*tempb17 + e_infd*tempb15
    u2_inf_rotdb = a2n_inf*tempb17 + b2_inf*tempb16
    b2_infdb = u2_inf_rot*tempb16 - tempb17
    tempb19 = rho_inf*ubardb(2)
    u1_inf_rotb = a2n_infd*tempb19 + rho_inf*a2n_inf*ubarb(2)
    tempb13 = a2p*ubardb(2)
    rhob = rhob + (u2_rotd*a2p+u2_rot*a2pd+b2d)*temp2db + u1_rotd*&
&     tempb13 + a2pd*u1_rot*ubardb(2) + a2p*u1_rot*ubarb(2) + (u2_rot*&
&     a2p+b2)*temp2b
    u1_rotb = rhod*tempb13 + a2pd*rho*ubardb(2) + a2p*rho*ubarb(2)
    ubarb(2) = 0.0_8
    u1_inf_rotdb = a2n_inf*tempb19
    a2n_infb = a2n_infb + rho_inf*ubarb(1) + u1_inf_rotd*tempb19
    u1_rotdb = rho*tempb13
    ubardb(2) = 0.0_8
    rhodb = (u2_rot*a2p+b2)*temp2db + a2p*ubardb(1) + u1_rot*tempb13 + &
&     u2_rot*tempb8 + a2p*tempb7
    a2n_infdb = u2_inf_rot*tempb17 + rho_inf*ubardb(1) + u1_inf_rot*&
&     tempb19 + e_inf*tempb15
    rhob = rhob + a2pd*ubardb(1) + a2p*ubarb(1)
    a2pb = a2pb + rhod*ubardb(1) + rho*ubarb(1)
    ubarb(1) = 0.0_8
    a2pdb = a2pdb + rho*ubardb(1)
    ubardb(1) = 0.0_8
    result1b = 0.5d0*a2pb
    result1db = 0.5d0*a2pdb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.0_8
    !CALL DERF_B(s2, s2b, result1b)

    s2b = s2b + (2.0d0/dsqrt(pi))*dexp(-s2**2)*result1b

    CALL POPREAL8(s2)
    temp10 = SQRT(pi)
    tempb20 = b2b/(2.0d0*result10)
    temp9 = 2.0d0**2*result10**2
    tempb21 = b2db/temp9
    temp8 = EXP(-(s2**2))
    temp6 = s2d*s2 + s2*s2d
    tempb23 = -(2.0d0*temp8*tempb21)
    tempb22 = result10*tempb23
    s2b = s2b + (EXP(-(s2**2))*result10d*2.0d0*2*s2+EXP(-(s2**2))*temp6*&
&     result10*2.0d0*2*s2)*tempb21 - EXP(-(s2**2))*2*s2*tempb20 + 2*s2d*&
&     tempb22 - DEXP(-(s2**2))*s2d*2.d0*2*s2*result1db/temp10
    s2db = 2*s2*tempb22 + DEXP(-(s2**2))*2.d0*result1db/temp10
    temp7 = EXP(-(s2**2))
    result10b = temp6*tempb23 - 2.0d0**2*(-(2.0d0*(temp6*result10*temp8)&
&     )-2.0d0*(temp7*result10d))*2*result10*tempb21/temp9 - EXP(-(s2**2)&
&     )*tempb20/result10
    result10db = -(2.0d0*temp7*tempb21)
    CALL POPREAL8(result10)
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result10b/(2.0*SQRT(arg1))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result10d)
      arg1db = 0.0_8
    ELSE
      CALL POPREAL8(result10d)
      temp5 = SQRT(arg1)
      tempb5 = result10db/(2.0*temp5)
      arg1db = tempb5
      IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb5/(2.0*temp5**2&
&         )
    END IF
    result10b = u2_rotd*s2db + u2_rot*s2b
    IF (beta .EQ. 0.0) THEN
      betab = pi*arg1b
    ELSE
      betab = result10b/(2.0*SQRT(beta)) + pi*arg1b
    END IF
    betadb = pi*arg1db
    u2_rotb = u2_rotb + result10d*s2db + result10*s2b
    CALL POPREAL8(s2d)
    u2_rotdb = u2_rotdb + result10*s2db
    result10db = u2_rot*s2db
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      temp4 = SQRT(beta)
      tempb4 = result10db/(2.0*temp4)
      betadb = betadb + tempb4
      IF (.NOT.beta .EQ. 0.0) betab = betab - betad*tempb4/(2.0*temp4**2&
&         )
    END IF
    temp0 = (gamma-1.0d0)**2*rho**2
    tempb1 = edb/temp0
    tempb2 = eb/((gamma-1.0d0)*rho)
    temp3 = 2.0d0**2*pr**2
    tempb0 = betadb/temp3
    tempb = betab/(2.0d0*pr)
    rhob = rhob + ((gamma-1.0d0)*prd-(gamma-1.0d0)**2*((gamma-1.0d0)*(&
&     prd*rho)-(gamma-1.0d0)*(pr*rhod))*2*rho/temp0)*tempb1 - 2.0d0*prd*&
&     tempb0 - pr*tempb2/rho + tempb
    prb = (2.0d0*rhod-2.0d0**2*(2.0d0*(rhod*pr)-2.0d0*(rho*prd))*2*pr/&
&     temp3)*tempb0 - (gamma-1.0d0)*rhod*tempb1 + tempb2 - rho*tempb/pr
    rhodb = rhodb + 2.0d0*pr*tempb0 - (gamma-1.0d0)*pr*tempb1
    prdb = (gamma-1.0d0)*rho*tempb1 - 2.0d0*rho*tempb0
    temp1b = 0.5d0*eb
    temp1db = 0.5d0*edb
    u1_rotb = u1_rotb + 2*u1_rotd*temp1db + 2*u1_rot*temp1b
    u2_rotb = u2_rotb + 2*u2_rotd*temp1db + 2*u2_rot*temp1b
    u1_rotdb = u1_rotdb + 2*u1_rot*temp1db
    u2_rotdb = u2_rotdb + 2*u2_rot*temp1db
    u1b = tx*u1_rotb + nx*u2_rotb
    u2b = ty*u1_rotb + ny*u2_rotb
    u1db = tx*u1_rotdb + nx*u2_rotdb
    u2db = ty*u1_rotdb + ny*u2_rotdb
    primb(4) = primb(4) + prb
    primdb(4) = primdb(4) + prdb
    primb(3) = primb(3) + u2b
    primdb(3) = primdb(3) + u2db
    primb(2) = primb(2) + u1b
    primdb(2) = primdb(2) + u1db
    primb(1) = primb(1) + rhob
    primdb(1) = primdb(1) + rhodb
    result1b = -(0.5d0*a2n_infb)
    result1db = -(0.5d0*a2n_infdb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL POPREAL8(result1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.0_8
    !CALL DERF_B(s2, s2b, result1b)

    s2b = s2b + (2.0d0/dsqrt(pi))*dexp(-s2**2)*result1b

    CALL POPREAL8(s2)
    CALL POPREAL8(result1)
    temp = SQRT(pi)
    tempb3 = -(DEXP(-(s2**2))*b2_infdb/(2.0d0*result1))
    s2b = s2b + DEXP(-(s2**2))*(s2d*s2+s2*s2d)*2*s2*b2_infdb/(2.0d0*&
&     result1) - DEXP(-(s2**2))*2*s2*b2_infb/(2.0d0*result1) + 2*s2d*&
&     tempb3 - DEXP(-(s2**2))*s2d*2.d0*2*s2*result1db/temp
    s2db = 2*s2*tempb3 + DEXP(-(s2**2))*2.d0*result1db/temp
    CALL POPREAL8(result1)
    temp1b = 0.5d0*e_infb
    temp1db = 0.5d0*e_infdb
    u2_inf_rotb = u2_inf_rotb + 2*u2_inf_rot*temp1b + 2*u2_inf_rotd*&
&     temp1db + result1*s2b
    u2_inf_rotdb = u2_inf_rotdb + 2*u2_inf_rot*temp1db + result1*s2db
    u1_inf_rotb = u1_inf_rotb + 2*u1_inf_rotd*temp1db + 2*u1_inf_rot*&
&     temp1b
    u1_inf_rotdb = u1_inf_rotdb + 2*u1_inf_rot*temp1db
    txb = u1d*u1_rotdb + u1_infd*u1_inf_rotdb + u1_inf*u1_inf_rotb + u1*&
&     u1_rotb
    nyb = nyb + u2d*u2_rotdb + u2_infd*u2_inf_rotdb + txb + u2_inf*&
&     u2_inf_rotb + u2*u2_rotb
    tyb = u2d*u1_rotdb + u2_infd*u1_inf_rotdb + u2_inf*u1_inf_rotb + u2*&
&     u1_rotb
    nxb = nxb + u1d*u2_rotdb + u1_infd*u2_inf_rotdb - tyb + u1_inf*&
&     u2_inf_rotb + u1*u2_rotb
  END SUBROUTINE CONSERVED_VECTOR_UBAR_D_B

!  Differentiation of conserved_vector_ubar in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: ubar
!   with respect to varying inputs: q_inf prim ubar
  SUBROUTINE CONSERVED_VECTOR_UBAR_D(prim, primd, ubar, ubard, nx, ny)
    IMPLICIT NONE
    REAL*8 :: u1_inf, u2_inf, u1_inf_rot, u2_inf_rot, e_inf
    REAL*8 :: u1_infd, u2_infd, u1_inf_rotd, u2_inf_rotd, e_infd
    REAL*8 :: u1, u2, pr, rho, u1_rot, u2_rot, e
    REAL*8 :: u1d, u2d, prd, rhod, u1_rotd, u2_rotd, ed
    REAL*8 :: beta, s2, b2_inf, a2n_inf
    REAL*8 :: betad, s2d, b2_infd, a2n_infd
    REAL*8 :: b2, a2p, temp1, temp2
    REAL*8 :: b2d, a2pd, temp1d, temp2d
    REAL*8 :: ubar(4), prim(4)
    REAL*8 :: ubard(4), primd(4)
    REAL*8 :: nx, ny, tx, ty
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    REAL*8 :: result10
    REAL*8 :: result10d
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    INTRINSIC EXP
    u1_infd = q_infd(2)
    u1_inf = q_inf(2)
    u2_infd = q_infd(3)
    u2_inf = q_inf(3)
    tx = ny
    ty = -nx
    u1_inf_rotd = tx*u1_infd + ty*u2_infd
    u1_inf_rot = u1_inf*tx + u2_inf*ty
    u2_inf_rotd = nx*u1_infd + ny*u2_infd
    u2_inf_rot = u1_inf*nx + u2_inf*ny
    temp1d = u1_inf_rotd*u1_inf_rot + u1_inf_rot*u1_inf_rotd + &
&     u2_inf_rotd*u2_inf_rot + u2_inf_rot*u2_inf_rotd
    temp1 = u1_inf_rot*u1_inf_rot + u2_inf_rot*u2_inf_rot
    e_infd = 0.5d0*temp1d
    e_inf = pr_inf/(rho_inf*(gamma-1.0d0)) + 0.5d0*temp1
    beta = 0.5d0*rho_inf/pr_inf
    result1 = DSQRT(beta)
    s2d = result1*u2_inf_rotd
    s2 = u2_inf_rot*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2_infd = (-((s2d*s2+s2*s2d)*DEXP(-(s2*s2))))/(2.0d0*result1)
    b2_inf = DEXP(-(s2*s2))/(2.0d0*result1)
!result1d = DERF_D(s2, s2d, result1)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    result1 = DERF(s2)
    a2n_infd = -(0.5d0*result1d)
    a2n_inf = 0.5d0*(1.0d0-result1)
    rhod = primd(1)
    rho = prim(1)
    u1d = primd(2)
    u1 = prim(2)
    u2d = primd(3)
    u2 = prim(3)
    prd = primd(4)
    pr = prim(4)
    u1_rotd = tx*u1d + ty*u2d
    u1_rot = u1*tx + u2*ty
    u2_rotd = nx*u1d + ny*u2d
    u2_rot = u1*nx + u2*ny
    temp1d = u1_rotd*u1_rot + u1_rot*u1_rotd + u2_rotd*u2_rot + u2_rot*&
&     u2_rotd
    temp1 = u1_rot*u1_rot + u2_rot*u2_rot
    ed = (prd*rho*(gamma-1.0d0)-pr*(gamma-1.0d0)*rhod)/(rho*(gamma-1.0d0&
&     ))**2 + 0.5d0*temp1d
    e = pr/(rho*(gamma-1.0d0)) + 0.5d0*temp1
    betad = (rhod*2.0d0*pr-rho*2.0d0*prd)/(2.0d0*pr)**2
    beta = rho/(2.0d0*pr)
    IF (beta .EQ. 0.0) THEN
      result10d = 0.0_8
    ELSE
      result10d = betad/(2.0*SQRT(beta))
    END IF
    result10 = SQRT(beta)
    s2d = u2_rotd*result10 + u2_rot*result10d
    s2 = u2_rot*result10
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      result10d = 0.0_8
    ELSE
      result10d = arg1d/(2.0*SQRT(arg1))
    END IF
    result10 = SQRT(arg1)
    b2d = (-((s2d*s2+s2*s2d)*EXP(-(s2*s2))*2.0d0*result10)-EXP(-(s2*s2))&
&     *2.0d0*result10d)/(2.0d0*result10)**2
    b2 = EXP(-(s2*s2))/(2.0d0*result10)
!result1d = DERF_D(s2, s2d, result1)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    result1 = DERF(s2)
    a2pd = 0.5d0*result1d
    a2p = 0.5d0*(1.0d0+result1)
    ubard(1) = rho_inf*a2n_infd + rhod*a2p + rho*a2pd
    ubar(1) = rho_inf*a2n_inf + rho*a2p
    ubard(2) = rho_inf*(u1_inf_rotd*a2n_inf+u1_inf_rot*a2n_infd) + (rhod&
&     *u1_rot+rho*u1_rotd)*a2p + rho*u1_rot*a2pd
    ubar(2) = rho_inf*u1_inf_rot*a2n_inf + rho*u1_rot*a2p
    temp1d = rho_inf*(u2_inf_rotd*a2n_inf+u2_inf_rot*a2n_infd-b2_infd)
    temp1 = rho_inf*(u2_inf_rot*a2n_inf-b2_inf)
    temp2d = rhod*(u2_rot*a2p+b2) + rho*(u2_rotd*a2p+u2_rot*a2pd+b2d)
    temp2 = rho*(u2_rot*a2p+b2)
    ubard(3) = temp1d + temp2d
    ubar(3) = temp1 + temp2
    temp1d = rho_inf*(a2n_infd*e_inf+a2n_inf*e_infd) - 0.5d0*rho_inf*(&
&     u2_inf_rotd*b2_inf+u2_inf_rot*b2_infd)
    temp1 = rho_inf*a2n_inf*e_inf - 0.5d0*rho_inf*u2_inf_rot*b2_inf
    temp2d = (rhod*a2p+rho*a2pd)*e + rho*a2p*ed + 0.5d0*((rhod*u2_rot+&
&     rho*u2_rotd)*b2+rho*u2_rot*b2d)
    temp2 = rho*a2p*e + 0.5d0*rho*u2_rot*b2
    ubard(4) = temp1d + temp2d
    ubar(4) = temp1 + temp2
  END SUBROUTINE CONSERVED_VECTOR_UBAR_D

  SUBROUTINE CONSERVED_VECTOR_UBAR(prim, ubar, nx, ny)
    IMPLICIT NONE
    REAL*8 :: u1_inf, u2_inf, u1_inf_rot, u2_inf_rot, e_inf
    REAL*8 :: u1, u2, pr, rho, u1_rot, u2_rot, e
    REAL*8 :: beta, s2, b2_inf, a2n_inf
    REAL*8 :: b2, a2p, temp1, temp2
    REAL*8 :: ubar(4), prim(4)
    REAL*8 :: nx, ny, tx, ty
    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    REAL*8 :: result10
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    INTRINSIC EXP
    u1_inf = q_inf(2)
    u2_inf = q_inf(3)
    tx = ny
    ty = -nx
    u1_inf_rot = u1_inf*tx + u2_inf*ty
    u2_inf_rot = u1_inf*nx + u2_inf*ny
    temp1 = u1_inf_rot*u1_inf_rot + u2_inf_rot*u2_inf_rot
    e_inf = pr_inf/(rho_inf*(gamma-1.0d0)) + 0.5d0*temp1
    beta = 0.5d0*rho_inf/pr_inf
    result1 = DSQRT(beta)
    s2 = u2_inf_rot*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2_inf = DEXP(-(s2*s2))/(2.0d0*result1)
    result1 = DERF(s2)
    a2n_inf = 0.5d0*(1.0d0-result1)
    rho = prim(1)
    u1 = prim(2)
    u2 = prim(3)
    pr = prim(4)
    u1_rot = u1*tx + u2*ty
    u2_rot = u1*nx + u2*ny
    temp1 = u1_rot*u1_rot + u2_rot*u2_rot
    e = pr/(rho*(gamma-1.0d0)) + 0.5d0*temp1
    beta = rho/(2.0d0*pr)
    result10 = SQRT(beta)
    s2 = u2_rot*result10
    arg1 = pi*beta
    result10 = SQRT(arg1)
    b2 = EXP(-(s2*s2))/(2.0d0*result10)
    result1 = DERF(s2)
    a2p = 0.5d0*(1.0d0+result1)
    ubar(1) = rho_inf*a2n_inf + rho*a2p
    ubar(2) = rho_inf*u1_inf_rot*a2n_inf + rho*u1_rot*a2p
    temp1 = rho_inf*(u2_inf_rot*a2n_inf-b2_inf)
    temp2 = rho*(u2_rot*a2p+b2)
    ubar(3) = temp1 + temp2
    temp1 = rho_inf*a2n_inf*e_inf - 0.5d0*rho_inf*u2_inf_rot*b2_inf
    temp2 = rho*a2p*e + 0.5d0*rho*u2_rot*b2
    ubar(4) = temp1 + temp2
  END SUBROUTINE CONSERVED_VECTOR_UBAR

END MODULE STATE_UPDATE_MOD_DIFF_DIFF

