module q_lskum_mod

        USE FPI_SOLVER_MOD_DIFF
        use q_variables_mod
        use flux_residual_mod
        use state_update_mod
        use DATA_STRUCTURE_MOD_DIFF
        use device_DATA_STRUCTURE_MOD_DIFF
        use point_normals_mod    
        use generate_connectivity_mod
        use post_processing_mod
        use stagnation_values_mod
        use cudafor
        use ieee_arithmetic


        real*8 :: temp2
        real*8, device :: temp
        real*8, device, allocatable :: cost_func_d(:)
        real*8, device, allocatable :: sum_res_sqr_d(:)

contains

        subroutine q_lskum(time)

                implicit none

                ! Grid and block dim
                type(dim3) :: grid , tBlock
                integer :: istat
                integer :: i
                integer :: rk
                real*8 :: start, finish, time


                INTEGER :: i0
                INTEGER :: t, r, ijk, k
                INTEGER :: ii1
                integer :: pflag = 1, iflag = 1
                real :: SF
                !    Declaration for running the revolve algorithm ...
                !    Parameters ..
                !
                    REAL*8 :: TAKSHT,ADVAN,FSTURN,YUTURN
                    PARAMETER (TAKSHT=1,ADVAN=2,FSTURN=3,YUTURN=4)
                    REAL*8 :: RESTRE,TRMATE,ERROR
                    PARAMETER (RESTRE=5,TRMATE=6,ERROR=7)
                !
                !  .. Local Scalars ..                                                       
                !                                                                               
                    INTEGER :: CAPO,CHECK,FINE,INFO,SNAPS,STEPS,WHATDO
                    INTEGER :: OLDCAPO,new_itime, ITIME, ITIMS, ITIM
                ! 
                !     .. External Functions ..                                                  
                !                                                                               
                    INTEGER :: REVOLV, ADJUST, PFS
                    EXTERNAL REVOLV, ADJUST
                !                                                                               
                    intrinsic cpu_time 
                    real*8 :: start_time, end_time

                !

                    real*8, allocatable :: prim_stor(:, :, :), qm_stor(:, :, :, :)
                    real*8, allocatable :: q_stor(:, :, :), dq_stor(:, :, :, :)
                    real*8, allocatable :: fluxres_stor(:, :, :), delta_stor(:, :)
                    real*8, allocatable :: primold_stor(:, :, :), ddq_stor(:, :, :, :)
                    real*8, allocatable :: temp_stor(:, :, :, :)
                !   Allocate store variables

                    allocate( prim_stor(0:chkpts, 4, max_points))
                    allocate( primold_stor(0:chkpts, 4, max_points))
                    allocate( q_stor(0:chkpts, 4, max_points))
                    allocate( fluxres_stor(0:chkpts, 4, max_points))
                    allocate( dq_stor(0:chkpts, 2, 4, max_points))
                    allocate( qm_stor(0:chkpts, 2, 4, max_points))
                    allocate( delta_stor(0:chkpts, max_points))
                    allocate( ddq_stor(0:chkpts, 3, 4, max_points))
                    allocate( temp_stor(0:chkpts, 3, 4, max_points))
                
                !   End of the declaraion for the revolve algorithm ..          
                !
                
                !	Assign the initial conditions for the primitive variables ..
                
                    ITIMS = 1
                    ITIME = max_iters
                    new_itime = ITIME - ITIMS + 1 
                    CAPO = 0
                    STEPS = new_itime
                    FINE = STEPS + CAPO
                    CHECK = -1
                !   SNAPS = ADJUST(STEPS)                                                    
                !
                !   Here SNAPS are the no. of checkpoints assigned ..
                !
                    SNAPS = chkpts
                    INFO = 5


                OPEN(UNIT=301,FILE="residue",FORM="FORMATTED",STATUS="REPLACE",ACTION="WRITE")
                OPEN(UNIT=302,FILE="objective",FORM="FORMATTED",STATUS="REPLACE",ACTION="WRITE")

                call compute_normals()
                call generate_connectivity()
                cost_funcb = 1.0d0
                write(*,*)'%%%%-Normals and connectivity generated-%%%'
                write(*,*)

                write(*,*)'%%%%%%%%%%%%%%%-Setting phi values to 1-%%%%%%%%%%%%%'
                do i=1,max_points
                        point%phi1(:,i) = 1.0d0
                        point%phi2(:,i) = 1.0d0
                enddo

                call cpu_time(start)

                ! Transfer from host device
                call host_to_device()
                
                write(*,*)'%%%%%%%%%-Host to device performed-%%%%%%%%'
                write(*,*)

                call generate_connectivity_x()
                write(*,*)'%%%%-Serial connectivity generated-%%%'

                allocate(sum_res_sqr_d(max_points))
                allocate(cost_func_d(max_points))

                tBlock = dim3 (blockx, blocky, blockz)
                grid = dim3(ceiling(real(max_points)/ tBlock%x), 1, 1)
                
                write(*,*)'%%%%%%%%%%%%%%%-GPU size info-%%%%%%%%%%%%%'
                write(*,*) 'number of threads per block:',blockx*blocky*blockz
                write(*,*) 'grid dimension:',grid
                write(*,*) 'thread block dimension:',tBlock

                write(*,*)
                write(*,*)'%%%%%%%%%%%%%-Iterations begin-%%%%%%%%%%%%'
                write(*,*)

                if(solution_restart == 0) itr = 0

                istat = cudaDeviceSetCacheConfig(cudaFuncCachePreferL1)

                !   The revolve algorithm starts here ..
                !
                !
                    10 CONTINUE
                    OLDCAPO = CAPO
                    WHATDO = REVOLV(CHECK,CAPO,FINE,SNAPS,INFO,SF,PFS)

                IF ((WHATDO.EQ.TAKSHT) .AND. (INFO.GT.1)) THEN  
                    call intermediate_device_to_host()                                 
                    do i=1,max_points
                        delta_stor(check, i) = point%delta(i)
                        do r = 1, 4
                            q_stor(check, r, i) = point%q(r,i)
                            prim_stor(check, r, i) = point%prim(r,i)
                            primold_stor(check, r, i) = point%prim_old(r,i)
                            fluxres_stor(check, r, i) = point%flux_res(r,i)
                            do k = 1, 2
                                dq_stor(check, k, r, i) = point%dq(k , r , i)
                                qm_stor(check, k, r, i) = point%qm(k , r , i)
                            end do
                            do k = 1, 3
                                ddq_stor(check, k, r, i) = point%ddq(k , r , i)
                            end do
                        enddo
                    enddo
                END IF

                IF ((WHATDO.EQ.ADVAN) .AND. (INFO.GT.2)) THEN
                !   WRITE (*,FMT=9010) CAPO
                    do ijk=OLDCAPO, CAPO-1
                        ITIM = ijk+ITIMS
                        ITIM = ITIM + itr
                        if(iflag == 1) then
                            write (*,*)
                            write (*,*) 'prediction of needed forward steps :', PFS
                            write (*,*) 'slowdown factor :', SF
                            write (*,*)
                            iflag = 0
                        end if
                        
                        call eval_timestep<<<grid, tBlock>>>(point_d%x, point_d%nbhs, &
                        & point_d%conn, point_d%delta, point_d%prim, point_d%prim_old)

                        do rk = 1, rks

                                call eval_q_variables<<<grid, tBlock>>>(point_d%prim, point_d%q)

                                call eval_q_derivatives<<<grid, tBlock>>>(point_d%x, point_d%nbhs, &
                                        & point_d%conn, point_d%q, point_d%qm, point_d%dq)

                                call eval_q_double_derivatives<<<grid, tBlock>>>(point_d%x, point_d%nbhs, point_d%conn, &
                                        & point_d%dq, point_d%ddq)

                                if(inner_iterations /= 0) then
                                        do i = 1, inner_iterations

                                                call eval_q_derivatives_inner_loop<<<grid, tBlock>>>(point_d%x, point_d%nbhs, &
                                                        & point_d%conn, point_d%q, point_d%dq, point_d%inner)

                                                call eval_update_innerloop_2<<<grid, tBlock>>>(point_d%dq, point_d%inner)

                                                call eval_dq_derivatives_inner_loop<<<grid, tBlock>>>(point_d%x, point_d%nbhs, &
                                                        & point_d%conn, point_d%q, point_d%dq, point_d%ddq, point_d%inner)

                                                call eval_update_innerloop_3<<<grid, tBlock>>>(point_d%ddq, point_d%inner)
                                                
                                        end do
                                end if

                                call cal_flux_residual<<<grid, tBlock>>>(point_d%x, point_d%nx, &
                                        & point_d%flag, point_d%min_dist, point_d%nbhs, point_d%conn, &
                                        & point_d%xpos_nbhs, point_d%xneg_nbhs, point_d%ypos_nbhs, &
                                        & point_d%yneg_nbhs, point_d%xpos_conn, point_d%xneg_conn,&
                                        & point_d%ypos_conn, point_d%yneg_conn, point_d%prim,  &
                                        & point_d%q, point_d%qm, point_d%dq, point_d%ddq, point_d%flux_res, &
                                        & point_d%phi1, point_d%phi1, point_d%delta)

                                call state_update<<<grid, tBlock>>>(point_d%x, point_d%nx, point_d%flag, &
                                        & point_d%nbhs, point_d%conn, point_d%prim, point_d%prim_old, &
                                        & point_d%delta, point_d%flux_res, sum_res_sqr_d, rk)


                        end do                        

                        call device_to_host()
                        call objective_function_J()

                        istat = cudaGetLastError() 

                        if (istat .ne. 0) then
                                print*, cudaGetErrorString(istat) 
                                stop istat 
                        endif
                        
                        ! Residue norm evaluation
                        
                        temp = 0.0

                        !$cuf kernel do <<< *, * >>>
                        do i = 1, mp_d
                                temp = temp + sum_res_sqr_d(i)
                        end do

                        sum_res_sqr = temp
                        
!                        temp2 = 0.0
!                        do i = 1, mp_d
!                                temp2 = temp2 + cost_func_d(i)
!                        end do
!
!                        cost_func = temp2
!
!                        write(*,*) "Objective Function J:", cost_func
!                        write(302,*) ITIM, cost_func

                        residue = dsqrt(sum_res_sqr)/max_points

                        if (ITIM .le. 2 .and. solution_restart == 0) then
                                res_old = residue
                                residue = 0.0d0
                        else
                                residue = dlog10(residue/res_old)
                        end if
                        if (pflag == 1) then
                            write(*,*) "iterations:", ITIM, "residue:", residue
                            write(301,*) ITIM, residue
                        end if


                        if(ieee_is_nan(residue))exit
        
                        if(mod(ITIM,nsave) == 0) then
                                write(*,*)'%%%%%%%%%%%%%-Saving solution-%%%%%%%%%%%%%'
                                call device_to_host()
                                call print_primal_output()
                        end if
                    end do
                END IF

            !   The below if condition runs the first reverse step.
            !   This requires the initialisation of the adjoint vectors ..
            !
            !
                120 IF ((WHATDO.EQ.FSTURN) .AND. (INFO.GT.2)) THEN
                    !
                    ITIM = CAPO + ITIMS
                    ITIM = ITIM + itr
                    pointb%delta = 0.0_8
                    pointb%prim = 0.0_8
                    pointb%prim_old = 0.0_8
                    pointb%q = 0.0_8
                    pointb%flux_res = 0.0_8
                    pointb%dq = 0.0_8
                    pointb%ddq = 0.0_8
                    pointb%temp = 0.0_8
                    pointb%phi1 = 0.0_8
                    pointb%phi2 = 0.0_8
                    call intermediate_device_to_host() 
                    write(*,*)
                    write(*,*)'%%%%%%%%-Adjoint computations begin-%%%%%%%'
                    write(*,*)
                    pflag = 0
                    CALL FPI_SOLVER_B(ITIM)
                    cost_funcb = 0.0_8
                    write(*,*) pointb%phi1(1,79)
                END IF
            
                !      The below if condition runs the subsequent reverse steps .. 
            !                                                                                                                                                  
                IF ((WHATDO.EQ.YUTURN) .AND. (INFO.GT.2)) THEN
                    ITIM = CAPO + ITIMS
                    ITIM = ITIM + itr
                    CALL FPI_SOLVER_B(ITIM)
                    cost_funcb = 0.0_8
                    write(*,*) pointb%phi1(1,79)
                END IF
            !
            !
            !           The below if condition restores the state vectors 
            !             at the check points ..  
            !                                               

                IF ((WHATDO.EQ.RESTRE) .AND. (INFO.GT.2)) THEN
                !
                        do i=1,max_points
                            point%delta(i) = delta_stor(check, i)
                            do r = 1, 4
                                point%q(r,i) = q_stor(check, r, i)
                                point%prim(r,i) = prim_stor(check, r, i)
                                point%prim_old(r,i) = primold_stor(check, r, i)
                                point%flux_res(r,i) = fluxres_stor(check, r, i)
                                do k = 1, 2
                                    point%dq(k, r, i) = dq_stor(check, k, r, i)
                                    point%qm(k, r, i) = qm_stor(check, k, r, i)
                                end do
                                do k = 1, 3
                                    point%ddq(k , r , i) = ddq_stor(check, k, r, i)
                                end do
                            enddo
                        enddo  
                        call intermediate_host_to_device()
                    END IF
                !
                !
                    IF (WHATDO.EQ.ERROR) THEN
                        WRITE (*,FMT=*) ' irregular termination of treeverse'
                        IF (INFO.EQ.10) THEN
                            WRITE (*,FMT=*) ' number of checkpoints stored exceeds CHEKUP,'
                            WRITE (*,FMT=*) ' increase constant CHEKUP and recompile'
                        END IF
                !
                        IF (INFO.EQ.11) THEN
                            WRITE (*,FMT=*) ' number of checkpoints stored = ', CHECK + 1,' exceeds SNAPS,'
                            WRITE (*,FMT=*) ' ensure SNAPS > 0 and ', 'increase initial FINE'
                        END IF
                
                        IF (INFO.EQ.12) WRITE (*,FMT=*) ' error occurs in NUMFRW'
                        IF (INFO.EQ.13) THEN
                            WRITE (*,FMT=*) ' enhancement of FINE, SNAPS = ', CHECK + 1,'checkpoints stored, increase SNAPS'
                        END IF
                        IF (INFO.EQ.14) THEN
                            WRITE (*,FMT=*) ' number of SNAPS = ',SNAPS, ' exceeds CHEKUP,'
                            WRITE (*,FMT=*) ' increase constant CHEKUP and recompile'
                        END IF
                        IF (INFO.EQ.15) THEN
                            WRITE (*,FMT=*) ' number of reps exceeds REPSUP, '
                            WRITE (*,FMT=*) ' increase constant REPSUP and recompile'
                        END IF
                    END IF
                !                                       
                !
                    IF ((WHATDO.EQ.TRMATE) .OR. (WHATDO.EQ.ERROR)) THEN
                        GO TO 20
                    ELSE
                        GO TO 10
                    END IF
                    20 CONTINUE
                !
                !
                    9000 FORMAT (' takeshot at',I6)
                    9010 FORMAT (' advance to',I7)
                    9020 FORMAT (' firsturn at',I6)
                    9030 FORMAT (' youturn at',I7)
                    9040 FORMAT (' restore at',I7)
                !                                                                                                                                                  
                !                                                                                                                                                  
                !       End of the revolve algorithm .. 

                call device_to_host()

                write(*,*)
                write(*,*)'%%%%%%%%%-Device to host performed-%%%%%%%%'
                write(*,*)

                istat = cudaDeviceSynchronize()
                if (istat .ne. 0) then
                        print*, cudaGetErrorString(istat) 
                        stop istat 
                endif

                call cpu_time(finish)

                time = finish - start

                CLOSE(UNIT=301)
                CLOSE(UNIT=302)
                OPEN(unit=301, file='jderivatives_c.dat', form='FORMATTED', status='REPLACE', action='WRITE')
                DO i=1,max_points
                    WRITE(301,'(4e30.20)') pointb%phi1(1,i), pointb%phi1(2,i), pointb%phi1(3,i), pointb%phi1(4,i)
                END DO
                CLOSE(unit=301)
                
                DO i=max_points,1,-1
                    pointb%phi2(:, i) = 0.0_8
                    pointb%phi1(:, i) = 0.0_8
                END DO
        end subroutine
end module q_lskum_mod
