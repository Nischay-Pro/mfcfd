!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
MODULE WALL_FLUXES_MOD_DIFF
!
!	First written on 14.10.2016
!	updated on Dec 29, 2016
!	updated on 19.08.2017
!	
  USE DATA_STRUCTURE_MOD_DIFF
  USE QUADRANT_FLUXES_MOD_DIFF
  USE SPLIT_FLUXES_MOD_DIFF
  USE Q_VARIABLES_MOD_DIFF
  USE LIMITERS_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of wall_dgx_pos in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: point.x point.y point.nx point.ny
!                point.q point.dq point.qm
!	This subroutine evaluates the wall flux derivative dGs_pos
  SUBROUTINE WALL_DGX_POS_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txd, tyd, nxd, nyd
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_id, y_id, x_kd, y_kd
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxd, delyd, detd, one_by_detd
    REAL*8 :: dels, deln
    REAL*8 :: delsd, delnd
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrd, sum_dely_sqrd, sum_delx_delyd
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: distd, weightsd
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxid(4), minid(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsd, deln_weightsd
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1d
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_id = pointd%x(i)
    x_i = point%x(i)
    y_id = pointd%y(i)
    y_i = point%y(i)
    nxd = pointd%nx(i)
    nx = point%nx(i)
    nyd = pointd%ny(i)
    ny = point%ny(i)
    txd = nyd
    tx = ny
    tyd = -nxd
    ty = -nx
    sum_delx_delyd = 0.0_8
    sum_delx_sqrd = 0.0_8
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    sum_dely_sqrd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_kd = pointd%x(k)
      x_k = point%x(k)
      y_kd = pointd%y(k)
      y_k = point%y(k)
      delxd = x_kd - x_id
      delx = x_k - x_i
      delyd = y_kd - y_id
      dely = y_k - y_i
      delsd = delxd*tx + delx*txd + delyd*ty + dely*tyd
      dels = delx*tx + dely*ty
      delnd = delxd*nx + delx*nxd + delyd*ny + dely*nyd
      deln = delx*nx + dely*ny
      arg1d = delsd*dels + dels*delsd + delnd*deln + deln*delnd
      arg1 = dels*dels + deln*deln
      IF (arg1 .EQ. 0.0) THEN
        distd = 0.0_8
      ELSE
        distd = arg1d/(2.D0*DSQRT(arg1))
      END IF
      dist = DSQRT(arg1)
      IF (dist .GT. 0.0 .OR. (dist .LT. 0.0 .AND. power .EQ. INT(power))&
&     ) THEN
        weightsd = power*dist**(power-1)*distd
      ELSE IF (dist .EQ. 0.0 .AND. power .EQ. 1.0) THEN
        weightsd = distd
      ELSE
        weightsd = 0.0
      END IF
      weights = dist**power
      dels_weightsd = delsd*weights + dels*weightsd
      dels_weights = dels*weights
      deln_weightsd = delnd*weights + deln*weightsd
      deln_weights = deln*weights
      sum_delx_sqrd = sum_delx_sqrd + delsd*dels_weights + dels*&
&       dels_weightsd
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqrd = sum_dely_sqrd + delnd*deln_weights + deln*&
&       deln_weightsd
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_delyd = sum_delx_delyd + delsd*deln_weights + dels*&
&       deln_weightsd
      sum_delx_dely = sum_delx_dely + dels*deln_weights
!			Higher order accuracy using q-variables ..
      qtilde_id = pointd%q(:, i) - 0.5d0*(delxd*point%dq(1, :, i)+delx*&
&       pointd%dq(1, :, i)+delyd*point%dq(2, :, i)+dely*pointd%dq(2, :, &
&       i))
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(delxd*point%dq(1, :, k)+delx*&
&       pointd%dq(1, :, k)+delyd*point%dq(2, :, k)+dely*pointd%dq(2, :, &
&       k))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
        CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
        qtilde_id = pointd%q(:, i) - 0.5d0*(phi_id*(delx*point%dq(1, :, &
&         i)+dely*point%dq(2, :, i))+phi_i*(delxd*point%dq(1, :, i)+delx&
&         *pointd%dq(1, :, i)+delyd*point%dq(2, :, i)+dely*pointd%dq(2, &
&         :, i)))
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_kd = pointd%q(:, k) - 0.5d0*(phi_kd*(delx*point%dq(1, :, &
&         k)+dely*point%dq(2, :, k))+phi_k*(delxd*point%dq(1, :, k)+delx&
&         *pointd%dq(1, :, k)+delyd*point%dq(2, :, k)+dely*pointd%dq(2, &
&         :, k)))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE_D(i, maxi, maxid)
        CALL MIN_Q_VALUE_D(i, mini, minid)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_id(r) = maxid(r)
            qtilde_i(r) = maxi(r)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_id(r) = minid(r)
            qtilde_i(r) = mini(r)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_kd(r) = maxid(r)
            qtilde_k(r) = maxi(r)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_kd(r) = minid(r)
            qtilde_k(r) = mini(r)
          END IF
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_QUAD_GXII_D0(g_i, g_id, nx, nxd, ny, nyd, u1, u1d, u2, &
&                      u2d, rho, rhod, pr, prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_QUAD_GXII_D0(g_k, g_kd, nx, nxd, ny, nyd, u1, u1d, u2, &
&                      u2d, rho, rhod, pr, prd)
      sum_delx_delfd = sum_delx_delfd + (g_kd-g_id)*dels_weights + (g_k-&
&       g_i)*dels_weightsd
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + (g_kd-g_id)*deln_weights + (g_k-&
&       g_i)*deln_weightsd
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    detd = sum_delx_sqrd*sum_dely_sqr + sum_delx_sqr*sum_dely_sqrd - &
&     sum_delx_delyd*sum_delx_dely - sum_delx_dely*sum_delx_delyd
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_detd = -(detd/det**2)
    one_by_det = 1.d0/det
    gd = (sum_delx_delfd*sum_dely_sqr+sum_delx_delf*sum_dely_sqrd-&
&     sum_dely_delfd*sum_delx_dely-sum_dely_delf*sum_delx_delyd)*&
&     one_by_det + (sum_delx_delf*sum_dely_sqr-sum_dely_delf*&
&     sum_delx_dely)*one_by_detd
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGX_POS_D

!	This subroutine evaluates the wall flux derivative dGs_pos
  SUBROUTINE WALL_DGX_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
!			Higher order accuracy using q-variables ..
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) qtilde_i(r) = maxi(r)
          IF (qtilde_i(r) .LT. mini(r)) qtilde_i(r) = mini(r)
          IF (qtilde_k(r) .GT. maxi(r)) qtilde_k(r) = maxi(r)
          IF (qtilde_k(r) .LT. mini(r)) qtilde_k(r) = mini(r)
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXII(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXII(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGX_POS

!  Differentiation of wall_dgx_neg in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: point.x point.y point.nx point.ny
!                point.q point.dq point.qm
!	This subroutine evaluates the wall flux derivative dGs_neg
  SUBROUTINE WALL_DGX_NEG_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txd, tyd, nxd, nyd
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_id, y_id, x_kd, y_kd
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: delxd, delyd, detd
    REAL*8 :: dels, deln
    REAL*8 :: delsd, delnd
!		real*8 :: sum_delx_delx, sum_dely_dely
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrd, sum_dely_sqrd, sum_delx_delyd
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: distd, weightsd
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxid(4), minid(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsd, deln_weightsd
    REAL*8 :: one_by_det
    REAL*8 :: one_by_detd
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1d
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_id = pointd%x(i)
    x_i = point%x(i)
    y_id = pointd%y(i)
    y_i = point%y(i)
    nxd = pointd%nx(i)
    nx = point%nx(i)
    nyd = pointd%ny(i)
    ny = point%ny(i)
    txd = nyd
    tx = ny
    tyd = -nxd
    ty = -nx
    sum_delx_delyd = 0.0_8
    sum_delx_sqrd = 0.0_8
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    sum_dely_sqrd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_kd = pointd%x(k)
      x_k = point%x(k)
      y_kd = pointd%y(k)
      y_k = point%y(k)
      delxd = x_kd - x_id
      delx = x_k - x_i
      delyd = y_kd - y_id
      dely = y_k - y_i
      delsd = delxd*tx + delx*txd + delyd*ty + dely*tyd
      dels = delx*tx + dely*ty
      delnd = delxd*nx + delx*nxd + delyd*ny + dely*nyd
      deln = delx*nx + dely*ny
      arg1d = delsd*dels + dels*delsd + delnd*deln + deln*delnd
      arg1 = dels*dels + deln*deln
      IF (arg1 .EQ. 0.0) THEN
        distd = 0.0_8
      ELSE
        distd = arg1d/(2.D0*DSQRT(arg1))
      END IF
      dist = DSQRT(arg1)
      IF (dist .GT. 0.0 .OR. (dist .LT. 0.0 .AND. power .EQ. INT(power))&
&     ) THEN
        weightsd = power*dist**(power-1)*distd
      ELSE IF (dist .EQ. 0.0 .AND. power .EQ. 1.0) THEN
        weightsd = distd
      ELSE
        weightsd = 0.0
      END IF
      weights = dist**power
      dels_weightsd = delsd*weights + dels*weightsd
      dels_weights = dels*weights
      deln_weightsd = delnd*weights + deln*weightsd
      deln_weights = deln*weights
      sum_delx_sqrd = sum_delx_sqrd + delsd*dels_weights + dels*&
&       dels_weightsd
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqrd = sum_dely_sqrd + delnd*deln_weights + deln*&
&       deln_weightsd
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_delyd = sum_delx_delyd + delsd*deln_weights + dels*&
&       deln_weightsd
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(delxd*point%dq(1, :, i)+delx*&
&       pointd%dq(1, :, i)+delyd*point%dq(2, :, i)+dely*pointd%dq(2, :, &
&       i))
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(delxd*point%dq(1, :, k)+delx*&
&       pointd%dq(1, :, k)+delyd*point%dq(2, :, k)+dely*pointd%dq(2, :, &
&       k))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
        CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
        qtilde_id = pointd%q(:, i) - 0.5d0*(phi_id*(delx*point%dq(1, :, &
&         i)+dely*point%dq(2, :, i))+phi_i*(delxd*point%dq(1, :, i)+delx&
&         *pointd%dq(1, :, i)+delyd*point%dq(2, :, i)+dely*pointd%dq(2, &
&         :, i)))
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_kd = pointd%q(:, k) - 0.5d0*(phi_kd*(delx*point%dq(1, :, &
&         k)+dely*point%dq(2, :, k))+phi_k*(delxd*point%dq(1, :, k)+delx&
&         *pointd%dq(1, :, k)+delyd*point%dq(2, :, k)+dely*pointd%dq(2, &
&         :, k)))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE_D(i, maxi, maxid)
        CALL MIN_Q_VALUE_D(i, mini, minid)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_id(r) = maxid(r)
            qtilde_i(r) = maxi(r)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_id(r) = minid(r)
            qtilde_i(r) = mini(r)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_kd(r) = maxid(r)
            qtilde_k(r) = maxi(r)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_kd(r) = minid(r)
            qtilde_k(r) = mini(r)
          END IF
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_QUAD_GXI_D0(g_i, g_id, nx, nxd, ny, nyd, u1, u1d, u2, &
&                     u2d, rho, rhod, pr, prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_QUAD_GXI_D0(g_k, g_kd, nx, nxd, ny, nyd, u1, u1d, u2, &
&                     u2d, rho, rhod, pr, prd)
      sum_delx_delfd = sum_delx_delfd + (g_kd-g_id)*dels_weights + (g_k-&
&       g_i)*dels_weightsd
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + (g_kd-g_id)*deln_weights + (g_k-&
&       g_i)*deln_weightsd
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    detd = sum_delx_sqrd*sum_dely_sqr + sum_delx_sqr*sum_dely_sqrd - &
&     sum_delx_delyd*sum_delx_dely - sum_delx_dely*sum_delx_delyd
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_detd = -(detd/det**2)
    one_by_det = 1.d0/det
    gd = (sum_delx_delfd*sum_dely_sqr+sum_delx_delf*sum_dely_sqrd-&
&     sum_dely_delfd*sum_delx_dely-sum_dely_delf*sum_delx_delyd)*&
&     one_by_det + (sum_delx_delf*sum_dely_sqr-sum_dely_delf*&
&     sum_delx_dely)*one_by_detd
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGX_NEG_D

!	This subroutine evaluates the wall flux derivative dGs_neg
  SUBROUTINE WALL_DGX_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: dels, deln
!		real*8 :: sum_delx_delx, sum_dely_dely
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) qtilde_i(r) = maxi(r)
          IF (qtilde_i(r) .LT. mini(r)) qtilde_i(r) = mini(r)
          IF (qtilde_k(r) .GT. maxi(r)) qtilde_k(r) = maxi(r)
          IF (qtilde_k(r) .LT. mini(r)) qtilde_k(r) = mini(r)
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXI(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXI(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGX_NEG

!  Differentiation of wall_dgy_neg in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: point.x point.y point.nx point.ny
!                point.q point.dq point.qm
  SUBROUTINE WALL_DGY_NEG_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txd, tyd, nxd, nyd
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_id, y_id, x_kd, y_kd
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxd, delyd, detd, one_by_detd
    REAL*8 :: dels, deln
    REAL*8 :: delsd, delnd
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrd, sum_dely_sqrd, sum_delx_delyd
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: distd, weightsd
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxid(4), minid(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsd, deln_weightsd
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1d
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_id = pointd%x(i)
    x_i = point%x(i)
    y_id = pointd%y(i)
    y_i = point%y(i)
    nxd = pointd%nx(i)
    nx = point%nx(i)
    nyd = pointd%ny(i)
    ny = point%ny(i)
    txd = nyd
    tx = ny
    tyd = -nxd
    ty = -nx
    sum_delx_delyd = 0.0_8
    sum_delx_sqrd = 0.0_8
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    sum_dely_sqrd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%yneg_nbhs(i)
      k = point%yneg_conn(i, j)
      x_kd = pointd%x(k)
      x_k = point%x(k)
      y_kd = pointd%y(k)
      y_k = point%y(k)
      delxd = x_kd - x_id
      delx = x_k - x_i
      delyd = y_kd - y_id
      dely = y_k - y_i
      delsd = delxd*tx + delx*txd + delyd*ty + dely*tyd
      dels = delx*tx + dely*ty
      delnd = delxd*nx + delx*nxd + delyd*ny + dely*nyd
      deln = delx*nx + dely*ny
      arg1d = delsd*dels + dels*delsd + delnd*deln + deln*delnd
      arg1 = dels*dels + deln*deln
      IF (arg1 .EQ. 0.0) THEN
        distd = 0.0_8
      ELSE
        distd = arg1d/(2.D0*DSQRT(arg1))
      END IF
      dist = DSQRT(arg1)
      IF (dist .GT. 0.0 .OR. (dist .LT. 0.0 .AND. power .EQ. INT(power))&
&     ) THEN
        weightsd = power*dist**(power-1)*distd
      ELSE IF (dist .EQ. 0.0 .AND. power .EQ. 1.0) THEN
        weightsd = distd
      ELSE
        weightsd = 0.0
      END IF
      weights = dist**power
      dels_weightsd = delsd*weights + dels*weightsd
      dels_weights = dels*weights
      deln_weightsd = delnd*weights + deln*weightsd
      deln_weights = deln*weights
      sum_delx_sqrd = sum_delx_sqrd + delsd*dels_weights + dels*&
&       dels_weightsd
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqrd = sum_dely_sqrd + delnd*deln_weights + deln*&
&       deln_weightsd
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_delyd = sum_delx_delyd + delsd*deln_weights + dels*&
&       deln_weightsd
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(delxd*point%dq(1, :, i)+delx*&
&       pointd%dq(1, :, i)+delyd*point%dq(2, :, i)+dely*pointd%dq(2, :, &
&       i))
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(delxd*point%dq(1, :, k)+delx*&
&       pointd%dq(1, :, k)+delyd*point%dq(2, :, k)+dely*pointd%dq(2, :, &
&       k))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
        CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
        qtilde_id = pointd%q(:, i) - 0.5d0*(phi_id*(delx*point%dq(1, :, &
&         i)+dely*point%dq(2, :, i))+phi_i*(delxd*point%dq(1, :, i)+delx&
&         *pointd%dq(1, :, i)+delyd*point%dq(2, :, i)+dely*pointd%dq(2, &
&         :, i)))
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_kd = pointd%q(:, k) - 0.5d0*(phi_kd*(delx*point%dq(1, :, &
&         k)+dely*point%dq(2, :, k))+phi_k*(delxd*point%dq(1, :, k)+delx&
&         *pointd%dq(1, :, k)+delyd*point%dq(2, :, k)+dely*pointd%dq(2, &
&         :, k)))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE_D(i, maxi, maxid)
        CALL MIN_Q_VALUE_D(i, mini, minid)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_id(r) = maxid(r)
            qtilde_i(r) = maxi(r)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_id(r) = minid(r)
            qtilde_i(r) = mini(r)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_kd(r) = maxid(r)
            qtilde_k(r) = maxi(r)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_kd(r) = minid(r)
            qtilde_k(r) = mini(r)
          END IF
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GYN_D0(g_i, g_id, nx, nxd, ny, nyd, u1, u1d, u2, u2d, &
&                rho, rhod, pr, prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GYN_D0(g_k, g_kd, nx, nxd, ny, nyd, u1, u1d, u2, u2d, &
&                rho, rhod, pr, prd)
      sum_delx_delfd = sum_delx_delfd + (g_kd-g_id)*dels_weights + (g_k-&
&       g_i)*dels_weightsd
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + (g_kd-g_id)*deln_weights + (g_k-&
&       g_i)*deln_weightsd
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    detd = sum_delx_sqrd*sum_dely_sqr + sum_delx_sqr*sum_dely_sqrd - &
&     sum_delx_delyd*sum_delx_dely - sum_delx_dely*sum_delx_delyd
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_detd = -(detd/det**2)
    one_by_det = 1.d0/det
    gd = (sum_dely_delfd*sum_delx_sqr+sum_dely_delf*sum_delx_sqrd-&
&     sum_delx_delfd*sum_delx_dely-sum_delx_delf*sum_delx_delyd)*&
&     one_by_det + (sum_dely_delf*sum_delx_sqr-sum_delx_delf*&
&     sum_delx_dely)*one_by_detd
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGY_NEG_D

  SUBROUTINE WALL_DGY_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%yneg_nbhs(i)
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) qtilde_i(r) = maxi(r)
          IF (qtilde_i(r) .LT. mini(r)) qtilde_i(r) = mini(r)
          IF (qtilde_k(r) .GT. maxi(r)) qtilde_k(r) = maxi(r)
          IF (qtilde_k(r) .LT. mini(r)) qtilde_k(r) = mini(r)
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GYN(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GYN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGY_NEG

END MODULE WALL_FLUXES_MOD_DIFF

