!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE POINT_NORMALS_MOD_DIFF
  USE DATA_STRUCTURE_MOD_DIFF
  IMPLICIT NONE

CONTAINS
  SUBROUTINE COMPUTE_NORMALS()
    IMPLICIT NONE
    DOUBLE PRECISION :: lx, ly, mx, my, rx, ry
    DOUBLE PRECISION :: nx1, nx2, ny1, ny2, nx, ny
    DOUBLE PRECISION :: det
    INTEGER :: i, j, k, l, m, r
    INTRINSIC DSQRT
    DOUBLE PRECISION :: arg1
!Finding the normals for the points on the shapes ..   
    DO i=1,wall_points
      m = wall_points_index(i)
      l = point%left(m)
      r = point%right(m)
      lx = point%x(l)
      ly = point%y(l)
      mx = point%x(m)
      my = point%y(m)
      rx = point%x(r)
      ry = point%y(r)
      nx1 = my - ly
      nx2 = ry - my
      ny1 = mx - lx
      ny2 = rx - mx
      nx = 0.5d0*(nx1+nx2)
      ny = 0.5d0*(ny1+ny2)
      arg1 = nx*nx + ny*ny
      det = DSQRT(arg1)
      nx = -(nx/det)
      ny = ny/det
      point%nx(m) = nx
      point%ny(m) = ny
    END DO
!	Finding the normals for the outer boundary points ..
    DO i=1,outer_points
      m = outer_points_index(i)
      l = point%left(m)
      r = point%right(m)
      lx = point%x(l)
      ly = point%y(l)
      mx = point%x(m)
      my = point%y(m)
      rx = point%x(r)
      ry = point%y(r)
      nx1 = my - ly
      nx2 = ry - my
      ny1 = mx - lx
      ny2 = rx - mx
      nx = 0.5d0*(nx1+nx2)
      ny = 0.5d0*(ny1+ny2)
      arg1 = nx*nx + ny*ny
      det = DSQRT(arg1)
      nx = -(nx/det)
      ny = ny/det
      point%nx(m) = nx
      point%ny(m) = ny
    END DO
    IF (interior_points_normal_flag .EQ. 0 .AND. format_file .NE. &
&       'quadtree') THEN
      DO i=1,interior_points
        k = interior_points_index(i)
        point%nx(k) = 0.d0
        point%ny(k) = 1.d0
      END DO
    ELSE IF (interior_points_normal_flag .EQ. 1 .AND. format_file .NE. &
&       'quadtree') THEN
      DO i=1,interior_points
        k = interior_points_index(i)
        point%nx(k) = 1.d0
        point%ny(k) = 0.d0
      END DO
    END IF
  END SUBROUTINE COMPUTE_NORMALS

END MODULE POINT_NORMALS_MOD_DIFF

