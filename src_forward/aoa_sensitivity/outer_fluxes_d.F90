!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
MODULE OUTER_FLUXES_MOD_DIFF
!
!	First written on 14.10.2016
!
  USE DATA_STRUCTURE_MOD_DIFF
  USE QUADRANT_FLUXES_MOD_DIFF
  USE SPLIT_FLUXES_MOD_DIFF
  USE Q_VARIABLES_MOD_DIFF
  USE LIMITERS_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of outer_dgx_pos in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: point.q point.dq point.qm
!	This subroutine evaluates the wall flux derivative dGs_pos
  SUBROUTINE OUTER_DGX_POS_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxid(4), minid(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(delx*pointd%dq(1, :, i)+dely*&
&       pointd%dq(2, :, i))
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(delx*pointd%dq(1, :, k)+dely*&
&       pointd%dq(2, :, k))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
        CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
        qtilde_id = pointd%q(:, i) - 0.5d0*(phi_id*(delx*point%dq(1, :, &
&         i)+dely*point%dq(2, :, i))+phi_i*(delx*pointd%dq(1, :, i)+dely&
&         *pointd%dq(2, :, i)))
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_kd = pointd%q(:, k) - 0.5d0*(phi_kd*(delx*point%dq(1, :, &
&         k)+dely*point%dq(2, :, k))+phi_k*(delx*pointd%dq(1, :, k)+dely&
&         *pointd%dq(2, :, k)))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE_D(i, maxi, maxid)
        CALL MIN_Q_VALUE_D(i, mini, minid)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_id(r) = maxid(r)
            qtilde_i(r) = maxi(r)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_id(r) = minid(r)
            qtilde_i(r) = mini(r)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_kd(r) = maxid(r)
            qtilde_k(r) = maxi(r)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_kd(r) = minid(r)
            qtilde_k(r) = mini(r)
          END IF
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_QUAD_GXIII_D0(g_i, g_id, nx, ny, u1, u1d, u2, u2d, rho, &
&                       rhod, pr, prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_QUAD_GXIII_D0(g_k, g_kd, nx, ny, u1, u1d, u2, u2d, rho, &
&                       rhod, pr, prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id)
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    gd = one_by_det*(sum_dely_sqr*sum_delx_delfd-sum_delx_dely*&
&     sum_dely_delfd)
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE OUTER_DGX_POS_D

!	This subroutine evaluates the wall flux derivative dGs_pos
  SUBROUTINE OUTER_DGX_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) qtilde_i(r) = maxi(r)
          IF (qtilde_i(r) .LT. mini(r)) qtilde_i(r) = mini(r)
          IF (qtilde_k(r) .GT. maxi(r)) qtilde_k(r) = maxi(r)
          IF (qtilde_k(r) .LT. mini(r)) qtilde_k(r) = mini(r)
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXIII(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXIII(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE OUTER_DGX_POS

!  Differentiation of outer_dgx_neg in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: point.q point.dq point.qm
!	This subroutine evaluates the wall flux derivative dGs_neg
  SUBROUTINE OUTER_DGX_NEG_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxid(4), minid(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(delx*pointd%dq(1, :, i)+dely*&
&       pointd%dq(2, :, i))
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(delx*pointd%dq(1, :, k)+dely*&
&       pointd%dq(2, :, k))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
        CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
        qtilde_id = pointd%q(:, i) - 0.5d0*(phi_id*(delx*point%dq(1, :, &
&         i)+dely*point%dq(2, :, i))+phi_i*(delx*pointd%dq(1, :, i)+dely&
&         *pointd%dq(2, :, i)))
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_kd = pointd%q(:, k) - 0.5d0*(phi_kd*(delx*point%dq(1, :, &
&         k)+dely*point%dq(2, :, k))+phi_k*(delx*pointd%dq(1, :, k)+dely&
&         *pointd%dq(2, :, k)))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE_D(i, maxi, maxid)
        CALL MIN_Q_VALUE_D(i, mini, minid)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_id(r) = maxid(r)
            qtilde_i(r) = maxi(r)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_id(r) = minid(r)
            qtilde_i(r) = mini(r)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_kd(r) = maxid(r)
            qtilde_k(r) = maxi(r)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_kd(r) = minid(r)
            qtilde_k(r) = mini(r)
          END IF
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_QUAD_GXIV_D0(g_i, g_id, nx, ny, u1, u1d, u2, u2d, rho, &
&                      rhod, pr, prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_QUAD_GXIV_D0(g_k, g_kd, nx, ny, u1, u1d, u2, u2d, rho, &
&                      rhod, pr, prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id)
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    gd = one_by_det*(sum_dely_sqr*sum_delx_delfd-sum_delx_dely*&
&     sum_dely_delfd)
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE OUTER_DGX_NEG_D

!	This subroutine evaluates the wall flux derivative dGs_neg
  SUBROUTINE OUTER_DGX_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) qtilde_i(r) = maxi(r)
          IF (qtilde_i(r) .LT. mini(r)) qtilde_i(r) = mini(r)
          IF (qtilde_k(r) .GT. maxi(r)) qtilde_k(r) = maxi(r)
          IF (qtilde_k(r) .LT. mini(r)) qtilde_k(r) = mini(r)
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXIV(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXIV(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE OUTER_DGX_NEG

!  Differentiation of outer_dgy_pos in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: point.q point.dq point.qm
  SUBROUTINE OUTER_DGY_POS_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxid(4), minid(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%ypos_nbhs(i)
      k = point%ypos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(delx*pointd%dq(1, :, i)+dely*&
&       pointd%dq(2, :, i))
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(delx*pointd%dq(1, :, k)+dely*&
&       pointd%dq(2, :, k))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
        CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
        qtilde_id = pointd%q(:, i) - 0.5d0*(phi_id*(delx*point%dq(1, :, &
&         i)+dely*point%dq(2, :, i))+phi_i*(delx*pointd%dq(1, :, i)+dely&
&         *pointd%dq(2, :, i)))
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_kd = pointd%q(:, k) - 0.5d0*(phi_kd*(delx*point%dq(1, :, &
&         k)+dely*point%dq(2, :, k))+phi_k*(delx*pointd%dq(1, :, k)+dely&
&         *pointd%dq(2, :, k)))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE_D(i, maxi, maxid)
        CALL MIN_Q_VALUE_D(i, mini, minid)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_id(r) = maxid(r)
            qtilde_i(r) = maxi(r)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_id(r) = minid(r)
            qtilde_i(r) = mini(r)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_kd(r) = maxid(r)
            qtilde_k(r) = maxi(r)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_kd(r) = minid(r)
            qtilde_k(r) = mini(r)
          END IF
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GYP_D0(g_i, g_id, nx, ny, u1, u1d, u2, u2d, rho, rhod, &
&                pr, prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GYP_D0(g_k, g_kd, nx, ny, u1, u1d, u2, u2d, rho, rhod, &
&                pr, prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id)
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    gd = one_by_det*(sum_delx_sqr*sum_dely_delfd-sum_delx_dely*&
&     sum_delx_delfd)
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE OUTER_DGY_POS_D

  SUBROUTINE OUTER_DGY_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%ypos_nbhs(i)
      k = point%ypos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) qtilde_i(r) = maxi(r)
          IF (qtilde_i(r) .LT. mini(r)) qtilde_i(r) = mini(r)
          IF (qtilde_k(r) .GT. maxi(r)) qtilde_k(r) = maxi(r)
          IF (qtilde_k(r) .LT. mini(r)) qtilde_k(r) = mini(r)
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GYP(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GYP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE OUTER_DGY_POS

END MODULE OUTER_FLUXES_MOD_DIFF

