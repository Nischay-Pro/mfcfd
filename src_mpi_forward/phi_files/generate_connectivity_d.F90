!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE GENERATE_CONNECTIVITY_MOD_DIFF
  USE DATA_STRUCTURE_MOD_DIFF
  IMPLICIT NONE

CONTAINS
  SUBROUTINE GENERATE_CONNECTIVITY()
    IMPLICIT NONE
    INTEGER :: i, k
    REAL*8 :: nx, ny
    DO k=1,interior_points
      i = interior_points_index(k)
      nx = point%nx(i)
      ny = point%ny(i)
      CALL GET_INTERIOR_NEIGHBOURS(i, nx, ny)
    END DO
    DO k=1,wall_points
      i = wall_points_index(k)
      nx = point%nx(i)
      ny = point%ny(i)
      CALL GET_WALL_BOUNDARY_NEIGHBOURS(i, nx, ny)
    END DO
    DO k=1,outer_points
      i = outer_points_index(k)
      nx = point%nx(i)
      ny = point%ny(i)
      CALL GET_OUTER_BOUNDARY_NEIGHBOURS(i, nx, ny)
    END DO
  END SUBROUTINE GENERATE_CONNECTIVITY

  SUBROUTINE GET_INTERIOR_NEIGHBOURS(i, nx, ny)
    IMPLICIT NONE
    REAL*8 :: xi, yi, xk, yk
    REAL*8 :: delx, dely, dels, deln
    REAL*8 :: nx, ny, tx, ty
    INTEGER :: i, r, count, nbh
    xi = point%x(i)
    yi = point%y(i)
    tx = ny
    ty = -nx
    point%xpos_nbhs(i) = 0
    point%xneg_nbhs(i) = 0
    point%ypos_nbhs(i) = 0
    point%yneg_nbhs(i) = 0
    DO r=1,point%nbhs(i)
      nbh = point%conn(i, r)
      xk = point%x(nbh)
      yk = point%y(nbh)
      delx = xk - xi
      dely = yk - yi
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      IF (dels .LE. 0.0d0) THEN
        point%xpos_nbhs(i) = point%xpos_nbhs(i) + 1
        count = point%xpos_nbhs(i)
        point%xpos_conn(i, count) = nbh
      END IF
      IF (dels .GE. 0.0d0) THEN
        point%xneg_nbhs(i) = point%xneg_nbhs(i) + 1
        count = point%xneg_nbhs(i)
        point%xneg_conn(i, count) = nbh
      END IF
      IF (deln .LE. 0.0d0) THEN
        point%ypos_nbhs(i) = point%ypos_nbhs(i) + 1
        count = point%ypos_nbhs(i)
        point%ypos_conn(i, count) = nbh
      END IF
      IF (deln .GE. 0.0d0) THEN
        point%yneg_nbhs(i) = point%yneg_nbhs(i) + 1
        count = point%yneg_nbhs(i)
        point%yneg_conn(i, count) = nbh
      END IF
    END DO
    IF (point%xpos_nbhs(i) .EQ. 0) THEN
      PRINT*, 'xpos zero for interior point number:', i
      STOP
    ELSE IF (point%xneg_nbhs(i) .EQ. 0) THEN
      PRINT*, 'xneg zero for interior point number:', i
      STOP
    ELSE IF (point%ypos_nbhs(i) .EQ. 0) THEN
      PRINT*, 'ypos zero for interior point number:', i
      STOP
    ELSE IF (point%yneg_nbhs(i) .EQ. 0) THEN
      PRINT*, 'yneg zero for interior point number:', i
      STOP
    END IF
  END SUBROUTINE GET_INTERIOR_NEIGHBOURS

  SUBROUTINE GET_WALL_BOUNDARY_NEIGHBOURS(i, nx, ny)
    IMPLICIT NONE
    REAL*8 :: xi, yi, xk, yk
    REAL*8 :: delx, dely, dels, deln
    REAL*8 :: nx, ny, tx, ty
    INTEGER :: i, r, count, nbh
    xi = point%x(i)
    yi = point%y(i)
    tx = ny
    ty = -nx
    point%xpos_nbhs(i) = 0
    point%xneg_nbhs(i) = 0
    point%yneg_nbhs(i) = 0
    DO r=1,point%nbhs(i)
      nbh = point%conn(i, r)
      xk = point%x(nbh)
      yk = point%y(nbh)
      delx = xk - xi
      dely = yk - yi
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      IF (dels .LE. 0.0d0) THEN
        point%xpos_nbhs(i) = point%xpos_nbhs(i) + 1
        count = point%xpos_nbhs(i)
        point%xpos_conn(i, count) = nbh
      END IF
      IF (dels .GE. 0.0d0) THEN
        point%xneg_nbhs(i) = point%xneg_nbhs(i) + 1
        count = point%xneg_nbhs(i)
        point%xneg_conn(i, count) = nbh
      END IF
      point%yneg_nbhs(i) = point%yneg_nbhs(i) + 1
      count = point%yneg_nbhs(i)
      point%yneg_conn(i, count) = nbh
    END DO
    IF (point%xpos_nbhs(i) .EQ. 0) THEN
      PRINT*, 'xpos zero for wall point number:', i
      STOP
    ELSE IF (point%xneg_nbhs(i) .EQ. 0) THEN
      PRINT*, 'xneg zero for wall point number:', i
      STOP
    ELSE IF (point%yneg_nbhs(i) .EQ. 0) THEN
      PRINT*, 'yneg zero for wall point number:', i
      STOP
    END IF
  END SUBROUTINE GET_WALL_BOUNDARY_NEIGHBOURS

  SUBROUTINE GET_OUTER_BOUNDARY_NEIGHBOURS(i, nx, ny)
    IMPLICIT NONE
    REAL*8 :: xi, yi, xk, yk
    REAL*8 :: delx, dely, dels, deln
    REAL*8 :: nx, ny, tx, ty
    INTEGER :: i, r, count, nbh
    xi = point%x(i)
    yi = point%y(i)
    tx = ny
    ty = -nx
    point%xpos_nbhs(i) = 0
    point%xneg_nbhs(i) = 0
    point%ypos_nbhs(i) = 0
    DO r=1,point%nbhs(i)
      nbh = point%conn(i, r)
      xk = point%x(nbh)
      yk = point%y(nbh)
      delx = xk - xi
      dely = yk - yi
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      IF (dels .LE. 0.0d0) THEN
        point%xpos_nbhs(i) = point%xpos_nbhs(i) + 1
        count = point%xpos_nbhs(i)
        point%xpos_conn(i, count) = nbh
      END IF
      IF (dels .GE. 0.0d0) THEN
        point%xneg_nbhs(i) = point%xneg_nbhs(i) + 1
        count = point%xneg_nbhs(i)
        point%xneg_conn(i, count) = nbh
      END IF
      point%ypos_nbhs(i) = point%ypos_nbhs(i) + 1
      count = point%ypos_nbhs(i)
      point%ypos_conn(i, count) = nbh
    END DO
    IF (point%xpos_nbhs(i) .EQ. 0) THEN
      PRINT*, 'xpos zero for outer point number:', i
      STOP
    ELSE IF (point%xneg_nbhs(i) .EQ. 0) THEN
      PRINT*, 'xneg zero for outer point number:', i
      STOP
    ELSE IF (point%ypos_nbhs(i) .EQ. 0) THEN
      PRINT*, 'ypos zero for outer point number:', i
      STOP
    END IF
  END SUBROUTINE GET_OUTER_BOUNDARY_NEIGHBOURS

  INTEGER FUNCTION FIND_LOC_F90(array, pointcount, pidx, nbhvalue)
    IMPLICIT NONE
    INTEGER, DIMENSION(:, :) :: array
    INTEGER :: pointcount, pidx, nbhvalue, i
    DO i=1,pointcount
      IF (array(pidx, i) .EQ. nbhvalue) THEN
        find_loc_f90 = i
        RETURN
      END IF
    END DO
    PRINT*, 'warning could not find point in conn', pidx, nbhvalue
    STOP
  END FUNCTION FIND_LOC_F90

END MODULE GENERATE_CONNECTIVITY_MOD_DIFF

