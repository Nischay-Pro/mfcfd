!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE STATE_UPDATE_MOD_DIFF
#include <petsc/finclude/petscsys.h>
  USE DATA_STRUCTURE_MOD_DIFF
  USE PETSC_DATA_STRUCTURE_MOD
  USE FLUX_RESIDUAL_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of state_update in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: *(point.prim)
!   with respect to varying inputs: *(point.prim) *(point.prim_old)
!                *(point.flux_res)
!   Plus diff mem management of: point.prim:in point.prim_old:in
!                point.flux_res:in
  SUBROUTINE STATE_UPDATE_D(rk)
    IMPLICIT NONE
    INTEGER :: i, k, r, rk
    REAL*8 :: delt, u(4), temp, u_old(4)
    REAL*8 :: ud(4), tempd, u_oldd(4)
    REAL*8 :: res_sqr
    REAL*8 :: nx, ny
    REAL*8 :: u2_rot, u3_rot
    REAL*8 :: u2_rotd, u3_rotd
    REAL*8, PARAMETER :: obt=1.0d0/3.0d0
    REAL*8, PARAMETER :: tbt=2.0d0/3.0d0
    max_res = 0.0d0
    sum_res_sqr = 0.0d0
    ud = 0.0_8
    u_oldd = 0.0_8
    DO i=1,wall_points
      k = wall_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim(:, k), pointd%prim(:, k)&
&                             , nx, ny, u, ud)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim_old(:, k), pointd%&
&                             prim_old(:, k), nx, ny, u_old, u_oldd)
      temp = u(1)
      IF (rk .NE. 3) THEN
        ud = ud - 0.5d0*euler*pointd%flux_res(:, k)
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        ud = tbt*u_oldd + obt*(ud-0.5d0*pointd%flux_res(:, k))
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      ud(3) = 0.0_8
      u(3) = 0.d0
      u2_rotd = ud(2)
      u2_rot = u(2)
      u3_rotd = ud(3)
      u3_rot = u(3)
      ud(2) = ny*u2_rotd + nx*u3_rotd
      u(2) = u2_rot*ny + u3_rot*nx
      ud(3) = ny*u3_rotd - nx*u2_rotd
      u(3) = u3_rot*ny - u2_rot*nx
      res_sqr = (u(1)-temp)*(u(1)-temp)
      IF (res_sqr .GT. max_res) THEN
        max_res = res_sqr
        max_res_point = k
      END IF
      sum_res_sqr = sum_res_sqr + res_sqr
      pointd%prim(1, k) = ud(1)
      point%prim(1, k) = u(1)
      tempd = -(ud(1)/u(1)**2)
      temp = 1.0d0/u(1)
      pointd%prim(2, k) = ud(2)*temp + u(2)*tempd
      point%prim(2, k) = u(2)*temp
      pointd%prim(3, k) = ud(3)*temp + u(3)*tempd
      point%prim(3, k) = u(3)*temp
      pointd%prim(4, k) = 0.4d0*ud(4) - 0.2d0*(tempd*(u(2)*u(2)+u(3)*u(3&
&       ))+temp*(ud(2)*u(2)+u(2)*ud(2)+ud(3)*u(3)+u(3)*ud(3)))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,outer_points
      k = outer_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL CONSERVED_VECTOR_UBAR_D(point%prim(:, k), pointd%prim(:, k), &
&                            u, ud, nx, ny)
      CALL CONSERVED_VECTOR_UBAR_D(point%prim_old(:, k), pointd%prim_old&
&                            (:, k), u_old, u_oldd, nx, ny)
      temp = u(1)
      IF (rk .NE. 3) THEN
        ud = ud - 0.5d0*euler*pointd%flux_res(:, k)
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        ud = tbt*u_oldd + obt*(ud-0.5d0*pointd%flux_res(:, k))
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u2_rotd = ud(2)
      u2_rot = u(2)
      u3_rotd = ud(3)
      u3_rot = u(3)
      ud(2) = ny*u2_rotd + nx*u3_rotd
      u(2) = u2_rot*ny + u3_rot*nx
      ud(3) = ny*u3_rotd - nx*u2_rotd
      u(3) = u3_rot*ny - u2_rot*nx
      pointd%prim(1, k) = ud(1)
      point%prim(1, k) = u(1)
      tempd = -(ud(1)/u(1)**2)
      temp = 1.0d0/u(1)
      pointd%prim(2, k) = ud(2)*temp + u(2)*tempd
      point%prim(2, k) = u(2)*temp
      pointd%prim(3, k) = ud(3)*temp + u(3)*tempd
      point%prim(3, k) = u(3)*temp
      pointd%prim(4, k) = 0.4d0*ud(4) - 0.2d0*(tempd*(u(2)*u(2)+u(3)*u(3&
&       ))+temp*(ud(2)*u(2)+u(2)*ud(2)+ud(3)*u(3)+u(3)*ud(3)))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,interior_points
      k = interior_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim(:, k), pointd%prim(:, k)&
&                             , nx, ny, u, ud)
      CALL PRIMITIVE_TO_CONSERVED_D(point%prim_old(:, k), pointd%&
&                             prim_old(:, k), nx, ny, u_old, u_oldd)
      temp = u(1)
      IF (rk .NE. 3) THEN
        ud = ud - 0.5d0*euler*pointd%flux_res(:, k)
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        ud = tbt*u_oldd + obt*(ud-0.5d0*pointd%flux_res(:, k))
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u2_rotd = ud(2)
      u2_rot = u(2)
      u3_rotd = ud(3)
      u3_rot = u(3)
      ud(2) = ny*u2_rotd + nx*u3_rotd
      u(2) = u2_rot*ny + u3_rot*nx
      ud(3) = ny*u3_rotd - nx*u2_rotd
      u(3) = u3_rot*ny - u2_rot*nx
      res_sqr = (u(1)-temp)*(u(1)-temp)
      IF (res_sqr .GT. max_res) THEN
        max_res = res_sqr
        max_res_point = k
      END IF
      sum_res_sqr = sum_res_sqr + res_sqr
      pointd%prim(1, k) = ud(1)
      point%prim(1, k) = u(1)
      tempd = -(ud(1)/u(1)**2)
      temp = 1.0d0/u(1)
      pointd%prim(2, k) = ud(2)*temp + u(2)*tempd
      point%prim(2, k) = u(2)*temp
      pointd%prim(3, k) = ud(3)*temp + u(3)*tempd
      point%prim(3, k) = u(3)*temp
      pointd%prim(4, k) = 0.4d0*ud(4) - 0.2d0*(tempd*(u(2)*u(2)+u(3)*u(3&
&       ))+temp*(ud(2)*u(2)+u(2)*ud(2)+ud(3)*u(3)+u(3)*ud(3)))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
  END SUBROUTINE STATE_UPDATE_D

  SUBROUTINE STATE_UPDATE(rk)
    IMPLICIT NONE
    INTEGER :: i, k, r, rk
    REAL*8 :: delt, u(4), temp, u_old(4)
    REAL*8 :: res_sqr
    REAL*8 :: nx, ny
    REAL*8 :: u2_rot, u3_rot
    REAL*8, PARAMETER :: obt=1.0d0/3.0d0
    REAL*8, PARAMETER :: tbt=2.0d0/3.0d0
    max_res = 0.0d0
    sum_res_sqr = 0.0d0
    DO i=1,wall_points
      k = wall_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PRIMITIVE_TO_CONSERVED(point%prim(:, k), nx, ny, u)
      CALL PRIMITIVE_TO_CONSERVED(point%prim_old(:, k), nx, ny, u_old)
      temp = u(1)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u(3) = 0.d0
      u2_rot = u(2)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      res_sqr = (u(1)-temp)*(u(1)-temp)
      IF (res_sqr .GT. max_res) THEN
        max_res = res_sqr
        max_res_point = k
      END IF
      sum_res_sqr = sum_res_sqr + res_sqr
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      point%prim(2, k) = u(2)*temp
      point%prim(3, k) = u(3)*temp
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,outer_points
      k = outer_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL CONSERVED_VECTOR_UBAR(point%prim(:, k), u, nx, ny)
      CALL CONSERVED_VECTOR_UBAR(point%prim_old(:, k), u_old, nx, ny)
      temp = u(1)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u2_rot = u(2)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      point%prim(2, k) = u(2)*temp
      point%prim(3, k) = u(3)*temp
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,interior_points
      k = interior_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PRIMITIVE_TO_CONSERVED(point%prim(:, k), nx, ny, u)
      CALL PRIMITIVE_TO_CONSERVED(point%prim_old(:, k), nx, ny, u_old)
      temp = u(1)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u2_rot = u(2)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      res_sqr = (u(1)-temp)*(u(1)-temp)
      IF (res_sqr .GT. max_res) THEN
        max_res = res_sqr
        max_res_point = k
      END IF
      sum_res_sqr = sum_res_sqr + res_sqr
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      point%prim(2, k) = u(2)*temp
      point%prim(3, k) = u(3)*temp
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
  END SUBROUTINE STATE_UPDATE

!  Differentiation of primitive_to_conserved in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u
!   with respect to varying inputs: prim u
  SUBROUTINE PRIMITIVE_TO_CONSERVED_D(prim, primd, nx, ny, u, ud)
    IMPLICIT NONE
    REAL*8 :: rho, prim(4)
    REAL*8 :: rhod, primd(4)
    REAL*8 :: u(4), nx, ny
    REAL*8 :: ud(4)
    REAL*8 :: temp1, temp2
    REAL*8 :: temp1d, temp2d
    rhod = primd(1)
    rho = prim(1)
    ud(1) = rhod
    u(1) = rho
    temp1d = rhod*prim(2) + rho*primd(2)
    temp1 = rho*prim(2)
    temp2d = rhod*prim(3) + rho*primd(3)
    temp2 = rho*prim(3)
    ud(4) = 2.5d0*primd(4) + (0.5d0*(temp1d*temp1+temp1*temp1d+temp2d*&
&     temp2+temp2*temp2d)*rho-0.5d0*(temp1*temp1+temp2*temp2)*rhod)/rho&
&     **2
    u(4) = 2.5d0*prim(4) + 0.5d0*(temp1*temp1+temp2*temp2)/rho
    ud(2) = ny*temp1d - nx*temp2d
    u(2) = temp1*ny - temp2*nx
    ud(3) = nx*temp1d + ny*temp2d
    u(3) = temp1*nx + temp2*ny
  END SUBROUTINE PRIMITIVE_TO_CONSERVED_D

  SUBROUTINE PRIMITIVE_TO_CONSERVED(prim, nx, ny, u)
    IMPLICIT NONE
    REAL*8 :: rho, prim(4)
    REAL*8 :: u(4), nx, ny
    REAL*8 :: temp1, temp2
    rho = prim(1)
    u(1) = rho
    temp1 = rho*prim(2)
    temp2 = rho*prim(3)
    u(4) = 2.5d0*prim(4) + 0.5d0*(temp1*temp1+temp2*temp2)/rho
    u(2) = temp1*ny - temp2*nx
    u(3) = temp1*nx + temp2*ny
  END SUBROUTINE PRIMITIVE_TO_CONSERVED

  SUBROUTINE CONSERVED_TO_PRIMITIVE(u, prim)
    IMPLICIT NONE
    REAL*8 :: temp, u(4), prim(4)
    prim(1) = u(1)
    temp = 1.0d0/u(1)
    prim(2) = u(2)*temp
    prim(3) = u(3)*temp
    temp = u(4) - 0.5d0*temp*(u(2)*u(2)+u(3)*u(3))
    prim(4) = 0.4d0*temp
  END SUBROUTINE CONSERVED_TO_PRIMITIVE

!  Differentiation of func_delta in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: *(point.delta) dtg lmin
!   with respect to varying inputs: t *(point.prim) *(point.delta)
!                dtg lmin
!   Plus diff mem management of: point.prim:in point.delta:in
!	This subroutine computes the delta_t (local time step) at a given point ..
  SUBROUTINE FUNC_DELTA_D()
    IMPLICIT NONE
    INTEGER :: i, k, r
    REAL*8 :: delta_t
    REAL*8 :: delta_td
    REAL*8 :: min_dist
    REAL*8, SAVE :: lmin=1.0d0
    REAL*8, SAVE :: lmind=0.0_8
    REAL*8 :: gmin
    REAL*8 :: gmind
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: u1, u2, rho, pr, mod_u
    REAL*8 :: u1d, u2d, rhod, prd, mod_ud
    REAL*8 :: dist
    REAL*8 :: min_delt
    REAL*8 :: min_deltd
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1d
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    PetscErrorCode :: ierr
    DO i=1,local_points
      min_delt = 1.0d0
      min_deltd = 0.0_8
      DO r=1,point%nbhs(i)
        k = point%conn(i, r)
        rhod = pointd%prim(1, k)
        rho = point%prim(1, k)
        u1d = pointd%prim(2, k)
        u1 = point%prim(2, k)
        u2d = pointd%prim(3, k)
        u2 = point%prim(3, k)
        prd = pointd%prim(4, k)
        pr = point%prim(4, k)
        x_i = point%x(i)
        y_i = point%y(i)
        x_k = point%x(k)
        y_k = point%y(k)
        dist = (x_k-x_i)*(x_k-x_i) + (y_k-y_i)*(y_k-y_i)
        dist = DSQRT(dist)
        arg1d = u1d*u1 + u1*u1d + u2d*u2 + u2*u2d
        arg1 = u1*u1 + u2*u2
        IF (arg1 .EQ. 0.0) THEN
          mod_ud = 0.0_8
        ELSE
          mod_ud = arg1d/(2.D0*DSQRT(arg1))
        END IF
        mod_u = DSQRT(arg1)
        arg1d = (prd*rho-pr*rhod)/rho**2
        arg1 = pr/rho
        IF (arg1 .EQ. 0.0) THEN
          result1d = 0.D0
        ELSE
          result1d = arg1d/(2.D0*DSQRT(arg1))
        END IF
        result1 = DSQRT(arg1)
        delta_td = -(dist*(mod_ud+3.0d0*result1d)/(mod_u+3.0d0*result1)&
&         **2)
        delta_t = dist/(mod_u+3.0d0*result1)
        delta_td = cfl*delta_td
        delta_t = cfl*delta_t
        IF (min_delt .GT. delta_t) THEN
          min_deltd = delta_td
          min_delt = delta_t
        END IF
      END DO
      pointd%delta(i) = min_deltd
      point%delta(i) = min_delt
    END DO
!     IF (timestep .EQ. 1) THEN
!       DO i=1,local_points
!         IF (point%delta(i) .LT. lmin) THEN
!           lmind = pointd%delta(i)
!           lmin = point%delta(i)
!         END IF
!       END DO
!       CALL TLS_MPI_REDUCE(lmin, lmind, gmin, gmind, 1, mpi_double, &
! &                   mpi_double, mpi_min, 0, 0, petsc_comm_world, ierr)
!       CALL TLS_MPI_BCAST(gmin, gmind, 1, mpi_double, mpi_double, 0, &
! &                  petsc_comm_world, ierr)
!       dtgd = gmind
!       dtg = gmin
!       IF (t + dtg .GT. tfinal) THEN
!         dtgd = -td
!         dtg = tfinal - t
!       END IF
!       pointd%delta = dtgd
!       point%delta = dtg
!     END IF
  END SUBROUTINE FUNC_DELTA_D

!	This subroutine computes the delta_t (local time step) at a given point ..
  SUBROUTINE FUNC_DELTA()
    IMPLICIT NONE
    INTEGER :: i, k, r
    REAL*8 :: delta_t
    REAL*8 :: min_dist
    REAL*8, SAVE :: lmin=1.0d0
    REAL*8 :: gmin
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: u1, u2, rho, pr, mod_u
    REAL*8 :: dist
    REAL*8 :: min_delt
    INTRINSIC DSQRT
    REAL*8 :: arg1
    DOUBLE PRECISION :: result1
PetscErrorCode :: ierr
    DO i=1,local_points
      min_delt = 1.0d0
      DO r=1,point%nbhs(i)
        k = point%conn(i, r)
        rho = point%prim(1, k)
        u1 = point%prim(2, k)
        u2 = point%prim(3, k)
        pr = point%prim(4, k)
        x_i = point%x(i)
        y_i = point%y(i)
        x_k = point%x(k)
        y_k = point%y(k)
        dist = (x_k-x_i)*(x_k-x_i) + (y_k-y_i)*(y_k-y_i)
        dist = DSQRT(dist)
        arg1 = u1*u1 + u2*u2
        mod_u = DSQRT(arg1)
        arg1 = pr/rho
        result1 = DSQRT(arg1)
        delta_t = dist/(mod_u+3.0d0*result1)
        delta_t = cfl*delta_t
        IF (min_delt .GT. delta_t) min_delt = delta_t
      END DO
      point%delta(i) = min_delt
    END DO
!     IF (timestep .EQ. 1) THEN
!       DO i=1,local_points
!         IF (point%delta(i) .LT. lmin) lmin = point%delta(i)
!       END DO
!       CALL MPI_REDUCE(lmin, gmin, 1, mpi_double, mpi_min, 0, &
! &               petsc_comm_world, ierr)
!       CALL MPI_BCAST(gmin, 1, mpi_double, 0, petsc_comm_world, ierr)
!       dtg = gmin
!       IF (t + dtg .GT. tfinal) dtg = tfinal - t
!       point%delta = dtg
!     END IF
  END SUBROUTINE FUNC_DELTA

!  Differentiation of conserved_vector_ubar in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: ubar
!   with respect to varying inputs: prim ubar
  SUBROUTINE CONSERVED_VECTOR_UBAR_D(prim, primd, ubar, ubard, nx, ny)
    IMPLICIT NONE
    REAL*8 :: u1_inf, u2_inf, u1_inf_rot, u2_inf_rot, e_inf
    REAL*8 :: u1, u2, pr, rho, u1_rot, u2_rot, e
    REAL*8 :: u1d, u2d, prd, rhod, u1_rotd, u2_rotd, ed
    REAL*8 :: beta, s2, b2_inf, a2n_inf
    REAL*8 :: betad, s2d
    REAL*8 :: b2, a2p, temp1, temp2
    REAL*8 :: b2d, a2pd, temp1d, temp2d
    REAL*8 :: ubar(4), prim(4)
    REAL*8 :: ubard(4), primd(4)
    REAL*8 :: nx, ny, tx, ty
    INTRINSIC DSQRT
    INTRINSIC DEXP
    ! EXTERNAL DERF
    ! EXTERNAL DERF_D
    ! DOUBLE PRECISION :: DERF
    ! DOUBLE PRECISION :: DERF_D
    ! INTRINSIC SQRT
    ! INTRINSIC EXP
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    REAL*8 :: result10
    REAL*8 :: result10d
    u1_inf = q_inf(2)
    u2_inf = q_inf(3)
    tx = ny
    ty = -nx
    u1_inf_rot = u1_inf*tx + u2_inf*ty
    u2_inf_rot = u1_inf*nx + u2_inf*ny
    temp1 = u1_inf_rot*u1_inf_rot + u2_inf_rot*u2_inf_rot
    e_inf = pr_inf/(rho_inf*(gamma-1.0d0)) + 0.5d0*temp1
    beta = 0.5d0*rho_inf/pr_inf
    result1 = DSQRT(beta)
    s2 = u2_inf_rot*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2_inf = DEXP(-(s2*s2))/(2.0d0*result1)
    result1 = DERF(s2)
    a2n_inf = 0.5d0*(1.0d0-result1)
    rhod = primd(1)
    rho = prim(1)
    u1d = primd(2)
    u1 = prim(2)
    u2d = primd(3)
    u2 = prim(3)
    prd = primd(4)
    pr = prim(4)
    u1_rotd = tx*u1d + ty*u2d
    u1_rot = u1*tx + u2*ty
    u2_rotd = nx*u1d + ny*u2d
    u2_rot = u1*nx + u2*ny
    temp1d = u1_rotd*u1_rot + u1_rot*u1_rotd + u2_rotd*u2_rot + u2_rot*&
&     u2_rotd
    temp1 = u1_rot*u1_rot + u2_rot*u2_rot
    ed = (prd*rho*(gamma-1.0d0)-pr*(gamma-1.0d0)*rhod)/(rho*(gamma-1.0d0&
&     ))**2 + 0.5d0*temp1d
    e = pr/(rho*(gamma-1.0d0)) + 0.5d0*temp1
    betad = (rhod*2.0d0*pr-rho*2.0d0*prd)/(2.0d0*pr)**2
    beta = rho/(2.0d0*pr)
    IF (beta .EQ. 0.0) THEN
      result10d = 0.0_8
    ELSE
      result10d = betad/(2.0*SQRT(beta))
    END IF
    result10 = SQRT(beta)
    s2d = u2_rotd*result10 + u2_rot*result10d
    s2 = u2_rot*result10
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      result10d = 0.0_8
    ELSE
      result10d = arg1d/(2.0*SQRT(arg1))
    END IF
    result10 = SQRT(arg1)
    b2d = (-((s2d*s2+s2*s2d)*EXP(-(s2*s2))*2.0d0*result10)-EXP(-(s2*s2))&
&     *2.0d0*result10d)/(2.0d0*result10)**2
    b2 = EXP(-(s2*s2))/(2.0d0*result10)
    !
    ! result1d = DERF_D(s2, s2d, result1)
    !
    result1d = dexp(-s2**2)*(2.d0/sqrt(pi))*s2d
    result1 = derf(s2)
    !
    a2pd = 0.5d0*result1d
    a2p = 0.5d0*(1.0d0+result1)
    ubard(1) = rhod*a2p + rho*a2pd
    ubar(1) = rho_inf*a2n_inf + rho*a2p
    ubard(2) = (rhod*u1_rot+rho*u1_rotd)*a2p + rho*u1_rot*a2pd
    ubar(2) = rho_inf*u1_inf_rot*a2n_inf + rho*u1_rot*a2p
    temp1 = rho_inf*(u2_inf_rot*a2n_inf-b2_inf)
    temp2d = rhod*(u2_rot*a2p+b2) + rho*(u2_rotd*a2p+u2_rot*a2pd+b2d)
    temp2 = rho*(u2_rot*a2p+b2)
    ubard(3) = temp2d
    ubar(3) = temp1 + temp2
    temp1 = rho_inf*a2n_inf*e_inf - 0.5d0*rho_inf*u2_inf_rot*b2_inf
    temp2d = (rhod*a2p+rho*a2pd)*e + rho*a2p*ed + 0.5d0*((rhod*u2_rot+&
&     rho*u2_rotd)*b2+rho*u2_rot*b2d)
    temp2 = rho*a2p*e + 0.5d0*rho*u2_rot*b2
    ubard(4) = temp2d
    ubar(4) = temp1 + temp2
  END SUBROUTINE CONSERVED_VECTOR_UBAR_D

  SUBROUTINE CONSERVED_VECTOR_UBAR(prim, ubar, nx, ny)
    IMPLICIT NONE
    REAL*8 :: u1_inf, u2_inf, u1_inf_rot, u2_inf_rot, e_inf
    REAL*8 :: u1, u2, pr, rho, u1_rot, u2_rot, e
    REAL*8 :: beta, s2, b2_inf, a2n_inf
    REAL*8 :: b2, a2p, temp1, temp2
    REAL*8 :: ubar(4), prim(4)
    REAL*8 :: nx, ny, tx, ty
    ! INTRINSIC DSQRT
    ! INTRINSIC DEXP
    ! EXTERNAL DERF
    ! DOUBLE PRECISION :: DERF
    ! INTRINSIC SQRT
    ! INTRINSIC EXP
    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    REAL*8 :: result10
    u1_inf = q_inf(2)
    u2_inf = q_inf(3)
    tx = ny
    ty = -nx
    u1_inf_rot = u1_inf*tx + u2_inf*ty
    u2_inf_rot = u1_inf*nx + u2_inf*ny
    temp1 = u1_inf_rot*u1_inf_rot + u2_inf_rot*u2_inf_rot
    e_inf = pr_inf/(rho_inf*(gamma-1.0d0)) + 0.5d0*temp1
    beta = 0.5d0*rho_inf/pr_inf
    result1 = DSQRT(beta)
    s2 = u2_inf_rot*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2_inf = DEXP(-(s2*s2))/(2.0d0*result1)
    result1 = DERF(s2)
    a2n_inf = 0.5d0*(1.0d0-result1)
    rho = prim(1)
    u1 = prim(2)
    u2 = prim(3)
    pr = prim(4)
    u1_rot = u1*tx + u2*ty
    u2_rot = u1*nx + u2*ny
    temp1 = u1_rot*u1_rot + u2_rot*u2_rot
    e = pr/(rho*(gamma-1.0d0)) + 0.5d0*temp1
    beta = rho/(2.0d0*pr)
    result10 = SQRT(beta)
    s2 = u2_rot*result10
    arg1 = pi*beta
    result10 = SQRT(arg1)
    b2 = EXP(-(s2*s2))/(2.0d0*result10)
    result1 = DERF(s2)
    a2p = 0.5d0*(1.0d0+result1)
    ubar(1) = rho_inf*a2n_inf + rho*a2p
    ubar(2) = rho_inf*u1_inf_rot*a2n_inf + rho*u1_rot*a2p
    temp1 = rho_inf*(u2_inf_rot*a2n_inf-b2_inf)
    temp2 = rho*(u2_rot*a2p+b2)
    ubar(3) = temp1 + temp2
    temp1 = rho_inf*a2n_inf*e_inf - 0.5d0*rho_inf*u2_inf_rot*b2_inf
    temp2 = rho*a2p*e + 0.5d0*rho*u2_rot*b2
    ubar(4) = temp1 + temp2
  END SUBROUTINE CONSERVED_VECTOR_UBAR

END MODULE STATE_UPDATE_MOD_DIFF
