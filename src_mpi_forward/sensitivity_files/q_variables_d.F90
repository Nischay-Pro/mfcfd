!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE Q_VARIABLES_MOD_DIFF
  USE DATA_STRUCTURE_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of eval_q_variables in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: *(point.q)
!   with respect to varying inputs: *(point.prim) *(point.q)
!   Plus diff mem management of: point.prim:in point.q:in
  SUBROUTINE EVAL_Q_VARIABLES_D()
    IMPLICIT NONE
    INTEGER :: k
    REAL*8 :: rho, u1, u2, pr, beta
    REAL*8 :: rhod, u1d, u2d, prd, betad
    REAL*8 :: two_times_beta
    REAL*8 :: two_times_betad
    INTRINSIC DLOG
!
    DO k=1,max_points
      rhod = pointd%prim(1, k)
      rho = point%prim(1, k)
      u1d = pointd%prim(2, k)
      u1 = point%prim(2, k)
      u2d = pointd%prim(3, k)
      u2 = point%prim(3, k)
      prd = pointd%prim(4, k)
      pr = point%prim(4, k)
      betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
      beta = 0.5d0*rho/pr
      pointd%q(1, k) = rhod/rho + 2.5d0*betad/beta - betad*(u1*u1+u2*u2)&
&       - beta*(u1d*u1+u1*u1d+u2d*u2+u2*u2d)
      point%q(1, k) = DLOG(rho) + DLOG(beta)*2.5d0 - beta*(u1*u1+u2*u2)
      two_times_betad = 2.0d0*betad
      two_times_beta = 2.0d0*beta
      pointd%q(2, k) = two_times_betad*u1 + two_times_beta*u1d
      point%q(2, k) = two_times_beta*u1
      pointd%q(3, k) = two_times_betad*u2 + two_times_beta*u2d
      point%q(3, k) = two_times_beta*u2
      pointd%q(4, k) = -two_times_betad
      point%q(4, k) = -two_times_beta
    END DO
  END SUBROUTINE EVAL_Q_VARIABLES_D

  SUBROUTINE EVAL_Q_VARIABLES()
    IMPLICIT NONE
    INTEGER :: k
    REAL*8 :: rho, u1, u2, pr, beta
    REAL*8 :: two_times_beta
    INTRINSIC DLOG
!
    DO k=1,max_points
      rho = point%prim(1, k)
      u1 = point%prim(2, k)
      u2 = point%prim(3, k)
      pr = point%prim(4, k)
      beta = 0.5d0*rho/pr
      point%q(1, k) = DLOG(rho) + DLOG(beta)*2.5d0 - beta*(u1*u1+u2*u2)
      two_times_beta = 2.0d0*beta
      point%q(2, k) = two_times_beta*u1
      point%q(3, k) = two_times_beta*u2
      point%q(4, k) = -two_times_beta
    END DO
  END SUBROUTINE EVAL_Q_VARIABLES

!  Differentiation of eval_q_derivatives in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: *(point.dq) *(point.qm)
!   with respect to varying inputs: *(point.x) *(point.y) *(point.q)
!                *(point.dq) *(point.qm)
!   Plus diff mem management of: point.x:in point.y:in point.q:in
!                point.dq:in point.qm:in
  SUBROUTINE EVAL_Q_DERIVATIVES_D()
    IMPLICIT NONE
    INTEGER :: i, k, r, nbh
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_id, y_id, x_kd, y_kd
    REAL*8 :: delx, dely, dist, weights
    REAL*8 :: delxd, delyd, distd, weightsd
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrd, sum_dely_sqrd, sum_delx_delyd
    REAL*8 :: sum_delx_delq(4), sum_dely_delq(4)
    REAL*8 :: sum_delx_delqd(4), sum_dely_delqd(4)
    REAL*8 :: det, delq, temp
    REAL*8 :: detd
    REAL*8 :: one_by_det
    REAL*8 :: one_by_detd
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1d
    DO i=1,local_points
      x_id = pointd%x(i)
      x_i = point%x(i)
      y_id = pointd%y(i)
      y_i = point%y(i)
      sum_delx_sqr = 0.d0
      sum_dely_sqr = 0.d0
      sum_delx_dely = 0.d0
      sum_delx_delq = 0.d0
      sum_dely_delq = 0.d0
      pointd%qm(1, :, i) = pointd%q(:, i)
      point%qm(1, :, i) = point%q(:, i)
      pointd%qm(2, :, i) = pointd%q(:, i)
      point%qm(2, :, i) = point%q(:, i)
      sum_delx_delqd = 0.0_8
      sum_delx_delyd = 0.0_8
      sum_delx_sqrd = 0.0_8
      sum_dely_sqrd = 0.0_8
      sum_dely_delqd = 0.0_8
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        DO r=1,4
          IF (point%q(r, nbh) .GT. point%qm(1, r, i)) THEN
            pointd%qm(1, r, i) = pointd%q(r, nbh)
            point%qm(1, r, i) = point%q(r, nbh)
          END IF
          IF (point%q(r, nbh) .LT. point%qm(2, r, i)) THEN
            pointd%qm(2, r, i) = pointd%q(r, nbh)
            point%qm(2, r, i) = point%q(r, nbh)
          END IF
        END DO
        x_kd = pointd%x(nbh)
        x_k = point%x(nbh)
        y_kd = pointd%y(nbh)
        y_k = point%y(nbh)
        delxd = x_kd - x_id
        delx = x_k - x_i
        delyd = y_kd - y_id
        dely = y_k - y_i
        arg1d = delxd*delx + delx*delxd + delyd*dely + dely*delyd
        arg1 = delx*delx + dely*dely
        IF (arg1 .EQ. 0.0) THEN
          distd = 0.0_8
        ELSE
          distd = arg1d/(2.D0*DSQRT(arg1))
        END IF
        dist = DSQRT(arg1)
        IF (dist .GT. 0.0 .OR. (dist .LT. 0.0 .AND. power .EQ. INT(power))) THEN
          weightsd = power*dist**(power-1)*distd
        ELSE IF (dist .EQ. 0.0 .AND. power .EQ. 1.0) THEN
          weightsd = distd
        ELSE
          weightsd = 0.0
        END IF
        weights = dist**power
        sum_delx_sqrd = sum_delx_sqrd + (delxd*delx+delx*delxd)*weights &
&         + delx**2*weightsd
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqrd = sum_dely_sqrd + (delyd*dely+dely*delyd)*weights &
&         + dely**2*weightsd
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_delyd = sum_delx_delyd + (delxd*dely+delx*delyd)*&
&         weights + delx*dely*weightsd
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        sum_delx_delqd = sum_delx_delqd + (weightsd*delx+weights*delxd)*&
&         (point%q(:, nbh)-point%q(:, i)) + weights*delx*(pointd%q(:, &
&         nbh)-pointd%q(:, i))
        sum_delx_delq = sum_delx_delq + weights*delx*(point%q(:, nbh)-&
&         point%q(:, i))
        sum_dely_delqd = sum_dely_delqd + (weightsd*dely+weights*delyd)*&
&         (point%q(:, nbh)-point%q(:, i)) + weights*dely*(pointd%q(:, &
&         nbh)-pointd%q(:, i))
        sum_dely_delq = sum_dely_delq + weights*dely*(point%q(:, nbh)-&
&         point%q(:, i))
      END DO
      detd = sum_delx_sqrd*sum_dely_sqr + sum_delx_sqr*sum_dely_sqrd - &
&       sum_delx_delyd*sum_delx_dely - sum_delx_dely*sum_delx_delyd
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      one_by_detd = -(detd/det**2)
      one_by_det = 1.0d0/det
      pointd%dq(1, :, i) = (sum_delx_delqd*sum_dely_sqr+sum_delx_delq*&
&       sum_dely_sqrd-sum_dely_delqd*sum_delx_dely-sum_dely_delq*&
&       sum_delx_delyd)*one_by_det + (sum_delx_delq*sum_dely_sqr-&
&       sum_dely_delq*sum_delx_dely)*one_by_detd
      point%dq(1, :, i) = (sum_delx_delq*sum_dely_sqr-sum_dely_delq*&
&       sum_delx_dely)*one_by_det
      pointd%dq(2, :, i) = (sum_dely_delqd*sum_delx_sqr+sum_dely_delq*&
&       sum_delx_sqrd-sum_delx_delqd*sum_delx_dely-sum_delx_delq*&
&       sum_delx_delyd)*one_by_det + (sum_dely_delq*sum_delx_sqr-&
&       sum_delx_delq*sum_delx_dely)*one_by_detd
      point%dq(2, :, i) = (sum_dely_delq*sum_delx_sqr-sum_delx_delq*&
&       sum_delx_dely)*one_by_det
    END DO
  END SUBROUTINE EVAL_Q_DERIVATIVES_D

  SUBROUTINE EVAL_Q_DERIVATIVES()
    IMPLICIT NONE
    INTEGER :: i, k, r, nbh
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: delx, dely, dist, weights
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delq(4), sum_dely_delq(4)
    REAL*8 :: det, delq, temp
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    REAL*8 :: arg1
    DO i=1,local_points
      x_i = point%x(i)
      y_i = point%y(i)
      sum_delx_sqr = 0.d0
      sum_dely_sqr = 0.d0
      sum_delx_dely = 0.d0
      sum_delx_delq = 0.d0
      sum_dely_delq = 0.d0
      point%qm(1, :, i) = point%q(:, i)
      point%qm(2, :, i) = point%q(:, i)
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        DO r=1,4
          IF (point%q(r, nbh) .GT. point%qm(1, r, i)) point%qm(1, r, i)&
&            = point%q(r, nbh)
          IF (point%q(r, nbh) .LT. point%qm(2, r, i)) point%qm(2, r, i)&
&            = point%q(r, nbh)
        END DO
        x_k = point%x(nbh)
        y_k = point%y(nbh)
        delx = x_k - x_i
        dely = y_k - y_i
        arg1 = delx*delx + dely*dely
        dist = DSQRT(arg1)
        weights = dist**power
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        sum_delx_delq = sum_delx_delq + weights*delx*(point%q(:, nbh)-&
&         point%q(:, i))
        sum_dely_delq = sum_dely_delq + weights*dely*(point%q(:, nbh)-&
&         point%q(:, i))
      END DO
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      one_by_det = 1.0d0/det
      point%dq(1, :, i) = (sum_delx_delq*sum_dely_sqr-sum_dely_delq*&
&       sum_delx_dely)*one_by_det
      point%dq(2, :, i) = (sum_dely_delq*sum_delx_sqr-sum_delx_delq*&
&       sum_delx_dely)*one_by_det
    END DO
  END SUBROUTINE EVAL_Q_DERIVATIVES

!  Differentiation of eval_q_inner_loop in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: *(point.temp)
!   with respect to varying inputs: *(point.x) *(point.y) *(point.q)
!                *(point.dq) *(point.temp)
!   Plus diff mem management of: point.x:in point.y:in point.q:in
!                point.dq:in point.temp:in
  SUBROUTINE EVAL_Q_INNER_LOOP_D()
    IMPLICIT NONE
    INTEGER :: i
    INTEGER :: k, r, nbh
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_id, y_id, x_kd, y_kd
    REAL*8 :: delx, dely, dist, weights
    REAL*8 :: delxd, delyd, distd, weightsd
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrd, sum_dely_sqrd, sum_delx_delyd
    REAL*8 :: det, temp
    REAL*8 :: detd
    REAL*8 :: one_by_det
    REAL*8 :: one_by_detd
    REAL*8 :: sum_delx_delq1, sum_delx_delq2, sum_delx_delq3, &
&   sum_delx_delq4
    REAL*8 :: sum_delx_delq1d, sum_delx_delq2d, sum_delx_delq3d, &
&   sum_delx_delq4d
    REAL*8 :: sum_dely_delq1, sum_dely_delq2, sum_dely_delq3, &
&   sum_dely_delq4
    REAL*8 :: sum_dely_delq1d, sum_dely_delq2d, sum_dely_delq3d, &
&   sum_dely_delq4d
    REAL*8 :: q1, q2, q3, q4
    REAL*8 :: q1d, q2d, q3d, q4d
    REAL*8 :: temp1, temp2
    REAL*8 :: temp1d, temp2d
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1d
    DO i=1,local_points
      x_id = pointd%x(i)
      x_i = point%x(i)
      y_id = pointd%y(i)
      y_i = point%y(i)
      sum_delx_sqr = 0.d0
      sum_dely_sqr = 0.d0
      sum_delx_dely = 0.d0
      temp1 = 0.d0
      temp2 = 0.d0
      sum_delx_delq1 = 0.d0
      sum_delx_delq2 = 0.d0
      sum_delx_delq3 = 0.d0
      sum_delx_delq4 = 0.d0
      sum_dely_delq1 = 0.d0
      sum_dely_delq2 = 0.d0
      sum_dely_delq3 = 0.d0
      sum_dely_delq4 = 0.d0
      q1d = pointd%q(1, i)
      q1 = point%q(1, i)
      q2d = pointd%q(2, i)
      q2 = point%q(2, i)
      q3d = pointd%q(3, i)
      q3 = point%q(3, i)
      q4d = pointd%q(4, i)
      q4 = point%q(4, i)
      sum_delx_delyd = 0.0_8
      sum_dely_delq1d = 0.0_8
      sum_dely_delq2d = 0.0_8
      sum_dely_delq3d = 0.0_8
      sum_dely_delq4d = 0.0_8
      sum_delx_sqrd = 0.0_8
      sum_delx_delq1d = 0.0_8
      sum_delx_delq2d = 0.0_8
      sum_delx_delq3d = 0.0_8
      sum_delx_delq4d = 0.0_8
      sum_dely_sqrd = 0.0_8
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        x_kd = pointd%x(nbh)
        x_k = point%x(nbh)
        y_kd = pointd%y(nbh)
        y_k = point%y(nbh)
        delxd = x_kd - x_id
        delx = x_k - x_i
        delyd = y_kd - y_id
        dely = y_k - y_i
        arg1d = delxd*delx + delx*delxd + delyd*dely + dely*delyd
        arg1 = delx*delx + dely*dely
        IF (arg1 .EQ. 0.0) THEN
          distd = 0.0_8
        ELSE
          distd = arg1d/(2.D0*DSQRT(arg1))
        END IF
        dist = DSQRT(arg1)
        IF (dist .GT. 0.0 .OR. (dist .LT. 0.0 .AND. power .EQ. INT(power))) THEN
          weightsd = power*dist**(power-1)*distd
        ELSE IF (dist .EQ. 0.0 .AND. power .EQ. 1.0) THEN
          weightsd = distd
        ELSE
          weightsd = 0.0
        END IF
        weights = dist**power
        sum_delx_sqrd = sum_delx_sqrd + (delxd*delx+delx*delxd)*weights &
&         + delx**2*weightsd
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqrd = sum_dely_sqrd + (delyd*dely+dely*delyd)*weights &
&         + dely**2*weightsd
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_delyd = sum_delx_delyd + (delxd*dely+delx*delyd)*&
&         weights + delx*dely*weightsd
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        temp1d = q1d - 0.5d0*(delxd*point%dq(1, 1, i)+delx*pointd%dq(1, &
&         1, i)+delyd*point%dq(2, 1, i)+dely*pointd%dq(2, 1, i))
        temp1 = q1 - 0.5d0*(delx*point%dq(1, 1, i)+dely*point%dq(2, 1, i&
&         ))
        temp2d = pointd%q(1, nbh) - 0.5d0*(delxd*point%dq(1, 1, nbh)+&
&         delx*pointd%dq(1, 1, nbh)+delyd*point%dq(2, 1, nbh)+dely*&
&         pointd%dq(2, 1, nbh))
        temp2 = point%q(1, nbh) - 0.5d0*(delx*point%dq(1, 1, nbh)+dely*&
&         point%dq(2, 1, nbh))
        sum_delx_delq1d = sum_delx_delq1d + (weightsd*delx+weights*delxd&
&         )*(temp2-temp1) + weights*delx*(temp2d-temp1d)
        sum_delx_delq1 = sum_delx_delq1 + weights*delx*(temp2-temp1)
        sum_dely_delq1d = sum_dely_delq1d + (weightsd*dely+weights*delyd&
&         )*(temp2-temp1) + weights*dely*(temp2d-temp1d)
        sum_dely_delq1 = sum_dely_delq1 + weights*dely*(temp2-temp1)
        temp1d = q2d - 0.5d0*(delxd*point%dq(1, 2, i)+delx*pointd%dq(1, &
&         2, i)+delyd*point%dq(2, 2, i)+dely*pointd%dq(2, 2, i))
        temp1 = q2 - 0.5d0*(delx*point%dq(1, 2, i)+dely*point%dq(2, 2, i&
&         ))
        temp2d = pointd%q(2, nbh) - 0.5d0*(delxd*point%dq(1, 2, nbh)+&
&         delx*pointd%dq(1, 2, nbh)+delyd*point%dq(2, 2, nbh)+dely*&
&         pointd%dq(2, 2, nbh))
        temp2 = point%q(2, nbh) - 0.5d0*(delx*point%dq(1, 2, nbh)+dely*&
&         point%dq(2, 2, nbh))
        sum_delx_delq2d = sum_delx_delq2d + (weightsd*delx+weights*delxd&
&         )*(temp2-temp1) + weights*delx*(temp2d-temp1d)
        sum_delx_delq2 = sum_delx_delq2 + weights*delx*(temp2-temp1)
        sum_dely_delq2d = sum_dely_delq2d + (weightsd*dely+weights*delyd&
&         )*(temp2-temp1) + weights*dely*(temp2d-temp1d)
        sum_dely_delq2 = sum_dely_delq2 + weights*dely*(temp2-temp1)
        temp1d = q3d - 0.5d0*(delxd*point%dq(1, 3, i)+delx*pointd%dq(1, &
&         3, i)+delyd*point%dq(2, 3, i)+dely*pointd%dq(2, 3, i))
        temp1 = q3 - 0.5d0*(delx*point%dq(1, 3, i)+dely*point%dq(2, 3, i&
&         ))
        temp2d = pointd%q(3, nbh) - 0.5d0*(delxd*point%dq(1, 3, nbh)+&
&         delx*pointd%dq(1, 3, nbh)+delyd*point%dq(2, 3, nbh)+dely*&
&         pointd%dq(2, 3, nbh))
        temp2 = point%q(3, nbh) - 0.5d0*(delx*point%dq(1, 3, nbh)+dely*&
&         point%dq(2, 3, nbh))
        sum_delx_delq3d = sum_delx_delq3d + (weightsd*delx+weights*delxd&
&         )*(temp2-temp1) + weights*delx*(temp2d-temp1d)
        sum_delx_delq3 = sum_delx_delq3 + weights*delx*(temp2-temp1)
        sum_dely_delq3d = sum_dely_delq3d + (weightsd*dely+weights*delyd&
&         )*(temp2-temp1) + weights*dely*(temp2d-temp1d)
        sum_dely_delq3 = sum_dely_delq3 + weights*dely*(temp2-temp1)
        temp1d = q4d - 0.5d0*(delxd*point%dq(1, 4, i)+delx*pointd%dq(1, &
&         4, i)+delyd*point%dq(2, 4, i)+dely*pointd%dq(2, 4, i))
        temp1 = q4 - 0.5d0*(delx*point%dq(1, 4, i)+dely*point%dq(2, 4, i&
&         ))
        temp2d = pointd%q(4, nbh) - 0.5d0*(delxd*point%dq(1, 4, nbh)+&
&         delx*pointd%dq(1, 4, nbh)+delyd*point%dq(2, 4, nbh)+dely*&
&         pointd%dq(2, 4, nbh))
        temp2 = point%q(4, nbh) - 0.5d0*(delx*point%dq(1, 4, nbh)+dely*&
&         point%dq(2, 4, nbh))
        sum_delx_delq4d = sum_delx_delq4d + (weightsd*delx+weights*delxd&
&         )*(temp2-temp1) + weights*delx*(temp2d-temp1d)
        sum_delx_delq4 = sum_delx_delq4 + weights*delx*(temp2-temp1)
        sum_dely_delq4d = sum_dely_delq4d + (weightsd*dely+weights*delyd&
&         )*(temp2-temp1) + weights*dely*(temp2d-temp1d)
        sum_dely_delq4 = sum_dely_delq4 + weights*dely*(temp2-temp1)
      END DO
      detd = sum_delx_sqrd*sum_dely_sqr + sum_delx_sqr*sum_dely_sqrd - &
&       sum_delx_delyd*sum_delx_dely - sum_delx_dely*sum_delx_delyd
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      one_by_detd = -(detd/det**2)
      one_by_det = 1.0d0/det
      pointd%temp(1, 1, i) = one_by_detd*(sum_delx_delq1*sum_dely_sqr-&
&       sum_dely_delq1*sum_delx_dely) + one_by_det*(sum_delx_delq1d*&
&       sum_dely_sqr+sum_delx_delq1*sum_dely_sqrd-sum_dely_delq1d*&
&       sum_delx_dely-sum_dely_delq1*sum_delx_delyd)
      point%temp(1, 1, i) = one_by_det*(sum_delx_delq1*sum_dely_sqr-&
&       sum_dely_delq1*sum_delx_dely)
      pointd%temp(1, 2, i) = one_by_detd*(sum_delx_delq2*sum_dely_sqr-&
&       sum_dely_delq2*sum_delx_dely) + one_by_det*(sum_delx_delq2d*&
&       sum_dely_sqr+sum_delx_delq2*sum_dely_sqrd-sum_dely_delq2d*&
&       sum_delx_dely-sum_dely_delq2*sum_delx_delyd)
      point%temp(1, 2, i) = one_by_det*(sum_delx_delq2*sum_dely_sqr-&
&       sum_dely_delq2*sum_delx_dely)
      pointd%temp(1, 3, i) = one_by_detd*(sum_delx_delq3*sum_dely_sqr-&
&       sum_dely_delq3*sum_delx_dely) + one_by_det*(sum_delx_delq3d*&
&       sum_dely_sqr+sum_delx_delq3*sum_dely_sqrd-sum_dely_delq3d*&
&       sum_delx_dely-sum_dely_delq3*sum_delx_delyd)
      point%temp(1, 3, i) = one_by_det*(sum_delx_delq3*sum_dely_sqr-&
&       sum_dely_delq3*sum_delx_dely)
      pointd%temp(1, 4, i) = one_by_detd*(sum_delx_delq4*sum_dely_sqr-&
&       sum_dely_delq4*sum_delx_dely) + one_by_det*(sum_delx_delq4d*&
&       sum_dely_sqr+sum_delx_delq4*sum_dely_sqrd-sum_dely_delq4d*&
&       sum_delx_dely-sum_dely_delq4*sum_delx_delyd)
      point%temp(1, 4, i) = one_by_det*(sum_delx_delq4*sum_dely_sqr-&
&       sum_dely_delq4*sum_delx_dely)
      pointd%temp(2, 1, i) = one_by_detd*(sum_dely_delq1*sum_delx_sqr-&
&       sum_delx_delq1*sum_delx_dely) + one_by_det*(sum_dely_delq1d*&
&       sum_delx_sqr+sum_dely_delq1*sum_delx_sqrd-sum_delx_delq1d*&
&       sum_delx_dely-sum_delx_delq1*sum_delx_delyd)
      point%temp(2, 1, i) = one_by_det*(sum_dely_delq1*sum_delx_sqr-&
&       sum_delx_delq1*sum_delx_dely)
      pointd%temp(2, 2, i) = one_by_detd*(sum_dely_delq2*sum_delx_sqr-&
&       sum_delx_delq2*sum_delx_dely) + one_by_det*(sum_dely_delq2d*&
&       sum_delx_sqr+sum_dely_delq2*sum_delx_sqrd-sum_delx_delq2d*&
&       sum_delx_dely-sum_delx_delq2*sum_delx_delyd)
      point%temp(2, 2, i) = one_by_det*(sum_dely_delq2*sum_delx_sqr-&
&       sum_delx_delq2*sum_delx_dely)
      pointd%temp(2, 3, i) = one_by_detd*(sum_dely_delq3*sum_delx_sqr-&
&       sum_delx_delq3*sum_delx_dely) + one_by_det*(sum_dely_delq3d*&
&       sum_delx_sqr+sum_dely_delq3*sum_delx_sqrd-sum_delx_delq3d*&
&       sum_delx_dely-sum_delx_delq3*sum_delx_delyd)
      point%temp(2, 3, i) = one_by_det*(sum_dely_delq3*sum_delx_sqr-&
&       sum_delx_delq3*sum_delx_dely)
      pointd%temp(2, 4, i) = one_by_detd*(sum_dely_delq4*sum_delx_sqr-&
&       sum_delx_delq4*sum_delx_dely) + one_by_det*(sum_dely_delq4d*&
&       sum_delx_sqr+sum_dely_delq4*sum_delx_sqrd-sum_delx_delq4d*&
&       sum_delx_dely-sum_delx_delq4*sum_delx_delyd)
      point%temp(2, 4, i) = one_by_det*(sum_dely_delq4*sum_delx_sqr-&
&       sum_delx_delq4*sum_delx_dely)
    END DO
  END SUBROUTINE EVAL_Q_INNER_LOOP_D

  SUBROUTINE EVAL_Q_INNER_LOOP()
    IMPLICIT NONE
    INTEGER :: i
    INTEGER :: k, r, nbh
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: delx, dely, dist, weights
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: det, temp
    REAL*8 :: one_by_det
    REAL*8 :: sum_delx_delq1, sum_delx_delq2, sum_delx_delq3, &
&   sum_delx_delq4
    REAL*8 :: sum_dely_delq1, sum_dely_delq2, sum_dely_delq3, &
&   sum_dely_delq4
    REAL*8 :: q1, q2, q3, q4
    REAL*8 :: temp1, temp2
    INTRINSIC DSQRT
    REAL*8 :: arg1
    DO i=1,local_points
      x_i = point%x(i)
      y_i = point%y(i)
      sum_delx_sqr = 0.d0
      sum_dely_sqr = 0.d0
      sum_delx_dely = 0.d0
      temp1 = 0.d0
      temp2 = 0.d0
      sum_delx_delq1 = 0.d0
      sum_delx_delq2 = 0.d0
      sum_delx_delq3 = 0.d0
      sum_delx_delq4 = 0.d0
      sum_dely_delq1 = 0.d0
      sum_dely_delq2 = 0.d0
      sum_dely_delq3 = 0.d0
      sum_dely_delq4 = 0.d0
      q1 = point%q(1, i)
      q2 = point%q(2, i)
      q3 = point%q(3, i)
      q4 = point%q(4, i)
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        x_k = point%x(nbh)
        y_k = point%y(nbh)
        delx = x_k - x_i
        dely = y_k - y_i
        arg1 = delx*delx + dely*dely
        dist = DSQRT(arg1)
        weights = dist**power
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        temp1 = q1 - 0.5d0*(delx*point%dq(1, 1, i)+dely*point%dq(2, 1, i&
&         ))
        temp2 = point%q(1, nbh) - 0.5d0*(delx*point%dq(1, 1, nbh)+dely*&
&         point%dq(2, 1, nbh))
        sum_delx_delq1 = sum_delx_delq1 + weights*delx*(temp2-temp1)
        sum_dely_delq1 = sum_dely_delq1 + weights*dely*(temp2-temp1)
        temp1 = q2 - 0.5d0*(delx*point%dq(1, 2, i)+dely*point%dq(2, 2, i&
&         ))
        temp2 = point%q(2, nbh) - 0.5d0*(delx*point%dq(1, 2, nbh)+dely*&
&         point%dq(2, 2, nbh))
        sum_delx_delq2 = sum_delx_delq2 + weights*delx*(temp2-temp1)
        sum_dely_delq2 = sum_dely_delq2 + weights*dely*(temp2-temp1)
        temp1 = q3 - 0.5d0*(delx*point%dq(1, 3, i)+dely*point%dq(2, 3, i&
&         ))
        temp2 = point%q(3, nbh) - 0.5d0*(delx*point%dq(1, 3, nbh)+dely*&
&         point%dq(2, 3, nbh))
        sum_delx_delq3 = sum_delx_delq3 + weights*delx*(temp2-temp1)
        sum_dely_delq3 = sum_dely_delq3 + weights*dely*(temp2-temp1)
        temp1 = q4 - 0.5d0*(delx*point%dq(1, 4, i)+dely*point%dq(2, 4, i&
&         ))
        temp2 = point%q(4, nbh) - 0.5d0*(delx*point%dq(1, 4, nbh)+dely*&
&         point%dq(2, 4, nbh))
        sum_delx_delq4 = sum_delx_delq4 + weights*delx*(temp2-temp1)
        sum_dely_delq4 = sum_dely_delq4 + weights*dely*(temp2-temp1)
      END DO
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      one_by_det = 1.0d0/det
      point%temp(1, 1, i) = one_by_det*(sum_delx_delq1*sum_dely_sqr-&
&       sum_dely_delq1*sum_delx_dely)
      point%temp(1, 2, i) = one_by_det*(sum_delx_delq2*sum_dely_sqr-&
&       sum_dely_delq2*sum_delx_dely)
      point%temp(1, 3, i) = one_by_det*(sum_delx_delq3*sum_dely_sqr-&
&       sum_dely_delq3*sum_delx_dely)
      point%temp(1, 4, i) = one_by_det*(sum_delx_delq4*sum_dely_sqr-&
&       sum_dely_delq4*sum_delx_dely)
      point%temp(2, 1, i) = one_by_det*(sum_dely_delq1*sum_delx_sqr-&
&       sum_delx_delq1*sum_delx_dely)
      point%temp(2, 2, i) = one_by_det*(sum_dely_delq2*sum_delx_sqr-&
&       sum_delx_delq2*sum_delx_dely)
      point%temp(2, 3, i) = one_by_det*(sum_dely_delq3*sum_delx_sqr-&
&       sum_delx_delq3*sum_delx_dely)
      point%temp(2, 4, i) = one_by_det*(sum_dely_delq4*sum_delx_sqr-&
&       sum_delx_delq4*sum_delx_dely)
    END DO
  END SUBROUTINE EVAL_Q_INNER_LOOP

!  Differentiation of eval_update_innerloop in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: *(point.dq)
!   with respect to varying inputs: *(point.dq) *(point.temp)
!   Plus diff mem management of: point.dq:in point.temp:in
  SUBROUTINE EVAL_UPDATE_INNERLOOP_D()
    IMPLICIT NONE
    INTEGER :: i
    DO i=1,local_points
      pointd%dq(1, 1, i) = pointd%temp(1, 1, i)
      point%dq(1, 1, i) = point%temp(1, 1, i)
      pointd%dq(1, 2, i) = pointd%temp(1, 2, i)
      point%dq(1, 2, i) = point%temp(1, 2, i)
      pointd%dq(1, 3, i) = pointd%temp(1, 3, i)
      point%dq(1, 3, i) = point%temp(1, 3, i)
      pointd%dq(1, 4, i) = pointd%temp(1, 4, i)
      point%dq(1, 4, i) = point%temp(1, 4, i)
      pointd%dq(2, 1, i) = pointd%temp(2, 1, i)
      point%dq(2, 1, i) = point%temp(2, 1, i)
      pointd%dq(2, 2, i) = pointd%temp(2, 2, i)
      point%dq(2, 2, i) = point%temp(2, 2, i)
      pointd%dq(2, 3, i) = pointd%temp(2, 3, i)
      point%dq(2, 3, i) = point%temp(2, 3, i)
      pointd%dq(2, 4, i) = pointd%temp(2, 4, i)
      point%dq(2, 4, i) = point%temp(2, 4, i)
    END DO
  END SUBROUTINE EVAL_UPDATE_INNERLOOP_D

  SUBROUTINE EVAL_UPDATE_INNERLOOP()
    IMPLICIT NONE
    INTEGER :: i
    DO i=1,local_points
      point%dq(1, 1, i) = point%temp(1, 1, i)
      point%dq(1, 2, i) = point%temp(1, 2, i)
      point%dq(1, 3, i) = point%temp(1, 3, i)
      point%dq(1, 4, i) = point%temp(1, 4, i)
      point%dq(2, 1, i) = point%temp(2, 1, i)
      point%dq(2, 2, i) = point%temp(2, 2, i)
      point%dq(2, 3, i) = point%temp(2, 3, i)
      point%dq(2, 4, i) = point%temp(2, 4, i)
    END DO
  END SUBROUTINE EVAL_UPDATE_INNERLOOP

!  Differentiation of qtilde_to_primitive in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: u1 u2 pr rho
!   with respect to varying inputs: qtilde
  SUBROUTINE QTILDE_TO_PRIMITIVE_D(qtilde, qtilded, u1, u1d, u2, u2d, &
&   rho, rhod, pr, prd)
    IMPLICIT NONE
    REAL*8 :: qtilde(4), u1, u2, rho, pr
    REAL*8 :: qtilded(4), u1d, u2d, rhod, prd
    REAL*8 :: beta, temp, temp1, temp2
    REAL*8 :: betad, tempd, temp1d, temp2d
    REAL*8 :: q1, q2, q3, q4
    REAL*8 :: q1d, q2d, q3d, q4d
    INTRINSIC DLOG
    INTRINSIC DEXP
    q1d = qtilded(1)
    q1 = qtilde(1)
    q2d = qtilded(2)
    q2 = qtilde(2)
    q3d = qtilded(3)
    q3 = qtilde(3)
    q4d = qtilded(4)
    q4 = qtilde(4)
    betad = -(0.5d0*q4d)
    beta = -(q4*0.5d0)
    tempd = -(0.5d0*betad/beta**2)
    temp = 0.5d0/beta
    u1d = q2d*temp + q2*tempd
    u1 = q2*temp
    u2d = q3d*temp + q3*tempd
    u2 = q3*temp
    temp1d = q1d + betad*(u1*u1+u2*u2) + beta*(u1d*u1+u1*u1d+u2d*u2+u2*&
&     u2d)
    temp1 = q1 + beta*(u1*u1+u2*u2)
    temp2d = temp1d - betad/beta/(gamma-1)
    temp2 = temp1 - DLOG(beta)/(gamma-1)
    rhod = temp2d*DEXP(temp2)
    rho = DEXP(temp2)
    prd = rhod*temp + rho*tempd
    pr = rho*temp
  END SUBROUTINE QTILDE_TO_PRIMITIVE_D

  SUBROUTINE QTILDE_TO_PRIMITIVE(qtilde, u1, u2, rho, pr)
    IMPLICIT NONE
    REAL*8 :: qtilde(4), u1, u2, rho, pr
    REAL*8 :: beta, temp, temp1, temp2
    REAL*8 :: q1, q2, q3, q4
    INTRINSIC DLOG
    INTRINSIC DEXP
    q1 = qtilde(1)
    q2 = qtilde(2)
    q3 = qtilde(3)
    q4 = qtilde(4)
    beta = -(q4*0.5d0)
    temp = 0.5d0/beta
    u1 = q2*temp
    u2 = q3*temp
    temp1 = q1 + beta*(u1*u1+u2*u2)
    temp2 = temp1 - DLOG(beta)/(gamma-1)
    rho = DEXP(temp2)
    pr = rho*temp
  END SUBROUTINE QTILDE_TO_PRIMITIVE

END MODULE Q_VARIABLES_MOD_DIFF
