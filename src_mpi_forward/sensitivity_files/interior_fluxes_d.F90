!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
MODULE INTERIOR_FLUXES_MOD_DIFF
!	First written on 14.10.2016.
!	updated on Sep 23, 2017
!	
  USE DATA_STRUCTURE_MOD_DIFF
  USE SPLIT_FLUXES_MOD_DIFF
  USE Q_VARIABLES_MOD_DIFF
  USE LIMITERS_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of interior_dgx_pos in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: *(point.x) *(point.y) *(point.nx)
!                *(point.ny) *(point.q) *(point.dq) *(point.qm)
!   Plus diff mem management of: point.x:in point.y:in point.nx:in
!                point.ny:in point.q:in point.dq:in point.qm:in
!	This subroutine evaluates the interior flux derivative dGx_pos
  SUBROUTINE INTERIOR_DGX_POS_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txd, tyd, nxd, nyd
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_id, y_id, x_kd, y_kd
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxd, delyd, detd, one_by_detd
    REAL*8 :: dels, deln
    REAL*8 :: delsd, delnd
!		
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrd, sum_dely_sqrd, sum_delx_delyd
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: distd, weightsd
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsd, deln_weightsd
    REAL*8 :: maxi(4), mini(4)
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1d
    DOUBLE PRECISION :: temp0
    REAL*8, DIMENSION(4) :: temp1
    REAL*8, DIMENSION(4) :: temp2
    REAL*8, DIMENSION(4) :: temp3
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_id = pointd%x(i)
    x_i = point%x(i)
    y_id = pointd%y(i)
    y_i = point%y(i)
    nxd = pointd%nx(i)
    nx = point%nx(i)
    nyd = pointd%ny(i)
    ny = point%ny(i)
    txd = nyd
    tx = ny
    tyd = -nxd
    ty = -nx
    sum_delx_delyd = 0.0_8
    sum_delx_sqrd = 0.0_8
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    sum_dely_sqrd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_kd = pointd%x(k)
      x_k = point%x(k)
      y_kd = pointd%y(k)
      y_k = point%y(k)
      delxd = x_kd - x_id
      delx = x_k - x_i
      delyd = y_kd - y_id
      dely = y_k - y_i
      delsd = tx*delxd + delx*txd + ty*delyd + dely*tyd
      dels = delx*tx + dely*ty
      delnd = nx*delxd + delx*nxd + ny*delyd + dely*nyd
      deln = delx*nx + dely*ny
      arg1d = 2*dels*delsd + 2*deln*delnd
      arg1 = dels*dels + deln*deln
      temp0 = DSQRT(arg1)
      IF (arg1 .EQ. 0.0) THEN
        distd = 0.0_8
      ELSE
        distd = arg1d/(2.D0*DSQRT(arg1))
      END IF
      dist = temp0
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        weightsd = 0.0_8
      ELSE
        weightsd = power*dist**(power-1)*distd
        END IF
      weights = dist**power
      dels_weightsd = weights*delsd + dels*weightsd
      dels_weights = dels*weights
      deln_weightsd = weights*delnd + deln*weightsd
      deln_weights = deln*weights
      sum_delx_sqrd = sum_delx_sqrd + dels_weights*delsd + dels*&
&       dels_weightsd
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqrd = sum_dely_sqrd + deln_weights*delnd + deln*&
&       deln_weightsd
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_delyd = sum_delx_delyd + deln_weights*delsd + dels*&
&       deln_weightsd
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(point%dq(1, :, i)*delxd+delx*&
&       pointd%dq(1, :, i)+point%dq(2, :, i)*delyd+dely*pointd%dq(2, :, &
&       i))
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(point%dq(1, :, k)*delxd+delx*&
&       pointd%dq(1, :, k)+point%dq(2, :, k)*delyd+dely*pointd%dq(2, :, &
&       k))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
      CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
      temp1 = delx*point%dq(1, :, i) + dely*point%dq(2, :, i)
      qtilde_id = pointd%q(:, i) - 0.5d0*(temp1*phi_id+phi_i*(point%dq(1&
&       , :, i)*delxd+delx*pointd%dq(1, :, i)+point%dq(2, :, i)*delyd+&
&       dely*pointd%dq(2, :, i)))
      qtilde_i = point%q(:, i) - 0.5d0*(phi_i*temp1)
      temp2 = delx*point%dq(1, :, k) + dely*point%dq(2, :, k)
      qtilde_kd = pointd%q(:, k) - 0.5d0*(temp2*phi_kd+phi_k*(point%dq(1&
&       , :, k)*delxd+delx*pointd%dq(1, :, k)+point%dq(2, :, k)*delyd+&
&       dely*pointd%dq(2, :, k)))
      qtilde_k = point%q(:, k) - 0.5d0*(phi_k*temp2)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GXP_D(g_i, g_id, nx, nxd, ny, nyd, u1, u1d, u2, u2d, rho&
&               , rhod, pr, prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GXP_D(g_k, g_kd, nx, nxd, ny, nyd, u1, u1d, u2, u2d, rho&
&               , rhod, pr, prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id) + (g_k-&
&       g_i)*dels_weightsd
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id) + (g_k-&
&       g_i)*deln_weightsd
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    detd = sum_dely_sqr*sum_delx_sqrd + sum_delx_sqr*sum_dely_sqrd - 2*&
&     sum_delx_dely*sum_delx_delyd
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_detd = -(detd/det**2)
    one_by_det = 1.d0/det
    temp3 = sum_delx_delf*sum_dely_sqr - sum_dely_delf*sum_delx_dely
    gd = one_by_det*(sum_dely_sqr*sum_delx_delfd+sum_delx_delf*&
&     sum_dely_sqrd-sum_delx_dely*sum_dely_delfd-sum_dely_delf*&
&     sum_delx_delyd) + temp3*one_by_detd
    g = temp3*one_by_det
  END SUBROUTINE INTERIOR_DGX_POS_D

!	This subroutine evaluates the interior flux derivative dGx_pos
  SUBROUTINE INTERIOR_DGX_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
!		
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: maxi(4), mini(4)
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GXP(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GXP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGX_POS

!  Differentiation of interior_dgx_neg in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: *(point.x) *(point.y) *(point.nx)
!                *(point.ny) *(point.q) *(point.dq) *(point.qm)
!   Plus diff mem management of: point.x:in point.y:in point.nx:in
!                point.ny:in point.q:in point.dq:in point.qm:in
!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGX_NEG_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_id, y_id, x_kd, y_kd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txd, tyd, nxd, nyd
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxd, delyd, detd, one_by_detd
    REAL*8 :: dels, deln
    REAL*8 :: delsd, delnd
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrd, sum_dely_sqrd, sum_delx_delyd
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: distd, weightsd
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsd, deln_weightsd
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1d
    DOUBLE PRECISION :: temp0
    REAL*8, DIMENSION(4) :: temp1
    REAL*8, DIMENSION(4) :: temp2
    REAL*8, DIMENSION(4) :: temp3
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_id = pointd%x(i)
    x_i = point%x(i)
    y_id = pointd%y(i)
    y_i = point%y(i)
    nxd = pointd%nx(i)
    nx = point%nx(i)
    nyd = pointd%ny(i)
    ny = point%ny(i)
    txd = nyd
    tx = ny
    tyd = -nxd
    ty = -nx
    sum_delx_delyd = 0.0_8
    sum_delx_sqrd = 0.0_8
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    sum_dely_sqrd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_kd = pointd%x(k)
      x_k = point%x(k)
      y_kd = pointd%y(k)
      y_k = point%y(k)
      delxd = x_kd - x_id
      delx = x_k - x_i
      delyd = y_kd - y_id
      dely = y_k - y_i
      delsd = tx*delxd + delx*txd + ty*delyd + dely*tyd
      dels = delx*tx + dely*ty
      delnd = nx*delxd + delx*nxd + ny*delyd + dely*nyd
      deln = delx*nx + dely*ny
      arg1d = 2*dels*delsd + 2*deln*delnd
      arg1 = dels*dels + deln*deln
      temp0 = DSQRT(arg1)
      IF (arg1 .EQ. 0.0) THEN
        distd = 0.0_8
      ELSE
        distd = arg1d/(2.D0*DSQRT(arg1))
      END IF
      dist = temp0
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        weightsd = 0.0_8
      ELSE
        weightsd = power*dist**(power-1)*distd
      END IF
      weights = dist**power
      dels_weightsd = weights*delsd + dels*weightsd
      dels_weights = dels*weights
      deln_weightsd = weights*delnd + deln*weightsd
      deln_weights = deln*weights
      sum_delx_sqrd = sum_delx_sqrd + dels_weights*delsd + dels*&
&       dels_weightsd
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqrd = sum_dely_sqrd + deln_weights*delnd + deln*&
&       deln_weightsd
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_delyd = sum_delx_delyd + deln_weights*delsd + dels*&
&       deln_weightsd
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(point%dq(1, :, i)*delxd+delx*&
&       pointd%dq(1, :, i)+point%dq(2, :, i)*delyd+dely*pointd%dq(2, :, &
&       i))
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(point%dq(1, :, k)*delxd+delx*&
&       pointd%dq(1, :, k)+point%dq(2, :, k)*delyd+dely*pointd%dq(2, :, &
&       k))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
      CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
      temp1 = delx*point%dq(1, :, i) + dely*point%dq(2, :, i)
      qtilde_id = pointd%q(:, i) - 0.5d0*(temp1*phi_id+phi_i*(point%dq(1&
&       , :, i)*delxd+delx*pointd%dq(1, :, i)+point%dq(2, :, i)*delyd+&
&       dely*pointd%dq(2, :, i)))
      qtilde_i = point%q(:, i) - 0.5d0*(phi_i*temp1)
      temp2 = delx*point%dq(1, :, k) + dely*point%dq(2, :, k)
      qtilde_kd = pointd%q(:, k) - 0.5d0*(temp2*phi_kd+phi_k*(point%dq(1&
&       , :, k)*delxd+delx*pointd%dq(1, :, k)+point%dq(2, :, k)*delyd+&
&       dely*pointd%dq(2, :, k)))
      qtilde_k = point%q(:, k) - 0.5d0*(phi_k*temp2)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GXN_D(g_i, g_id, nx, nxd, ny, nyd, u1, u1d, u2, u2d, rho&
&               , rhod, pr, prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GXN_D(g_k, g_kd, nx, nxd, ny, nyd, u1, u1d, u2, u2d, rho&
&               , rhod, pr, prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id) + (g_k-&
&       g_i)*dels_weightsd
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id) + (g_k-&
&       g_i)*deln_weightsd
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    detd = sum_dely_sqr*sum_delx_sqrd + sum_delx_sqr*sum_dely_sqrd - 2*&
&     sum_delx_dely*sum_delx_delyd
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_detd = -(detd/det**2)
    one_by_det = 1.d0/det
    temp3 = sum_delx_delf*sum_dely_sqr - sum_dely_delf*sum_delx_dely
    gd = one_by_det*(sum_dely_sqr*sum_delx_delfd+sum_delx_delf*&
&     sum_dely_sqrd-sum_delx_dely*sum_dely_delfd-sum_dely_delf*&
&     sum_delx_delyd) + temp3*one_by_detd
    g = temp3*one_by_det
  END SUBROUTINE INTERIOR_DGX_NEG_D

!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGX_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GXN(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GXN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGX_NEG

!  Differentiation of interior_dgy_pos in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: *(point.x) *(point.y) *(point.nx)
!                *(point.ny) *(point.q) *(point.dq) *(point.qm)
!   Plus diff mem management of: point.x:in point.y:in point.nx:in
!                point.ny:in point.q:in point.dq:in point.qm:in
!	This subroutine evaluates the interior flux derivative dGx_neg
!
!
  SUBROUTINE INTERIOR_DGY_POS_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_id, y_id, x_kd, y_kd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txd, tyd, nxd, nyd
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxd, delyd, detd, one_by_detd
    REAL*8 :: dels, deln
    REAL*8 :: delsd, delnd
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrd, sum_dely_sqrd, sum_delx_delyd
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: distd, weightsd
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsd, deln_weightsd
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1d
    DOUBLE PRECISION :: temp0
    REAL*8, DIMENSION(4) :: temp1
    REAL*8, DIMENSION(4) :: temp2
    REAL*8, DIMENSION(4) :: temp3
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_id = pointd%x(i)
    x_i = point%x(i)
    y_id = pointd%y(i)
    y_i = point%y(i)
    nxd = pointd%nx(i)
    nx = point%nx(i)
    nyd = pointd%ny(i)
    ny = point%ny(i)
    txd = nyd
    tx = ny
    tyd = -nxd
    ty = -nx
    sum_delx_delyd = 0.0_8
    sum_delx_sqrd = 0.0_8
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    sum_dely_sqrd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%ypos_nbhs(i)
      k = point%ypos_conn(i, j)
      x_kd = pointd%x(k)
      x_k = point%x(k)
      y_kd = pointd%y(k)
      y_k = point%y(k)
      delxd = x_kd - x_id
      delx = x_k - x_i
      delyd = y_kd - y_id
      dely = y_k - y_i
      delsd = tx*delxd + delx*txd + ty*delyd + dely*tyd
      dels = delx*tx + dely*ty
      delnd = nx*delxd + delx*nxd + ny*delyd + dely*nyd
      deln = delx*nx + dely*ny
      arg1d = 2*dels*delsd + 2*deln*delnd
      arg1 = dels*dels + deln*deln
      temp0 = DSQRT(arg1)
      IF (arg1 .EQ. 0.0) THEN
        distd = 0.0_8
      ELSE
        distd = arg1d/(2.D0*DSQRT(arg1))
      END IF
      dist = temp0
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        weightsd = 0.0_8
      ELSE
        weightsd = power*dist**(power-1)*distd
      END IF
      weights = dist**power
      dels_weightsd = weights*delsd + dels*weightsd
      dels_weights = dels*weights
      deln_weightsd = weights*delnd + deln*weightsd
      deln_weights = deln*weights
      sum_delx_sqrd = sum_delx_sqrd + dels_weights*delsd + dels*&
&       dels_weightsd
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqrd = sum_dely_sqrd + deln_weights*delnd + deln*&
&       deln_weightsd
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_delyd = sum_delx_delyd + deln_weights*delsd + dels*&
&       deln_weightsd
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(point%dq(1, :, i)*delxd+delx*&
&       pointd%dq(1, :, i)+point%dq(2, :, i)*delyd+dely*pointd%dq(2, :, &
&       i))
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(point%dq(1, :, k)*delxd+delx*&
&       pointd%dq(1, :, k)+point%dq(2, :, k)*delyd+dely*pointd%dq(2, :, &
&       k))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
      CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
      temp1 = delx*point%dq(1, :, i) + dely*point%dq(2, :, i)
      qtilde_id = pointd%q(:, i) - 0.5d0*(temp1*phi_id+phi_i*(point%dq(1&
&       , :, i)*delxd+delx*pointd%dq(1, :, i)+point%dq(2, :, i)*delyd+&
&       dely*pointd%dq(2, :, i)))
      qtilde_i = point%q(:, i) - 0.5d0*(phi_i*temp1)
      temp2 = delx*point%dq(1, :, k) + dely*point%dq(2, :, k)
      qtilde_kd = pointd%q(:, k) - 0.5d0*(temp2*phi_kd+phi_k*(point%dq(1&
&       , :, k)*delxd+delx*pointd%dq(1, :, k)+point%dq(2, :, k)*delyd+&
&       dely*pointd%dq(2, :, k)))
      qtilde_k = point%q(:, k) - 0.5d0*(phi_k*temp2)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GYP_D(g_i, g_id, nx, nxd, ny, nyd, u1, u1d, u2, u2d, rho&
&               , rhod, pr, prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GYP_D(g_k, g_kd, nx, nxd, ny, nyd, u1, u1d, u2, u2d, rho&
&               , rhod, pr, prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id) + (g_k-&
&       g_i)*dels_weightsd
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id) + (g_k-&
&       g_i)*deln_weightsd
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    detd = sum_dely_sqr*sum_delx_sqrd + sum_delx_sqr*sum_dely_sqrd - 2*&
&     sum_delx_dely*sum_delx_delyd
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_detd = -(detd/det**2)
    one_by_det = 1.d0/det
    temp3 = sum_dely_delf*sum_delx_sqr - sum_delx_delf*sum_delx_dely
    gd = one_by_det*(sum_delx_sqr*sum_dely_delfd+sum_dely_delf*&
&     sum_delx_sqrd-sum_delx_dely*sum_delx_delfd-sum_delx_delf*&
&     sum_delx_delyd) + temp3*one_by_detd
    g = temp3*one_by_det
  END SUBROUTINE INTERIOR_DGY_POS_D

!	This subroutine evaluates the interior flux derivative dGx_neg
!
!
  SUBROUTINE INTERIOR_DGY_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%ypos_nbhs(i)
      k = point%ypos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GYP(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GYP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGY_POS

!  Differentiation of interior_dgy_neg in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: *(point.x) *(point.y) *(point.nx)
!                *(point.ny) *(point.q) *(point.dq) *(point.qm)
!   Plus diff mem management of: point.x:in point.y:in point.nx:in
!                point.ny:in point.q:in point.dq:in point.qm:in
!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGY_NEG_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txd, tyd, nxd, nyd
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_id, y_id, x_kd, y_kd
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxd, delyd, detd, one_by_detd
    REAL*8 :: dels, deln
    REAL*8 :: delsd, delnd
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrd, sum_dely_sqrd, sum_delx_delyd
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: distd, weightsd
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsd, deln_weightsd
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1d
    DOUBLE PRECISION :: temp0
    REAL*8, DIMENSION(4) :: temp1
    REAL*8, DIMENSION(4) :: temp2
    REAL*8, DIMENSION(4) :: temp3
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_id = pointd%x(i)
    x_i = point%x(i)
    y_id = pointd%y(i)
    y_i = point%y(i)
    nxd = pointd%nx(i)
    nx = point%nx(i)
    nyd = pointd%ny(i)
    ny = point%ny(i)
    txd = nyd
    tx = ny
    tyd = -nxd
    ty = -nx
    sum_delx_delyd = 0.0_8
    sum_delx_sqrd = 0.0_8
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    sum_dely_sqrd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%yneg_nbhs(i)
      k = point%yneg_conn(i, j)
      x_kd = pointd%x(k)
      x_k = point%x(k)
      y_kd = pointd%y(k)
      y_k = point%y(k)
      delxd = x_kd - x_id
      delx = x_k - x_i
      delyd = y_kd - y_id
      dely = y_k - y_i
      delsd = tx*delxd + delx*txd + ty*delyd + dely*tyd
      dels = delx*tx + dely*ty
      delnd = nx*delxd + delx*nxd + ny*delyd + dely*nyd
      deln = delx*nx + dely*ny
      arg1d = 2*dels*delsd + 2*deln*delnd
      arg1 = dels*dels + deln*deln
      temp0 = DSQRT(arg1)
      IF (arg1 .EQ. 0.0) THEN
        distd = 0.0_8
      ELSE
        distd = arg1d/(2.D0*DSQRT(arg1))
      END IF
      dist = temp0
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        weightsd = 0.0_8
      ELSE
        weightsd = power*dist**(power-1)*distd
      END IF
      weights = dist**power
      dels_weightsd = weights*delsd + dels*weightsd
      dels_weights = dels*weights
      deln_weightsd = weights*delnd + deln*weightsd
      deln_weights = deln*weights
      sum_delx_sqrd = sum_delx_sqrd + dels_weights*delsd + dels*&
&       dels_weightsd
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqrd = sum_dely_sqrd + deln_weights*delnd + deln*&
&       deln_weightsd
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_delyd = sum_delx_delyd + deln_weights*delsd + dels*&
&       deln_weightsd
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(point%dq(1, :, i)*delxd+delx*&
&       pointd%dq(1, :, i)+point%dq(2, :, i)*delyd+dely*pointd%dq(2, :, &
&       i))
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(point%dq(1, :, k)*delxd+delx*&
&       pointd%dq(1, :, k)+point%dq(2, :, k)*delyd+dely*pointd%dq(2, :, &
&       k))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
      CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
      temp1 = delx*point%dq(1, :, i) + dely*point%dq(2, :, i)
      qtilde_id = pointd%q(:, i) - 0.5d0*(temp1*phi_id+phi_i*(point%dq(1&
&       , :, i)*delxd+delx*pointd%dq(1, :, i)+point%dq(2, :, i)*delyd+&
&       dely*pointd%dq(2, :, i)))
      qtilde_i = point%q(:, i) - 0.5d0*(phi_i*temp1)
      temp2 = delx*point%dq(1, :, k) + dely*point%dq(2, :, k)
      qtilde_kd = pointd%q(:, k) - 0.5d0*(temp2*phi_kd+phi_k*(point%dq(1&
&       , :, k)*delxd+delx*pointd%dq(1, :, k)+point%dq(2, :, k)*delyd+&
&       dely*pointd%dq(2, :, k)))
      qtilde_k = point%q(:, k) - 0.5d0*(phi_k*temp2)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GYN_D(g_i, g_id, nx, nxd, ny, nyd, u1, u1d, u2, u2d, rho&
&               , rhod, pr, prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GYN_D(g_k, g_kd, nx, nxd, ny, nyd, u1, u1d, u2, u2d, rho&
&               , rhod, pr, prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id) + (g_k-&
&       g_i)*dels_weightsd
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id) + (g_k-&
&       g_i)*deln_weightsd
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    detd = sum_dely_sqr*sum_delx_sqrd + sum_delx_sqr*sum_dely_sqrd - 2*&
&     sum_delx_dely*sum_delx_delyd
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_detd = -(detd/det**2)
    one_by_det = 1.d0/det
    temp3 = sum_dely_delf*sum_delx_sqr - sum_delx_delf*sum_delx_dely
    gd = one_by_det*(sum_delx_sqr*sum_dely_delfd+sum_dely_delf*&
&     sum_delx_sqrd-sum_delx_dely*sum_delx_delfd-sum_delx_delf*&
&     sum_delx_delyd) + temp3*one_by_detd
    g = temp3*one_by_det
  END SUBROUTINE INTERIOR_DGY_NEG_D

!	This subroutine evaluates the interior flux derivative dGx_neg
  SUBROUTINE INTERIOR_DGY_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%yneg_nbhs(i)
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GYN(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GYN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE INTERIOR_DGY_NEG

END MODULE INTERIOR_FLUXES_MOD_DIFF
