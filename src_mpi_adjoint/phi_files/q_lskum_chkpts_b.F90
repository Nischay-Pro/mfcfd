!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE Q_LSKUM_MOD_CHKPTS_DIFF
!	First written on 14.10.2016
!	updated on Dec 26, 2016
!	updated on Dec 29, 2016
  USE DATA_STRUCTURE_MOD_DIFF
  USE POINT_NORMALS_MOD_DIFF
  USE GENERATE_CONNECTIVITY_MOD_DIFF
  USE FPI_SOLVER_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of q_lskum in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: cost_func
!   with respect to varying inputs: point.phi1 point.phi2
!   RW status of diff variables: cost_func:in-killed point.delta:(loc)
!                point.prim:(loc) point.prim_old:(loc) point.q:(loc)
!                point.flux_res:(loc) point.dq:(loc) point.ddq:(loc)
!                point.temp:(loc) point.phi1:out point.phi2:out
  SUBROUTINE Q_LSKUM_CHKPTS_B()
    IMPLICIT NONE
    INTEGER :: i
    ! INTEGER :: ad_count
    INTEGER :: i0
    ! INTEGER :: branch

    INTEGER :: t, r, ijk, k
    INTEGER :: ii1
    integer :: pflag = 1, iflag = 1
    real :: SF

!     Declaration for running the revolve algorithm ...
!    Parameters ..
!
    REAL*8 :: TAKSHT,ADVAN,FSTURN,YUTURN
    PARAMETER (TAKSHT=1,ADVAN=2,FSTURN=3,YUTURN=4)
    REAL*8 :: RESTRE,TRMATE,ERROR
    PARAMETER (RESTRE=5,TRMATE=6,ERROR=7)
!
!  .. Local Scalars ..                                                       
!                                                                               
    INTEGER :: CAPO,CHECK,FINE,INFO,SNAPS,STEPS,WHATDO
    INTEGER :: OLDCAPO,new_itime, ITIME, ITIMS, ITIM
! 
!     .. External Functions ..                                                  
!                                                                               
    INTEGER :: REVOLV, ADJUST, PFS
    EXTERNAL REVOLV, ADJUST
!                                                                               
    intrinsic cpu_time 
    real*8 :: start_time, end_time
!

    real*8, allocatable :: prim_stor(:, :, :), qm_stor(:, :, :, :)
    real*8, allocatable :: q_stor(:, :, :), dq_stor(:, :, :, :)
    real*8, allocatable :: fluxres_stor(:, :, :), delta_stor(:, :)
    real*8, allocatable :: primold_stor(:, :, :), ddq_stor(:, :, :, :)
    real*8, allocatable :: temp_stor(:, :, :, :) !, vorticitysqr_stor(:, :)

!   Allocate store variables

    allocate( prim_stor(0:chkpts, 4, max_points))
    allocate( primold_stor(0:chkpts, 4, max_points))
    allocate( q_stor(0:chkpts, 4, max_points))
    allocate( fluxres_stor(0:chkpts, 4, max_points))
    allocate( dq_stor(0:chkpts, 2, 4, max_points))
    allocate( qm_stor(0:chkpts, 2, 4, max_points))
    allocate( delta_stor(0:chkpts, max_points))
    ! allocate( vorticitysqr_stor(0:chkpts, max_points))
    allocate( ddq_stor(0:chkpts, 3, 4, max_points))
    allocate( temp_stor(0:chkpts, 3, 4, max_points))

!   End of the declaraion for the revolve algorithm ..          
!

!	Assign the initial conditions for the primitive variables ..

    ITIMS = 1
    ITIME = max_iters
    new_itime = ITIME - ITIMS + 1 
    CAPO = 0
    STEPS = new_itime
    FINE = STEPS + CAPO
    CHECK = -1
!   SNAPS = ADJUST(STEPS)                                                    
!
!   Here SNAPS are the no. of checkpoints assigned ..
!
    SNAPS = chkpts
    INFO = 5


    OPEN(UNIT=301,FILE="residue",FORM="FORMATTED",STATUS="REPLACE",ACTION="WRITE")
    ! OPEN(UNIT=302,FILE="residue_b",FORM="FORMATTED",STATUS="REPLACE",ACTION="WRITE")
    
    
    CALL COMPUTE_NORMALS()
    CALL GENERATE_CONNECTIVITY()
    total_enstrophyb = 1.0d0
    ! DO i=1,max_points
    !     point%vor_area(i) = 1.0d0
    ! END DO
    ! DO i=1,max_points
    !     point%phi1(:, i) = 1.0d0
    !     point%phi2(:, i) = 1.0d0
    ! END DO

    IF (rank .EQ. 0) THEN
        WRITE(*, *) 
        WRITE(*, *) '%%%%-Normals and connectivity generated-%%%'
        WRITE(*, *) 
    END IF

    IF (rank .EQ. 0) THEN
        WRITE(*, *) '%%%%%%%%%%%%%-Iterations begin-%%%%%%%%%%%%'
        WRITE(*, *) 
    END IF
!   Some initialisations for the revolve alogorithm ..  
    IF (restart .EQ. 0) itr = 0
    ! ad_count = 1

!   The revolve algorithm starts here ..
!
!
    10 CONTINUE
    OLDCAPO = CAPO
    WHATDO = REVOLV(CHECK,CAPO,FINE,SNAPS,INFO,SF,PFS)
!  
!                                                                             
!   The below if condition stores the check-points ..                       
!                                                                                
    IF ((WHATDO.EQ.TAKSHT) .AND. (INFO.GT.1)) THEN                                                                          
        do i=1,max_points
            delta_stor(check, i) = point%delta(i)
            ! vorticitysqr_stor(check, i) = point%vorticity_sqr(i)
            do r = 1, 4
                q_stor(check, r, i) = point%q(r,i)
                prim_stor(check, r, i) = point%prim(r,i)
                primold_stor(check, r, i) = point%prim_old(r,i)
                fluxres_stor(check, r, i) = point%flux_res(r,i)
                do k = 1, 2
                    dq_stor(check, k, r, i) = point%dq(k , r , i)
                    qm_stor(check, k, r, i) = point%qm(k , r , i)
                end do
                do k = 1, 3
                    ddq_stor(check, k, r, i) = point%ddq(k , r , i)
                    temp_stor(check, k, r, i) = point%temp(k , r , i)
                end do
            enddo
        enddo
    END IF
!
    !   The below if condition runs the forward mode without 
!   storing the intermediate values ..
!                                                                                                                                                  
    IF ((WHATDO.EQ.ADVAN) .AND. (INFO.GT.2)) THEN
!         WRITE (*,FMT=9010) CAPO
        do ijk=OLDCAPO, CAPO-1
            ITIM = ijk+ITIMS
            ITIM = ITIM + itr
            IF (rank .EQ. 0) THEN
                if(iflag == 1) then
                    write (*,*)
                    write (*,*) 'prediction of needed forward steps :', PFS
                    write (*,*) 'slowdown factor :', SF
                    write (*,*)
                    iflag = 0
                end if
            END IF
            CALL FPI_SOLVER(ITIM)
            IF (rank .EQ. 0) THEN
                if (pflag == 1) then
                write(*,'(a12,i8,a15,e30.20)')'iterations:',ITIM,'residue:',residue
                write(301, *) itim, residue
                end if
            end if
        end do
    END IF

!   The below if condition runs the first reverse step.
!   This requires the initialisation of the adjoint vectors ..
!
!
120 IF ((WHATDO.EQ.FSTURN) .AND. (INFO.GT.2)) THEN
        !
        ITIM = CAPO + ITIMS
        ITIM = ITIM + itr
        ! pointb%vorticity_sqr = 0.0_8
        pointb%delta = 0.0_8
        pointb%prim = 0.0_8
        pointb%prim_old = 0.0_8
        pointb%q = 0.0_8
        pointb%flux_res = 0.0_8
        pointb%dq = 0.0_8
        pointb%ddq = 0.0_8
        pointb%temp = 0.0_8
        pointb%phi1 = 0.0_8
        pointb%phi2 = 0.0_8
        IF (rank .EQ. 0) THEN
            write(*,*)
            write(*,*)'%%%%%%%%-Adjoint computations begin-%%%%%%%'
            write(*,*)
        END IF
        pflag = 0
        CALL FPI_SOLVER_B(ITIM)
        total_enstrophyb = 0.0_8
        IF (rank .EQ. 0) THEN
            ! if (pflag == 1) then
                write(*,'(a12,i8,a15,e30.20)')'iterations_back:',ITIM,'residue:',residue
                ! write(301, *) itim, residue
            ! end if
        end if
    END IF

    !      The below if condition runs the subsequent reverse steps .. 
!                                                                                                                                                  
    IF ((WHATDO.EQ.YUTURN) .AND. (INFO.GT.2)) THEN
        ITIM = CAPO + ITIMS
        ITIM = ITIM + itr
        CALL FPI_SOLVER_B(ITIM)
        total_enstrophyb = 0.0_8
        IF (rank .EQ. 0) THEN
            ! if (pflag == 1) then
                write(*,'(a12,i8,a15,e30.20)')'iterations_back:',ITIM,'residue:',residue
                ! write(301, *) itim, residue
            ! end if
        end if
    END IF
!
!
!           The below if condition restores the state vectors 
!             at the check points ..  
!                                                                                                                                                  
    IF ((WHATDO.EQ.RESTRE) .AND. (INFO.GT.2)) THEN
!
        do i=1,max_points
            point%delta(i) = delta_stor(check, i)
            ! point%vorticity_sqr(i) = vorticitysqr_stor(check, i)
            do r = 1, 4
                point%q(r,i) = q_stor(check, r, i)
                point%prim(r,i) = prim_stor(check, r, i)
                point%prim_old(r,i) = primold_stor(check, r, i)
                point%flux_res(r,i) = fluxres_stor(check, r, i)
                do k = 1, 2
                    point%dq(k, r, i) = dq_stor(check, k, r, i)
                    point%qm(k, r, i) = qm_stor(check, k, r, i)
                end do
                do k = 1, 3
                    point%ddq(k , r , i) = ddq_stor(check, k, r, i)
                    point%temp(k , r , i) = temp_stor(check, k, r, i)
                end do
            enddo
        enddo  
    END IF
!
!
    IF (WHATDO.EQ.ERROR) THEN
        WRITE (*,FMT=*) ' irregular termination of treeverse'
        IF (INFO.EQ.10) THEN
            WRITE (*,FMT=*) ' number of checkpoints stored exceeds CHEKUP,'
            WRITE (*,FMT=*) ' increase constant CHEKUP and recompile'
        END IF
!
        IF (INFO.EQ.11) THEN
            WRITE (*,FMT=*) ' number of checkpoints stored = ', CHECK + 1,' exceeds SNAPS,'
            WRITE (*,FMT=*) ' ensure SNAPS > 0 and ', 'increase initial FINE'
        END IF

        IF (INFO.EQ.12) WRITE (*,FMT=*) ' error occurs in NUMFRW'
        IF (INFO.EQ.13) THEN
            WRITE (*,FMT=*) ' enhancement of FINE, SNAPS = ', CHECK + 1,'checkpoints stored, increase SNAPS'
        END IF
        IF (INFO.EQ.14) THEN
            WRITE (*,FMT=*) ' number of SNAPS = ',SNAPS, ' exceeds CHEKUP,'
            WRITE (*,FMT=*) ' increase constant CHEKUP and recompile'
        END IF
        IF (INFO.EQ.15) THEN
            WRITE (*,FMT=*) ' number of reps exceeds REPSUP, '
            WRITE (*,FMT=*) ' increase constant REPSUP and recompile'
        END IF
    END IF
!                                       
!
    IF ((WHATDO.EQ.TRMATE) .OR. (WHATDO.EQ.ERROR)) THEN
        GO TO 20
    ELSE
        GO TO 10
    END IF
    20 CONTINUE
!
!
    9000 FORMAT (' takeshot at',I6)
    9010 FORMAT (' advance to',I7)
    9020 FORMAT (' firsturn at',I6)
    9030 FORMAT (' youturn at',I7)
    9040 FORMAT (' restore at',I7)
!                  
    CALL PRINT_PHI_OUTPUT()                                                                                                                                
!                                                                                                                                                  
!       End of the revolve algorithm ..   

END SUBROUTINE Q_LSKUM_CHKPTS_B

END MODULE Q_LSKUM_MOD_CHKPTS_DIFF
