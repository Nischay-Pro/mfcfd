!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE FPI_SOLVER_MOD_DIFF
#include <petsc/finclude/petscsys.h>
  USE DATA_STRUCTURE_MOD_DIFF
  USE FLUX_RESIDUAL_MOD_DIFF
  USE STATE_UPDATE_MOD_DIFF
  USE Q_VARIABLES_MOD_DIFF
  USE OBJECTIVE_FUNCTION_MOD_DIFF
  USE POST_PROCESSING_MOD
  USE STAGNATION_VALUES_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of fpi_solver in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: cost_func *(point.prim) *(point.prim_old)
!                *(point.flux_res) *(point.q) *(point.dq) *(point.ddq)
!                *(point.temp) *(point.phi1) *(point.phi2) *(point.delta)
!   with respect to varying inputs: *(point.prim) *(point.prim_old)
!                *(point.flux_res) *(point.q) *(point.dq) *(point.ddq)
!                *(point.temp) *(point.phi1) *(point.phi2) *(point.delta)
!   Plus diff mem management of: point.prim:in point.prim_old:in
!                point.flux_res:in point.q:in point.dq:in point.ddq:in
!                point.temp:in point.phi1:in point.phi2:in point.delta:in
  SUBROUTINE FPI_SOLVER_B(t)
    IMPLICIT NONE
    INTEGER :: t, i, rk, j, z, nbh, k
    INTRINSIC DSQRT
    INTRINSIC DLOG10
    INTEGER :: branch
    PetscErrorCode :: ierr
    DO i=1,local_points
      point%prim_old(:, i) = point%prim(:, i)
    END DO
    CALL FUNC_DELTA()
! Perform 4-stage, 3-order SSPRK update
    DO rk=1,rks
      CALL PUSHREAL8ARRAY(point%q, 4*max_points)
      CALL EVAL_Q_VARIABLES()

      CALL PUSHREAL8ARRAY(point%dq, 2*4*max_points)
      CALL EVAL_Q_DERIVATIVES()
      
      CALL UPDATE_BEGIN_DQ_GHOST()
      CALL UPDATE_BEGIN_QM_GHOST()
      CALL UPDATE_END_DQ_GHOST()
      CALL UPDATE_END_QM_GHOST()
!Update the ghost values from the owned process
      CALL PUSHREAL8ARRAY(point%ddq, 3*4*max_points)
      CALL EVAL_Q_DOUBLE_DERIVATIVES()
      
      CALL UPDATE_BEGIN_DDQ_GHOST()
      CALL UPDATE_END_DDQ_GHOST()
      
      IF (inner_iterations .NE. 0) THEN
        DO i=1,inner_iterations
          CALL EVAL_DQ_INNER_LOOP()
          CALL EVAL_UPDATE_INNERLOOP_2()

          CALL UPDATE_BEGIN_DQ_GHOST()
          CALL UPDATE_END_DQ_GHOST()

          CALL EVAL_DDQ_INNER_LOOP()
          CALL EVAL_UPDATE_INNERLOOP_3()
          CALL UPDATE_BEGIN_DDQ_GHOST()
          CALL UPDATE_END_DDQ_GHOST()
        END DO
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF

      CALL PUSHREAL8ARRAY(point%flux_res, 4*max_points)
      CALL CAL_FLUX_RESIDUAL()

      CALL PUSHREAL8ARRAY(point%prim, 4*max_points)
      CALL STATE_UPDATE(rk)
      CALL UPDATE_BEGIN_PRIM_GHOST()
      CALL UPDATE_END_PRIM_GHOST()
! start updating primitive values
    END DO
! call objective_function()
    CALL MPI_REDUCE(sum_res_sqr, gsum_res_sqr, 1, mpi_double, mpi_sum, 0&
&             , petsc_comm_world, ierr)
    CALL MPI_BCAST(gsum_res_sqr, 1, mpi_double, 0, petsc_comm_world, &
&            ierr)
    CALL OBJECTIVE_FUNCTION_J_B()

    ! CALL UPDATE_BEGIN_PRIMB_GHOST_()
    ! CALL UPDATE_END_PRIMB_GHOST_()
    ! CALL UPDATE_BEGIN_QB_GHOST_()
    ! CALL UPDATE_END_QB_GHOST_()
    ! CALL UPDATE_BEGIN_DQB_GHOST_()
    ! CALL UPDATE_END_DQB_GHOST_()
    ! CALL UPDATE_BEGIN_DDQB_GHOST_()
    ! CALL UPDATE_END_DDQB_GHOST_()

      DO rk=rks,1,-1
      ! IF (rank .EQ. 1) THEN
      !   z = 14
      !   write(*,*) rk, 'is rk'
      !   ! write(*,*) pointb%phi1(:,z), ' is Phi1'
      !   ! write(*,*) pointb%phi1(:,z), ' is Phi2'
      !   write(*,*) pointb%prim(:,z), ' is Prim'
      !   write(*,*) pointb%q(:,z), ' is Q'
      !   ! write(*,*) pointb%temp(:,:,z), ' is Temp'
      !   ! write(*,*) pointb%delta(z), ' is Delta'
      !   ! write(*,*) pointb%prim_old(:,z), ' is Prim_Old'
      !   ! DO k=1,point%nbhs(z)
      !       ! nbh = point%conn(z, k)
      !       ! write(*,*) pointb%temp(:,:,nbh), ' is Temp'
      !       ! write(*,*) pointb%delta(nbh), ' is Delta'
      !       ! write(*,*) pointb%prim_old(:,nbh), ' is Prim_Old'
      !       ! write(*,*) pointb%phi1(:,nbh), ' is Phi1-k'
      !       ! write(*,*) pointb%prim(:,nbh), ' is Prim-k'
      !       ! write(*,*) pointb%q(:,nbh), ' is Q'
      !       ! write(*,*) pointb%dq(:,:,nbh), ' is DQ'
      !       ! write(*,*) pointb%ddq(:,:,nbh), ' is DDQ'
      !       ! write(*,*) pointb%flux_res(:,nbh), ' is Flux Res'
      !   ! END DO
      ! END IF
      CALL POPREAL8ARRAY(point%prim, 4*max_points)
      CALL STATE_UPDATE_B(rk)
      CALL UPDATE_BEGIN_PRIMB_GHOST()
      CALL UPDATE_END_PRIMB_GHOST()
      do j = local_points+1, max_points 
        pointb%prim(:, j) = 0.0d0
        pointb%prim_old(:, j) = 0.0d0
      end do
      ! do j = local_points+1, max_points 
      !   pointb%prim( :, j) = 0.0d0
      ! end do
      ! CALL UPDATE_BEGIN_PRIMB_GHOST_()
      ! CALL UPDATE_END_PRIMB_GHOST_()
      
      CALL POPREAL8ARRAY(point%flux_res, 4*max_points)
      CALL CAL_FLUX_RESIDUAL_B()

      CALL POPCONTROL1B(branch)
      ! CALL UPDATE_QB()
      CALL UPDATE_BEGIN_QB_GHOST()
      CALL UPDATE_END_QB_GHOST()
      do j = local_points+1, max_points 
        pointb%q(:, j) = 0.0d0
      end do
      CALL UPDATE_BEGIN_DQB_GHOST()
      CALL UPDATE_END_DQB_GHOST()
      do j = local_points+1, max_points 
        pointb%dq(:, :, j) = 0.0d0
      end do
      CALL UPDATE_BEGIN_DDQB_GHOST()
      CALL UPDATE_END_DDQB_GHOST()
      do j = local_points+1, max_points 
        pointb%ddq(:, :, j) = 0.0d0
      end do


      ! do j = local_points+1, max_points 
      !   pointb%flux_res(:, j) = 0.0d0
      ! end do

      ! IF (branch .EQ. 0) THEN
      !   DO i=inner_iterations,1,-1
      !     ! CALL UPDATE_BEGIN_DQB_GHOST_()
      !     ! CALL UPDATE_END_DQB_GHOST_()
      !     CALL EVAL_UPDATE_INNERLOOP_3_B()
      !     do j = local_points+1, max_points 
      !       pointb%ddq(:, :, j) = 0.0d0
      !     end do
      !     ! CALL UPDATE_BEGIN_DQB_GHOST_()
      !     ! CALL UPDATE_END_DQB_GHOST_()


      !     CALL EVAL_DDQ_INNER_LOOP_B()
      !     do j = local_points+1, max_points 
      !       pointb%temp(:, :, j) = 0.0d0
      !     end do
      !     CALL UPDATE_DQB()
      !     CALL UPDATE_DDQB()

      !     CALL EVAL_UPDATE_INNERLOOP_2_B()
      !     do j = local_points+1, max_points 
      !       pointb%dq(:, :, j) = 0.0d0
      !     end do

      !     CALL EVAL_DQ_INNER_LOOP_B()
      !     do j = local_points+1, max_points 
      !       pointb%temp(:, :, j) = 0.0d0
      !     end do
      !     CALL UPDATE_QB()
      !     CALL UPDATE_DQB()
      !   END DO
      ! END IF

    !   IF (rank .EQ. 1) THEN
    ! !     ! z = 14
    !   write(*,*) rk, 'is rk-pre-qdb'
    !   ! write(*,*) pointb%phi1(:,z), ' is Phi1'
    !   ! write(*,*) pointb%phi1(:,z), ' is Phi2'
    !   ! write(*,*) pointb%prim(:,z), ' is Prim'
    !   write(*,*) pointb%q(:,z), ' is Q'
    !   write(*,*) pointb%ddq(:,:,z), ' is DDQ'
    !   ! write(*,*) pointb%temp(:,:,z), ' is Temp'
    !   ! write(*,*) pointb%delta(z), ' is Delta'
    !   ! write(*,*) pointb%prim_old(:,z), ' is Prim_Old'
    !   DO k=1,point%nbhs(z)
    !       nbh = point%conn(z, k)
    !       ! write(*,*) pointb%temp(:,:,nbh), ' is Temp'
    !       ! write(*,*) pointb%delta(nbh), ' is Delta'
    !       ! write(*,*) pointb%prim_old(:,nbh), ' is Prim_Old'
    !       ! write(*,*) pointb%phi1(:,nbh), ' is Phi1-k'
    !       ! write(*,*) pointb%prim(:,nbh), ' is Prim-k'
    !       write(*,*) pointb%q(:,nbh), ' is Q'
    !       write(*,*) pointb%ddq(:,:,nbh), ' is DDQ'
    !       ! write(*,*) pointb%ddq(:,:,nbh), ' is DDQ'
    !       ! write(*,*) pointb%flux_res(:,nbh), ' is Flux Res'
    !   END DO
    !  END IF

      CALL POPREAL8ARRAY(point%ddq, 3*4*max_points)
      CALL EVAL_Q_DOUBLE_DERIVATIVES_B()
      do j = 1, max_points 
        pointb%ddq(:, :, j) = 0.0d0
      end do
    !   IF (rank .EQ. 1) THEN
    !     ! z = 14
    !   write(*,*) rk, 'is rk-qdb-pre-update'
    !   ! write(*,*) pointb%phi1(:,z), ' is Phi1'
    !   ! write(*,*) pointb%phi1(:,z), ' is Phi2'
    !   ! write(*,*) pointb%prim(:,z), ' is Prim'
    !   write(*,*) pointb%q(:,z), ' is Q'
    !   write(*,*) pointb%dq(:,:,z), ' is DQ'
    !   ! write(*,*) pointb%temp(:,:,z), ' is Temp'
    !   ! write(*,*) pointb%delta(z), ' is Delta'
    !   ! write(*,*) pointb%prim_old(:,z), ' is Prim_Old'
    !   DO k=1,point%nbhs(z)
    !       nbh = point%conn(z, k)
    !       ! write(*,*) pointb%temp(:,:,nbh), ' is Temp'
    !       ! write(*,*) pointb%delta(nbh), ' is Delta'
    !       ! write(*,*) pointb%prim_old(:,nbh), ' is Prim_Old'
    !       ! write(*,*) pointb%phi1(:,nbh), ' is Phi1-k'
    !       ! write(*,*) pointb%prim(:,nbh), ' is Prim-k'
    !       ! write(*,*) pointb%q(:,nbh), ' is Q'
    !       write(*,*) pointb%dq(:,:,nbh), ' is DQ'
    !       ! write(*,*) pointb%ddq(:,:,nbh), ' is DDQ'
    !       ! write(*,*) pointb%flux_res(:,nbh), ' is Flux Res'
    !   END DO
    ! END IF
    CALL UPDATE_BEGIN_DQB_GHOST()
    CALL UPDATE_END_DQB_GHOST()
    do j = local_points+1, max_points 
      pointb%dq(:, :, j) = 0.0d0
    end do
    !   IF (rank .EQ. 1) THEN
    !     ! z = 14
    !   write(*,*) rk, 'is rk-qdb'
    !   ! write(*,*) pointb%phi1(:,z), ' is Phi1'
    !   ! write(*,*) pointb%phi1(:,z), ' is Phi2'
    !   ! write(*,*) pointb%prim(:,z), ' is Prim'
    !   write(*,*) pointb%q(:,z), ' is Q'
    !   write(*,*) pointb%dq(:,:,z), ' is DQ'
    !   ! write(*,*) pointb%temp(:,:,z), ' is Temp'
    !   ! write(*,*) pointb%delta(z), ' is Delta'
    !   ! write(*,*) pointb%prim_old(:,z), ' is Prim_Old'
    !   DO k=1,point%nbhs(z)
    !       nbh = point%conn(z, k)
    !       ! write(*,*) pointb%temp(:,:,nbh), ' is Temp'
    !       ! write(*,*) pointb%delta(nbh), ' is Delta'
    !       ! write(*,*) pointb%prim_old(:,nbh), ' is Prim_Old'
    !       ! write(*,*) pointb%phi1(:,nbh), ' is Phi1-k'
    !       ! write(*,*) pointb%prim(:,nbh), ' is Prim-k'
    !       ! write(*,*) pointb%q(:,nbh), ' is Q'
    !       write(*,*) pointb%dq(:,:,nbh), ' is DQ'
    !       ! write(*,*) pointb%ddq(:,:,nbh), ' is DDQ'
    !       ! write(*,*) pointb%flux_res(:,nbh), ' is Flux Res'
    !   END DO
    !  END IF
      CALL POPREAL8ARRAY(point%dq, 2*4*max_points)
      CALL EVAL_Q_DERIVATIVES_B()

    !   ! IF (rank .EQ. 1) THEN
    !     ! z = 14
    !   write(*,*) rk, 'is rk-post-qdb'
    !   ! write(*,*) pointb%phi1(:,z), ' is Phi1'
    !   ! write(*,*) pointb%phi1(:,z), ' is Phi2'
    !   ! write(*,*) pointb%prim(:,z), ' is Prim'
    !   write(*,*) pointb%q(:,z), ' is Q'
    !   write(*,*) pointb%dq(:,:,z), ' is DQ'
    !   ! write(*,*) pointb%temp(:,:,z), ' is Temp'
    !   ! write(*,*) pointb%delta(z), ' is Delta'
    !   ! write(*,*) pointb%prim_old(:,z), ' is Prim_Old'
    !   ! DO k=1,point%nbhs(z)
    !       ! nbh = point%conn(z, k)
    !       ! write(*,*) pointb%temp(:,:,nbh), ' is Temp'
    !       ! write(*,*) pointb%delta(nbh), ' is Delta'
    !       ! write(*,*) pointb%prim_old(:,nbh), ' is Prim_Old'
    !       ! write(*,*) pointb%phi1(:,nbh), ' is Phi1-k'
    !       ! write(*,*) pointb%prim(:,nbh), ' is Prim-k'
    !       ! write(*,*) pointb%q(:,nbh), ' is Q'
    !       ! write(*,*) pointb%dq(:,:,nbh), ' is DQ'
    !       ! write(*,*) pointb%ddq(:,:,nbh), ' is DDQ'
    !       ! write(*,*) pointb%flux_res(:,nbh), ' is Flux Res'
    !   ! END DO
    ! !  END IF

      CALL UPDATE_BEGIN_QB_GHOST()
      CALL UPDATE_END_QB_GHOST()
      do j = local_points+1, max_points 
        pointb%q(:, j) = 0.0d0
      end do
      CALL POPREAL8ARRAY(point%q, 4*max_points)
      CALL EVAL_Q_VARIABLES_B()
      CALL UPDATE_BEGIN_PRIMB_GHOST()
      CALL UPDATE_END_PRIMB_GHOST()
      do j = local_points+1, max_points 
        pointb%prim(:, j) = 0.0d0
      end do
      ! CALL UPDATE_BEGIN_PRIMB_GHOST_()
      ! CALL UPDATE_END_PRIMB_GHOST_()

    END DO

    ! CALL UPDATE_BEGIN_PRIMB_GHOST_()
    ! CALL UPDATE_END_PRIMB_GHOST_()

    CALL FUNC_DELTA_B()  
    CALL UPDATE_BEGIN_PRIMB_GHOST()
    CALL UPDATE_END_PRIMB_GHOST()
    do j = local_points+1, max_points 
      pointb%prim(:, j) = 0.0d0
    end do
    ! CALL UPDATE_BEGIN_PRIMB_GHOST_()
    ! CALL UPDATE_END_PRIMB_GHOST_()
    DO i=local_points,1,-1
      pointb%prim(:, i) = pointb%prim(:, i) + pointb%prim_old(:, i)
      pointb%prim_old(:, i) = 0.0_8
    END DO

    ! CALL UPDATE_BEGIN_PRIMB_GHOST_()
    ! CALL UPDATE_END_PRIMB_GHOST_()
    ! CALL UPDATE_BEGIN_PRIMB_GHOST_()
    ! CALL UPDATE_END_PRIMB_GHOST_()
    ! CALL UPDATE_BEGIN_QB_GHOST_()
    ! CALL UPDATE_END_QB_GHOST_()
    ! CALL UPDATE_BEGIN_DQB_GHOST_()
    ! CALL UPDATE_END_DQB_GHOST_()
    ! CALL UPDATE_BEGIN_DDQB_GHOST_()
    ! CALL UPDATE_END_DDQB_GHOST_()
  END SUBROUTINE FPI_SOLVER_B

  SUBROUTINE FPI_SOLVER(t)
    IMPLICIT NONE
    INTEGER :: t, i, rk
    INTRINSIC DSQRT
    INTRINSIC DLOG10
    PetscErrorCode :: ierr
    DO i=1,local_points
      point%prim_old(:, i) = point%prim(:, i)
    END DO
    CALL FUNC_DELTA()
! Perform 4-stage, 3-order SSPRK update
    DO rk=1,rks
      CALL EVAL_Q_VARIABLES()
      CALL EVAL_Q_DERIVATIVES()
!Update the ghost values from the owned process
      CALL UPDATE_BEGIN_DQ_GHOST()
      CALL UPDATE_BEGIN_QM_GHOST()
      CALL UPDATE_END_DQ_GHOST()
      CALL UPDATE_END_QM_GHOST()
      CALL EVAL_Q_DOUBLE_DERIVATIVES()
      CALL UPDATE_BEGIN_DDQ_GHOST()
      CALL UPDATE_END_DDQ_GHOST()
      IF (inner_iterations .NE. 0) THEN
        DO i=1,inner_iterations
          CALL EVAL_DQ_INNER_LOOP()
          CALL EVAL_UPDATE_INNERLOOP_2()
          CALL UPDATE_BEGIN_DQ_GHOST()
          CALL UPDATE_END_DQ_GHOST()
          CALL EVAL_DDQ_INNER_LOOP()
          CALL EVAL_UPDATE_INNERLOOP_3()
          CALL UPDATE_BEGIN_DDQ_GHOST()
          CALL UPDATE_END_DDQ_GHOST()
        END DO
      END IF
      CALL CAL_FLUX_RESIDUAL()
      CALL STATE_UPDATE(rk)
! start updating primitive values
      CALL UPDATE_BEGIN_PRIM_GHOST()
      CALL UPDATE_END_PRIM_GHOST()
    END DO
! call objective_function()
    CALL OBJECTIVE_FUNCTION_J()
    CALL MPI_REDUCE(sum_res_sqr, gsum_res_sqr, 1, mpi_double, mpi_sum, 0&
&             , petsc_comm_world, ierr)
    CALL MPI_BCAST(gsum_res_sqr, 1, mpi_double, 0, petsc_comm_world, &
&            ierr)
    res_new = DSQRT(gsum_res_sqr)/plen
    IF (t .LE. 2 .AND. restart .EQ. 0) THEN
      res_old = res_new
      residue = 0.d0
    ELSE
      residue = DLOG10(res_new/res_old)
    END IF
  END SUBROUTINE FPI_SOLVER

END MODULE FPI_SOLVER_MOD_DIFF
