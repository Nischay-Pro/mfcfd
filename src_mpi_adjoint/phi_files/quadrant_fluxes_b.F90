!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE QUADRANT_FLUXES_MOD_DIFF
  !	This module consists of quadrant split fluxes
  !	with respect to the x-coordinate direction ..
    USE PARAMETER_MOD
    IMPLICIT NONE
  !
  !
  
  CONTAINS
  !  Differentiation of flux_quad_gxi in reverse (adjoint) mode (with options fixinterface):
  !   gradient     of useful results: g
  !   with respect to varying inputs: g u1 u2 pr rho
    SUBROUTINE FLUX_QUAD_GXI_B(g, gb, nx, ny, u1, u1b, u2, u2b, rho, rhob&
  &   , pr, prb)
      IMPLICIT NONE
      DOUBLE PRECISION :: g(4), u1, u2, rho, pr
      DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
      DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
      DOUBLE PRECISION :: utb, unb
      DOUBLE PRECISION :: beta
      DOUBLE PRECISION :: betab
      DOUBLE PRECISION :: s1, b1, s2, b2
      DOUBLE PRECISION :: s1b, b1b, s2b, b2b
      DOUBLE PRECISION :: a1neg, a2neg
      DOUBLE PRECISION :: a1negb, a2negb
      DOUBLE PRECISION :: temp1, temp2, temp3, temp4
      DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
      DOUBLE PRECISION :: pr_by_rho, u_sqr
      DOUBLE PRECISION :: pr_by_rhob, u_sqrb
      ! DOUBLE PRECISION :: DERF
      ! INTRINSIC DSQRT
      ! INTRINSIC DEXP
      ! EXTERNAL DERF
      ! EXTERNAL DERF_B
      DOUBLE PRECISION :: result1
      DOUBLE PRECISION :: result1b
      DOUBLE PRECISION :: temp
      DOUBLE PRECISION :: temp0
      DOUBLE PRECISION :: temp5
      DOUBLE PRECISION :: temp6
      DOUBLE PRECISION :: tempb
      DOUBLE PRECISION :: tempb0
      DOUBLE PRECISION :: tempb1
      DOUBLE PRECISION :: tempb2
      DOUBLE PRECISION :: tempb3
      DOUBLE PRECISION :: tempb4
      DOUBLE PRECISION :: tempb5
      DOUBLE PRECISION :: tempb6
      DOUBLE PRECISION :: tempb7
      tx = ny
      ty = -nx
      ut = u1*tx + u2*ty
      un = u1*nx + u2*ny
      beta = 0.5d0*rho/pr
      s1 = ut*DSQRT(beta)
      s2 = un*DSQRT(beta)
      b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
      b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
      CALL PUSHREAL8(s1)
      result1 = DERF(s1)
      a1neg = 0.5d0*(1.0d0-result1)
      CALL PUSHREAL8(s2)
      result1 = DERF(s2)
      a2neg = 0.5d0*(1.0d0-result1)
      pr_by_rho = pr/rho
      u_sqr = ut*ut + un*un
  !	Expressions for the split fluxes ..
      temp1 = 7.0d0*pr_by_rho + u_sqr
      temp2 = 0.5d0*ut*temp1*a1neg
      temp1 = 6.0d0*pr_by_rho + u_sqr
      temp3 = 0.5d0*b1*temp1
      temp1 = ut*a1neg - b1
      temp = DSQRT(beta)
      temp0 = DSQRT(beta)
      tempb = rho*a2neg*gb(4)
      rhob = (temp2-temp3)*a2neg*gb(4)
      a2negb = (temp2-temp3)*rho*gb(4)
      temp2b = tempb
      temp3b = -tempb
      temp4b = -gb(4)
      gb(4) = 0.D0
      tempb0 = 0.5d0*b2*temp1*temp4b
      tempb1 = 0.5d0*rho*un*temp4b
      b2b = temp1*tempb1
      temp1b = b2*tempb1
      utb = a1neg*temp1b
      temp1 = 6.0d0*pr_by_rho + u_sqr
      b1b = 0.5d0*temp1*temp3b - temp1b
      temp1 = 7.0d0*pr_by_rho + u_sqr
      a1negb = 0.5d0*ut*temp1*temp2b + ut*temp1b
      temp1b = 0.5d0*b1*temp3b
      pr_by_rhob = 6.0d0*temp1b
      u_sqrb = temp1b
      tempb2 = 0.5d0*a1neg*temp2b
      temp1b = ut*tempb2
      pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
      u_sqrb = u_sqrb + temp1b
      temp2 = un*a2neg - b2
      temp1b = temp2*rho*gb(3)
      utb = utb + a1neg*temp1b + temp1*tempb2
      temp1 = ut*a1neg - b1
      rhob = rhob + temp2*temp1*gb(3) + un*tempb0
      temp2b = rho*temp1*gb(3)
      unb = a2neg*temp2b + rho*tempb0
      gb(3) = 0.D0
      b2b = b2b - temp2b
      temp1 = pr_by_rho + ut*ut
      temp2 = temp1*a1neg - ut*b1
      a2negb = a2negb + temp2*rho*gb(2) + un*temp2b
      rhob = rhob + temp2*a2neg*gb(2)
      temp2b = rho*a2neg*gb(2)
      gb(2) = 0.D0
      tempb4 = (ut*a1neg-b1)*gb(1)
      tempb3 = rho*a2neg*gb(1)
      a1negb = a1negb + temp1*temp2b + ut*tempb3 + ut*temp1b
      b1b = b1b - ut*temp2b - tempb3 - temp1b
      temp1b = a1neg*temp2b
      pr_by_rhob = pr_by_rhob + temp1b
      a2negb = a2negb + rho*tempb4
      gb(1) = 0.D0
      result1b = -(0.5d0*a2negb)
      CALL ADSTACK_STARTREPEAT()
      CALL POPREAL8(s2)
      CALL ADSTACK_RESETREPEAT()
      CALL ADSTACK_ENDREPEAT()
      s2b = 0.D0
  
      ! CALL DERF_B(s2, s2b, result1b)
      s2b = s2b + (2.0d0/dsqrt(pi))*dexp(-s2**2)*result1b
  
      CALL POPREAL8(s2)
      result1b = -(0.5d0*a1negb)
      CALL ADSTACK_STARTREPEAT()
      CALL POPREAL8(s1)
      CALL ADSTACK_RESETREPEAT()
      CALL ADSTACK_ENDREPEAT()
      s1b = 0.D0
  
      ! CALL DERF_B(s1, s1b, result1b)
      s1b = s1b + (2.0d0/dsqrt(pi))*dexp(-s1**2)*result1b
  
      CALL POPREAL8(s1)
      temp6 = DSQRT(pi*beta)
      tempb6 = 0.5d0*b2b/temp6
      s2b = s2b - DEXP(-(s2**2))*2*s2*tempb6
      unb = unb + temp0*s2b + 2*un*u_sqrb
      IF (pi*beta .EQ. 0.0) THEN
        betab = 0.0
      ELSE
        betab = -(DEXP(-(s2**2))*pi*tempb6/(2.D0*DSQRT(pi*beta)*temp6))
      END IF
      temp5 = DSQRT(pi*beta)
      tempb7 = 0.5d0*b1b/temp5
      s1b = s1b - DEXP(-(s1**2))*2*s1*tempb7
      utb = utb + 2*ut*temp1b + 2*ut*u_sqrb + temp*s1b + a1neg*tempb3 - b1&
  &     *temp2b
      IF (.NOT.pi*beta .EQ. 0.0) betab = betab - DEXP(-(s1**2))*pi*tempb7/&
  &       (2.D0*DSQRT(pi*beta)*temp5)
      IF (.NOT.beta .EQ. 0.0) betab = betab + un*s2b/(2.D0*DSQRT(beta))
      IF (.NOT.beta .EQ. 0.0) betab = betab + ut*s1b/(2.D0*DSQRT(beta))
      tempb5 = 0.5d0*betab/pr
      rhob = rhob + tempb5 - pr*pr_by_rhob/rho**2 + a2neg*tempb4
      prb = pr_by_rhob/rho - rho*tempb5/pr
      u1b = tx*utb + nx*unb
      u2b = ty*utb + ny*unb
    END SUBROUTINE FLUX_QUAD_GXI_B
  
    SUBROUTINE FLUX_QUAD_GXI(g, nx, ny, u1, u2, rho, pr)
      IMPLICIT NONE
      DOUBLE PRECISION :: g(4), u1, u2, rho, pr
      DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
      DOUBLE PRECISION :: beta
      DOUBLE PRECISION :: s1, b1, s2, b2
      DOUBLE PRECISION :: a1neg, a2neg
      DOUBLE PRECISION :: temp1, temp2, temp3, temp4
      DOUBLE PRECISION :: pr_by_rho, u_sqr
      ! DOUBLE PRECISION :: DERF
      ! INTRINSIC DSQRT
      ! INTRINSIC DEXP
      ! EXTERNAL DERF
      DOUBLE PRECISION :: result1
      tx = ny
      ty = -nx
      ut = u1*tx + u2*ty
      un = u1*nx + u2*ny
      beta = 0.5d0*rho/pr
      s1 = ut*DSQRT(beta)
      s2 = un*DSQRT(beta)
      b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
      b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
      result1 = DERF(s1)
      a1neg = 0.5d0*(1.0d0-result1)
      result1 = DERF(s2)
      a2neg = 0.5d0*(1.0d0-result1)
      pr_by_rho = pr/rho
      u_sqr = ut*ut + un*un
  !	Expressions for the split fluxes ..
      g(1) = rho*a2neg*(ut*a1neg-b1)
      temp1 = pr_by_rho + ut*ut
      temp2 = temp1*a1neg - ut*b1
      g(2) = rho*a2neg*temp2
      temp1 = ut*a1neg - b1
      temp2 = un*a2neg - b2
      g(3) = rho*temp1*temp2
      temp1 = 7.0d0*pr_by_rho + u_sqr
      temp2 = 0.5d0*ut*temp1*a1neg
      temp1 = 6.0d0*pr_by_rho + u_sqr
      temp3 = 0.5d0*b1*temp1
      temp1 = ut*a1neg - b1
      temp4 = 0.5d0*rho*un*b2*temp1
      g(4) = rho*a2neg*(temp2-temp3) - temp4
    END SUBROUTINE FLUX_QUAD_GXI
  
  !  Differentiation of flux_quad_gxii in reverse (adjoint) mode (with options fixinterface):
  !   gradient     of useful results: g
  !   with respect to varying inputs: g u1 u2 pr rho
    SUBROUTINE FLUX_QUAD_GXII_B(g, gb, nx, ny, u1, u1b, u2, u2b, rho, rhob&
  &   , pr, prb)
      IMPLICIT NONE
      DOUBLE PRECISION :: g(4), u1, u2, rho, pr
      DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
      DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
      DOUBLE PRECISION :: utb, unb
      DOUBLE PRECISION :: beta
      DOUBLE PRECISION :: betab
      DOUBLE PRECISION :: s1, b1, s2, b2
      DOUBLE PRECISION :: s1b, b1b, s2b, b2b
      DOUBLE PRECISION :: a1pos, a2neg
      DOUBLE PRECISION :: a1posb, a2negb
      DOUBLE PRECISION :: temp1, temp2, temp3, temp4
      DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
      DOUBLE PRECISION :: pr_by_rho, u_sqr
      DOUBLE PRECISION :: pr_by_rhob, u_sqrb
      ! DOUBLE PRECISION :: DERF
      ! INTRINSIC DSQRT
      ! INTRINSIC DEXP
      ! EXTERNAL DERF
      ! EXTERNAL DERF_B
      DOUBLE PRECISION :: result1
      DOUBLE PRECISION :: result1b
      DOUBLE PRECISION :: temp
      DOUBLE PRECISION :: temp0
      DOUBLE PRECISION :: temp5
      DOUBLE PRECISION :: temp6
      DOUBLE PRECISION :: tempb
      DOUBLE PRECISION :: tempb0
      DOUBLE PRECISION :: tempb1
      DOUBLE PRECISION :: tempb2
      DOUBLE PRECISION :: tempb3
      DOUBLE PRECISION :: tempb4
      DOUBLE PRECISION :: tempb5
      DOUBLE PRECISION :: tempb6
      DOUBLE PRECISION :: tempb7
      tx = ny
      ty = -nx
      ut = u1*tx + u2*ty
      un = u1*nx + u2*ny
      beta = 0.5d0*rho/pr
      s1 = ut*DSQRT(beta)
      s2 = un*DSQRT(beta)
      b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
      b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
      CALL PUSHREAL8(s1)
      result1 = DERF(s1)
      a1pos = 0.5d0*(1.d0+result1)
      CALL PUSHREAL8(s2)
      result1 = DERF(s2)
      a2neg = 0.5d0*(1.d0-result1)
      pr_by_rho = pr/rho
      u_sqr = ut*ut + un*un
  !	Expressions for the split fluxes ..
      temp1 = 7.0d0*pr_by_rho + u_sqr
      temp2 = 0.5d0*ut*temp1*a1pos
      temp1 = 6.0d0*pr_by_rho + u_sqr
      temp3 = 0.5d0*b1*temp1
      temp1 = ut*a1pos + b1
      temp = DSQRT(beta)
      temp0 = DSQRT(beta)
      tempb = rho*a2neg*gb(4)
      rhob = (temp2+temp3)*a2neg*gb(4)
      a2negb = (temp2+temp3)*rho*gb(4)
      temp2b = tempb
      temp3b = tempb
      temp4b = -gb(4)
      gb(4) = 0.D0
      tempb0 = 0.5d0*b2*temp1*temp4b
      tempb1 = 0.5d0*rho*un*temp4b
      b2b = temp1*tempb1
      temp1b = b2*tempb1
      utb = a1pos*temp1b
      temp1 = 6.0d0*pr_by_rho + u_sqr
      b1b = 0.5d0*temp1*temp3b + temp1b
      temp1 = 7.0d0*pr_by_rho + u_sqr
      a1posb = 0.5d0*ut*temp1*temp2b + ut*temp1b
      temp1b = 0.5d0*b1*temp3b
      pr_by_rhob = 6.0d0*temp1b
      u_sqrb = temp1b
      tempb2 = 0.5d0*a1pos*temp2b
      temp1b = ut*tempb2
      pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
      u_sqrb = u_sqrb + temp1b
      temp2 = un*a2neg - b2
      temp1b = temp2*rho*gb(3)
      utb = utb + a1pos*temp1b + temp1*tempb2
      temp1 = ut*a1pos + b1
      rhob = rhob + temp2*temp1*gb(3) + un*tempb0
      temp2b = rho*temp1*gb(3)
      unb = a2neg*temp2b + rho*tempb0
      gb(3) = 0.D0
      b2b = b2b - temp2b
      temp1 = pr_by_rho + ut*ut
      temp2 = temp1*a1pos + ut*b1
      a2negb = a2negb + temp2*rho*gb(2) + un*temp2b
      rhob = rhob + temp2*a2neg*gb(2)
      temp2b = rho*a2neg*gb(2)
      gb(2) = 0.D0
      tempb4 = (ut*a1pos+b1)*gb(1)
      tempb3 = rho*a2neg*gb(1)
      a1posb = a1posb + temp1*temp2b + ut*tempb3 + ut*temp1b
      b1b = b1b + ut*temp2b + tempb3 + temp1b
      temp1b = a1pos*temp2b
      pr_by_rhob = pr_by_rhob + temp1b
      a2negb = a2negb + rho*tempb4
      gb(1) = 0.D0
      result1b = -(0.5d0*a2negb)
      CALL ADSTACK_STARTREPEAT()
      CALL POPREAL8(s2)
      CALL ADSTACK_RESETREPEAT()
      CALL ADSTACK_ENDREPEAT()
      s2b = 0.D0
  
      ! CALL DERF_B(s2, s2b, result1b)
      s2b = s2b + (2.0d0/dsqrt(pi))*dexp(-s2**2)*result1b
  
      CALL POPREAL8(s2)
      result1b = 0.5d0*a1posb
      CALL ADSTACK_STARTREPEAT()
      CALL POPREAL8(s1)
      CALL ADSTACK_RESETREPEAT()
      CALL ADSTACK_ENDREPEAT()
      s1b = 0.D0
  
      ! CALL DERF_B(s1, s1b, result1b)
      s1b = s1b + (2.0d0/dsqrt(pi))*dexp(-s1**2)*result1b
  
      CALL POPREAL8(s1)
      temp6 = DSQRT(pi*beta)
      tempb6 = 0.5d0*b2b/temp6
      s2b = s2b - DEXP(-(s2**2))*2*s2*tempb6
      unb = unb + temp0*s2b + 2*un*u_sqrb
      IF (pi*beta .EQ. 0.0) THEN
        betab = 0.0
      ELSE
        betab = -(DEXP(-(s2**2))*pi*tempb6/(2.D0*DSQRT(pi*beta)*temp6))
      END IF
      temp5 = DSQRT(pi*beta)
      tempb7 = 0.5d0*b1b/temp5
      s1b = s1b - DEXP(-(s1**2))*2*s1*tempb7
      utb = utb + 2*ut*temp1b + 2*ut*u_sqrb + temp*s1b + a1pos*tempb3 + b1&
  &     *temp2b
      IF (.NOT.pi*beta .EQ. 0.0) betab = betab - DEXP(-(s1**2))*pi*tempb7/&
  &       (2.D0*DSQRT(pi*beta)*temp5)
      IF (.NOT.beta .EQ. 0.0) betab = betab + un*s2b/(2.D0*DSQRT(beta))
      IF (.NOT.beta .EQ. 0.0) betab = betab + ut*s1b/(2.D0*DSQRT(beta))
      tempb5 = 0.5d0*betab/pr
      rhob = rhob + tempb5 - pr*pr_by_rhob/rho**2 + a2neg*tempb4
      prb = pr_by_rhob/rho - rho*tempb5/pr
      u1b = tx*utb + nx*unb
      u2b = ty*utb + ny*unb
    END SUBROUTINE FLUX_QUAD_GXII_B
  
    SUBROUTINE FLUX_QUAD_GXII(g, nx, ny, u1, u2, rho, pr)
      IMPLICIT NONE
      DOUBLE PRECISION :: g(4), u1, u2, rho, pr
      DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
      DOUBLE PRECISION :: beta
      DOUBLE PRECISION :: s1, b1, s2, b2
      DOUBLE PRECISION :: a1pos, a2neg
      DOUBLE PRECISION :: temp1, temp2, temp3, temp4
      DOUBLE PRECISION :: pr_by_rho, u_sqr
      ! DOUBLE PRECISION :: DERF
      ! INTRINSIC DSQRT
      ! INTRINSIC DEXP
      ! EXTERNAL DERF
      DOUBLE PRECISION :: result1
      tx = ny
      ty = -nx
      ut = u1*tx + u2*ty
      un = u1*nx + u2*ny
      beta = 0.5d0*rho/pr
      s1 = ut*DSQRT(beta)
      s2 = un*DSQRT(beta)
      b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
      b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
      result1 = DERF(s1)
      a1pos = 0.5d0*(1.d0+result1)
      result1 = DERF(s2)
      a2neg = 0.5d0*(1.d0-result1)
      pr_by_rho = pr/rho
      u_sqr = ut*ut + un*un
  !	Expressions for the split fluxes ..
      g(1) = rho*a2neg*(ut*a1pos+b1)
      temp1 = pr_by_rho + ut*ut
      temp2 = temp1*a1pos + ut*b1
      g(2) = rho*a2neg*temp2
      temp1 = ut*a1pos + b1
      temp2 = un*a2neg - b2
      g(3) = rho*temp1*temp2
      temp1 = 7.0d0*pr_by_rho + u_sqr
      temp2 = 0.5d0*ut*temp1*a1pos
      temp1 = 6.0d0*pr_by_rho + u_sqr
      temp3 = 0.5d0*b1*temp1
      temp1 = ut*a1pos + b1
      temp4 = 0.5d0*rho*un*b2*temp1
      g(4) = rho*a2neg*(temp2+temp3) - temp4
    END SUBROUTINE FLUX_QUAD_GXII
  
  !  Differentiation of flux_quad_gxiii in reverse (adjoint) mode (with options fixinterface):
  !   gradient     of useful results: g
  !   with respect to varying inputs: g u1 u2 pr rho
    SUBROUTINE FLUX_QUAD_GXIII_B(g, gb, nx, ny, u1, u1b, u2, u2b, rho, &
  &   rhob, pr, prb)
      IMPLICIT NONE
      DOUBLE PRECISION :: g(4), u1, u2, rho, pr
      DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
      DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
      DOUBLE PRECISION :: utb, unb
      DOUBLE PRECISION :: beta
      DOUBLE PRECISION :: betab
      DOUBLE PRECISION :: s1, b1, s2, b2
      DOUBLE PRECISION :: s1b, b1b, s2b, b2b
      DOUBLE PRECISION :: a1pos, a2pos
      DOUBLE PRECISION :: a1posb, a2posb
      DOUBLE PRECISION :: temp1, temp2, temp3, temp4
      DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
      DOUBLE PRECISION :: pr_by_rho, u_sqr
      DOUBLE PRECISION :: pr_by_rhob, u_sqrb
      ! DOUBLE PRECISION :: DERF
      ! INTRINSIC DSQRT
      ! INTRINSIC DEXP
      ! EXTERNAL DERF
      ! EXTERNAL DERF_B
      DOUBLE PRECISION :: result1
      DOUBLE PRECISION :: result1b
      DOUBLE PRECISION :: temp
      DOUBLE PRECISION :: temp0
      DOUBLE PRECISION :: temp5
      DOUBLE PRECISION :: temp6
      DOUBLE PRECISION :: tempb
      DOUBLE PRECISION :: tempb0
      DOUBLE PRECISION :: tempb1
      DOUBLE PRECISION :: tempb2
      DOUBLE PRECISION :: tempb3
      DOUBLE PRECISION :: tempb4
      DOUBLE PRECISION :: tempb5
      DOUBLE PRECISION :: tempb6
      DOUBLE PRECISION :: tempb7
      tx = ny
      ty = -nx
      ut = u1*tx + u2*ty
      un = u1*nx + u2*ny
      beta = 0.5d0*rho/pr
      s1 = ut*DSQRT(beta)
      s2 = un*DSQRT(beta)
      b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
      b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
      CALL PUSHREAL8(s1)
      result1 = DERF(s1)
      a1pos = 0.5d0*(1.0d0+result1)
      CALL PUSHREAL8(s2)
      result1 = DERF(s2)
      a2pos = 0.5d0*(1.0d0+result1)
      pr_by_rho = pr/rho
      u_sqr = ut*ut + un*un
  !	Expressions for the split fluxes ..
      temp1 = 7.0d0*pr_by_rho + u_sqr
      temp2 = 0.5d0*ut*temp1*a1pos
      temp1 = 6.0d0*pr_by_rho + u_sqr
      temp3 = 0.5d0*b1*temp1
      temp1 = ut*a1pos + b1
      temp = DSQRT(beta)
      temp0 = DSQRT(beta)
      tempb = rho*a2pos*gb(4)
      rhob = (temp2+temp3)*a2pos*gb(4)
      a2posb = (temp2+temp3)*rho*gb(4)
      temp2b = tempb
      temp3b = tempb
      temp4b = gb(4)
      gb(4) = 0.D0
      tempb0 = 0.5d0*b2*temp1*temp4b
      tempb1 = 0.5d0*rho*un*temp4b
      b2b = temp1*tempb1
      temp1b = b2*tempb1
      utb = a1pos*temp1b
      temp1 = 6.0d0*pr_by_rho + u_sqr
      b1b = 0.5d0*temp1*temp3b + temp1b
      temp1 = 7.0d0*pr_by_rho + u_sqr
      a1posb = 0.5d0*ut*temp1*temp2b + ut*temp1b
      temp1b = 0.5d0*b1*temp3b
      pr_by_rhob = 6.0d0*temp1b
      u_sqrb = temp1b
      tempb2 = 0.5d0*a1pos*temp2b
      temp1b = ut*tempb2
      pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
      u_sqrb = u_sqrb + temp1b
      temp2 = un*a2pos + b2
      temp1b = temp2*rho*gb(3)
      utb = utb + a1pos*temp1b + temp1*tempb2
      temp1 = ut*a1pos + b1
      rhob = rhob + temp2*temp1*gb(3) + un*tempb0
      temp2b = rho*temp1*gb(3)
      unb = a2pos*temp2b + rho*tempb0
      gb(3) = 0.D0
      b2b = b2b + temp2b
      temp1 = pr_by_rho + ut*ut
      temp2 = temp1*a1pos + ut*b1
      a2posb = a2posb + temp2*rho*gb(2) + un*temp2b
      rhob = rhob + temp2*a2pos*gb(2)
      temp2b = rho*a2pos*gb(2)
      gb(2) = 0.D0
      tempb4 = (ut*a1pos+b1)*gb(1)
      tempb3 = rho*a2pos*gb(1)
      a1posb = a1posb + temp1*temp2b + ut*tempb3 + ut*temp1b
      b1b = b1b + ut*temp2b + tempb3 + temp1b
      temp1b = a1pos*temp2b
      pr_by_rhob = pr_by_rhob + temp1b
      a2posb = a2posb + rho*tempb4
      gb(1) = 0.D0
      result1b = 0.5d0*a2posb
      CALL ADSTACK_STARTREPEAT()
      CALL POPREAL8(s2)
      CALL ADSTACK_RESETREPEAT()
      CALL ADSTACK_ENDREPEAT()
      s2b = 0.D0
  
      ! CALL DERF_B(s2, s2b, result1b)
      s2b = s2b + (2.0d0/dsqrt(pi))*dexp(-s2**2)*result1b
  
      CALL POPREAL8(s2)
      result1b = 0.5d0*a1posb
      CALL ADSTACK_STARTREPEAT()
      CALL POPREAL8(s1)
      CALL ADSTACK_RESETREPEAT()
      CALL ADSTACK_ENDREPEAT()
      s1b = 0.D0
  
      ! CALL DERF_B(s1, s1b, result1b)
      s1b = s1b + (2.0d0/dsqrt(pi))*dexp(-s1**2)*result1b
  
      CALL POPREAL8(s1)
      temp6 = DSQRT(pi*beta)
      tempb6 = 0.5d0*b2b/temp6
      s2b = s2b - DEXP(-(s2**2))*2*s2*tempb6
      unb = unb + temp0*s2b + 2*un*u_sqrb
      IF (pi*beta .EQ. 0.0) THEN
        betab = 0.0
      ELSE
        betab = -(DEXP(-(s2**2))*pi*tempb6/(2.D0*DSQRT(pi*beta)*temp6))
      END IF
      temp5 = DSQRT(pi*beta)
      tempb7 = 0.5d0*b1b/temp5
      s1b = s1b - DEXP(-(s1**2))*2*s1*tempb7
      utb = utb + 2*ut*temp1b + 2*ut*u_sqrb + temp*s1b + a1pos*tempb3 + b1&
  &     *temp2b
      IF (.NOT.pi*beta .EQ. 0.0) betab = betab - DEXP(-(s1**2))*pi*tempb7/&
  &       (2.D0*DSQRT(pi*beta)*temp5)
      IF (.NOT.beta .EQ. 0.0) betab = betab + un*s2b/(2.D0*DSQRT(beta))
      IF (.NOT.beta .EQ. 0.0) betab = betab + ut*s1b/(2.D0*DSQRT(beta))
      tempb5 = 0.5d0*betab/pr
      rhob = rhob + tempb5 - pr*pr_by_rhob/rho**2 + a2pos*tempb4
      prb = pr_by_rhob/rho - rho*tempb5/pr
      u1b = tx*utb + nx*unb
      u2b = ty*utb + ny*unb
    END SUBROUTINE FLUX_QUAD_GXIII_B
  
    SUBROUTINE FLUX_QUAD_GXIII(g, nx, ny, u1, u2, rho, pr)
      IMPLICIT NONE
      DOUBLE PRECISION :: g(4), u1, u2, rho, pr
      DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
      DOUBLE PRECISION :: beta
      DOUBLE PRECISION :: s1, b1, s2, b2
      DOUBLE PRECISION :: a1pos, a2pos
      DOUBLE PRECISION :: temp1, temp2, temp3, temp4
      DOUBLE PRECISION :: pr_by_rho, u_sqr
      ! DOUBLE PRECISION :: DERF
      ! INTRINSIC DSQRT
      ! INTRINSIC DEXP
      ! EXTERNAL DERF
      DOUBLE PRECISION :: result1
      tx = ny
      ty = -nx
      ut = u1*tx + u2*ty
      un = u1*nx + u2*ny
      beta = 0.5d0*rho/pr
      s1 = ut*DSQRT(beta)
      s2 = un*DSQRT(beta)
      b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
      b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
      result1 = DERF(s1)
      a1pos = 0.5d0*(1.0d0+result1)
      result1 = DERF(s2)
      a2pos = 0.5d0*(1.0d0+result1)
      pr_by_rho = pr/rho
      u_sqr = ut*ut + un*un
  !	Expressions for the split fluxes ..
      g(1) = rho*a2pos*(ut*a1pos+b1)
      temp1 = pr_by_rho + ut*ut
      temp2 = temp1*a1pos + ut*b1
      g(2) = rho*a2pos*temp2
      temp1 = ut*a1pos + b1
      temp2 = un*a2pos + b2
      g(3) = rho*temp1*temp2
      temp1 = 7.0d0*pr_by_rho + u_sqr
      temp2 = 0.5d0*ut*temp1*a1pos
      temp1 = 6.0d0*pr_by_rho + u_sqr
      temp3 = 0.5d0*b1*temp1
      temp1 = ut*a1pos + b1
      temp4 = 0.5d0*rho*un*b2*temp1
      g(4) = rho*a2pos*(temp2+temp3) + temp4
    END SUBROUTINE FLUX_QUAD_GXIII
  
  !  Differentiation of flux_quad_gxiv in reverse (adjoint) mode (with options fixinterface):
  !   gradient     of useful results: g
  !   with respect to varying inputs: g u1 u2 pr rho
    SUBROUTINE FLUX_QUAD_GXIV_B(g, gb, nx, ny, u1, u1b, u2, u2b, rho, rhob&
  &   , pr, prb)
      IMPLICIT NONE
      DOUBLE PRECISION :: g(4), u1, u2, rho, pr
      DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
      DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
      DOUBLE PRECISION :: utb, unb
      DOUBLE PRECISION :: beta
      DOUBLE PRECISION :: betab
      DOUBLE PRECISION :: s1, b1, s2, b2
      DOUBLE PRECISION :: s1b, b1b, s2b, b2b
      DOUBLE PRECISION :: a1neg, a2pos
      DOUBLE PRECISION :: a1negb, a2posb
      DOUBLE PRECISION :: temp1, temp2, temp3, temp4
      DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
      DOUBLE PRECISION :: pr_by_rho, u_sqr
      DOUBLE PRECISION :: pr_by_rhob, u_sqrb
      ! DOUBLE PRECISION :: DERF
      ! INTRINSIC DSQRT
      ! INTRINSIC DEXP
      ! EXTERNAL DERF
      ! EXTERNAL DERF_B
      DOUBLE PRECISION :: result1
      DOUBLE PRECISION :: result1b
      DOUBLE PRECISION :: temp
      DOUBLE PRECISION :: temp0
      DOUBLE PRECISION :: temp5
      DOUBLE PRECISION :: temp6
      DOUBLE PRECISION :: tempb
      DOUBLE PRECISION :: tempb0
      DOUBLE PRECISION :: tempb1
      DOUBLE PRECISION :: tempb2
      DOUBLE PRECISION :: tempb3
      DOUBLE PRECISION :: tempb4
      DOUBLE PRECISION :: tempb5
      DOUBLE PRECISION :: tempb6
      DOUBLE PRECISION :: tempb7
      tx = ny
      ty = -nx
      ut = u1*tx + u2*ty
      un = u1*nx + u2*ny
      beta = 0.5d0*rho/pr
      s1 = ut*DSQRT(beta)
      s2 = un*DSQRT(beta)
      b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
      b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
      CALL PUSHREAL8(s1)
      result1 = DERF(s1)
      a1neg = 0.5d0*(1.0d0-result1)
      CALL PUSHREAL8(s2)
      result1 = DERF(s2)
      a2pos = 0.5d0*(1.0d0+result1)
      pr_by_rho = pr/rho
      u_sqr = ut*ut + un*un
  !	Expressions for the split fluxes ..
      temp1 = 7.0d0*pr_by_rho + u_sqr
      temp2 = 0.5d0*ut*temp1*a1neg
      temp1 = 6.0d0*pr_by_rho + u_sqr
      temp3 = 0.5d0*b1*temp1
      temp1 = ut*a1neg - b1
      temp = DSQRT(beta)
      temp0 = DSQRT(beta)
      tempb = rho*a2pos*gb(4)
      rhob = (temp2-temp3)*a2pos*gb(4)
      a2posb = (temp2-temp3)*rho*gb(4)
      temp2b = tempb
      temp3b = -tempb
      temp4b = gb(4)
      gb(4) = 0.D0
      tempb0 = 0.5d0*b2*temp1*temp4b
      tempb1 = 0.5d0*rho*un*temp4b
      b2b = temp1*tempb1
      temp1b = b2*tempb1
      utb = a1neg*temp1b
      temp1 = 6.0d0*pr_by_rho + u_sqr
      b1b = 0.5d0*temp1*temp3b - temp1b
      temp1 = 7.0d0*pr_by_rho + u_sqr
      a1negb = 0.5d0*ut*temp1*temp2b + ut*temp1b
      temp1b = 0.5d0*b1*temp3b
      pr_by_rhob = 6.0d0*temp1b
      u_sqrb = temp1b
      tempb2 = 0.5d0*a1neg*temp2b
      temp1b = ut*tempb2
      pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
      u_sqrb = u_sqrb + temp1b
      temp2 = un*a2pos + b2
      temp1b = temp2*rho*gb(3)
      utb = utb + a1neg*temp1b + temp1*tempb2
      temp1 = ut*a1neg - b1
      rhob = rhob + temp2*temp1*gb(3) + un*tempb0
      temp2b = rho*temp1*gb(3)
      unb = a2pos*temp2b + rho*tempb0
      gb(3) = 0.D0
      b2b = b2b + temp2b
      temp1 = pr_by_rho + ut*ut
      temp2 = temp1*a1neg - ut*b1
      a2posb = a2posb + temp2*rho*gb(2) + un*temp2b
      rhob = rhob + temp2*a2pos*gb(2)
      temp2b = rho*a2pos*gb(2)
      gb(2) = 0.D0
      tempb4 = (ut*a1neg-b1)*gb(1)
      tempb3 = rho*a2pos*gb(1)
      a1negb = a1negb + temp1*temp2b + ut*tempb3 + ut*temp1b
      b1b = b1b - ut*temp2b - tempb3 - temp1b
      temp1b = a1neg*temp2b
      pr_by_rhob = pr_by_rhob + temp1b
      a2posb = a2posb + rho*tempb4
      gb(1) = 0.D0
      result1b = 0.5d0*a2posb
      CALL ADSTACK_STARTREPEAT()
      CALL POPREAL8(s2)
      CALL ADSTACK_RESETREPEAT()
      CALL ADSTACK_ENDREPEAT()
      s2b = 0.D0
  
      ! CALL DERF_B(s2, s2b, result1b)
      s2b = s2b + (2.0d0/dsqrt(pi))*dexp(-s2**2)*result1b
  
      CALL POPREAL8(s2)
      result1b = -(0.5d0*a1negb)
      CALL ADSTACK_STARTREPEAT()
      CALL POPREAL8(s1)
      CALL ADSTACK_RESETREPEAT()
      CALL ADSTACK_ENDREPEAT()
      s1b = 0.D0
  
      ! CALL DERF_B(s1, s1b, result1b)
      s1b = s1b + (2.0d0/dsqrt(pi))*dexp(-s1**2)*result1b
  
      CALL POPREAL8(s1)
      temp6 = DSQRT(pi*beta)
      tempb6 = 0.5d0*b2b/temp6
      s2b = s2b - DEXP(-(s2**2))*2*s2*tempb6
      unb = unb + temp0*s2b + 2*un*u_sqrb
      IF (pi*beta .EQ. 0.0) THEN
        betab = 0.0
      ELSE
        betab = -(DEXP(-(s2**2))*pi*tempb6/(2.D0*DSQRT(pi*beta)*temp6))
      END IF
      temp5 = DSQRT(pi*beta)
      tempb7 = 0.5d0*b1b/temp5
      s1b = s1b - DEXP(-(s1**2))*2*s1*tempb7
      utb = utb + 2*ut*temp1b + 2*ut*u_sqrb + temp*s1b + a1neg*tempb3 - b1&
  &     *temp2b
      IF (.NOT.pi*beta .EQ. 0.0) betab = betab - DEXP(-(s1**2))*pi*tempb7/&
  &       (2.D0*DSQRT(pi*beta)*temp5)
      IF (.NOT.beta .EQ. 0.0) betab = betab + un*s2b/(2.D0*DSQRT(beta))
      IF (.NOT.beta .EQ. 0.0) betab = betab + ut*s1b/(2.D0*DSQRT(beta))
      tempb5 = 0.5d0*betab/pr
      rhob = rhob + tempb5 - pr*pr_by_rhob/rho**2 + a2pos*tempb4
      prb = pr_by_rhob/rho - rho*tempb5/pr
      u1b = tx*utb + nx*unb
      u2b = ty*utb + ny*unb
    END SUBROUTINE FLUX_QUAD_GXIV_B
  
    SUBROUTINE FLUX_QUAD_GXIV(g, nx, ny, u1, u2, rho, pr)
      IMPLICIT NONE
      DOUBLE PRECISION :: g(4), u1, u2, rho, pr
      DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
      DOUBLE PRECISION :: beta
      DOUBLE PRECISION :: s1, b1, s2, b2
      DOUBLE PRECISION :: a1neg, a2pos
      DOUBLE PRECISION :: temp1, temp2, temp3, temp4
      DOUBLE PRECISION :: pr_by_rho, u_sqr
      ! DOUBLE PRECISION :: DERF
      ! INTRINSIC DSQRT
      ! INTRINSIC DEXP
      ! EXTERNAL DERF
      DOUBLE PRECISION :: result1
      tx = ny
      ty = -nx
      ut = u1*tx + u2*ty
      un = u1*nx + u2*ny
      beta = 0.5d0*rho/pr
      s1 = ut*DSQRT(beta)
      s2 = un*DSQRT(beta)
      b1 = 0.5d0*DEXP(-(s1*s1))/DSQRT(pi*beta)
      b2 = 0.5d0*DEXP(-(s2*s2))/DSQRT(pi*beta)
      result1 = DERF(s1)
      a1neg = 0.5d0*(1.0d0-result1)
      result1 = DERF(s2)
      a2pos = 0.5d0*(1.0d0+result1)
      pr_by_rho = pr/rho
      u_sqr = ut*ut + un*un
  !	Expressions for the split fluxes ..
      g(1) = rho*a2pos*(ut*a1neg-b1)
      temp1 = pr_by_rho + ut*ut
      temp2 = temp1*a1neg - ut*b1
      g(2) = rho*a2pos*temp2
      temp1 = ut*a1neg - b1
      temp2 = un*a2pos + b2
      g(3) = rho*temp1*temp2
      temp1 = 7.0d0*pr_by_rho + u_sqr
      temp2 = 0.5d0*ut*temp1*a1neg
      temp1 = 6.0d0*pr_by_rho + u_sqr
      temp3 = 0.5d0*b1*temp1
      temp1 = ut*a1neg - b1
      temp4 = 0.5d0*rho*un*b2*temp1
      g(4) = rho*a2pos*(temp2-temp3) + temp4
    END SUBROUTINE FLUX_QUAD_GXIV
  
  END MODULE QUADRANT_FLUXES_MOD_DIFF
