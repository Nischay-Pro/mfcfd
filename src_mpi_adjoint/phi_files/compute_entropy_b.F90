!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE COMPUTE_ENTROPY_MOD_DIFF
#include <petsc/finclude/petscsys.h>
    USE DATA_STRUCTURE_MOD_DIFF
    USE PETSC_DATA_STRUCTURE_MOD
    IMPLICIT NONE
    
    CONTAINS
    SUBROUTINE COMPUTE_ENTROPY()
        IMPLICIT NONE
        INTEGER :: k
        REAL*8 :: temp1, temp2
        REAL*8 :: gtotal_entropy
        INTRINSIC DLOG
        PetscErrorCode :: ierr
        total_entropy = 0.d0
        temp2 = DLOG(pr_inf)
        DO k=1,local_points
            temp1 = point%prim(1, k)**gamma
            temp1 = point%prim(4, k)/temp1
            temp1 = DLOG(temp1)
            point%entropy(k) = (temp1-temp2)**2
            total_entropy = total_entropy + (temp1-temp2)**2
        END DO
        CALL MPI_REDUCE(total_entropy, gtotal_entropy, 1, mpi_double, &
        &             mpi_sum, 0, petsc_comm_world, ierr)
        IF (rank .EQ. 0) WRITE(*, *) 'total entropy :', gtotal_entropy
    END SUBROUTINE COMPUTE_ENTROPY
    
SUBROUTINE COMPUTE_ENSTROPHY()
    IMPLICIT NONE
    INTEGER :: i, k, r, nbh
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: delx, dely, dist, weights
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delu1, sum_delx_delu2, sum_dely_delu1, &
&   sum_dely_delu2
    REAL*8 :: det
    REAL*8 :: one_by_det
    REAL*8 :: du1_dy, du2_dx, temp
    REAL*8 :: gtotal_enstrophy
    INTRINSIC DSQRT
    INTEGER :: petsc_comm_world
    INTEGER :: ierr
    INTEGER :: mpi_sum
    INTEGER :: mpi_double
! PetscErrorCode :: ierr
    total_enstrophy = 0.d0
    DO i=1,local_points
      x_i = point%x(i)
      y_i = point%y(i)
      sum_delx_sqr = 0.d0
      sum_dely_sqr = 0.d0
      sum_delx_dely = 0.d0
      sum_delx_delu1 = 0.d0
      sum_dely_delu1 = 0.d0
      sum_delx_delu2 = 0.d0
      sum_dely_delu2 = 0.d0
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        x_k = point%x(nbh)
        y_k = point%y(nbh)
        delx = x_k - x_i
        dely = y_k - y_i
        dist = DSQRT(delx*delx + dely*dely)
        weights = dist**power
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        sum_delx_delu1 = sum_delx_delu1 + weights*delx*(point%prim(2, &
&         nbh)-point%prim(2, i))
        sum_delx_delu2 = sum_delx_delu2 + weights*delx*(point%prim(3, &
&         nbh)-point%prim(3, i))
        sum_dely_delu1 = sum_dely_delu1 + weights*dely*(point%prim(2, &
&         nbh)-point%prim(2, i))
        sum_dely_delu2 = sum_dely_delu2 + weights*dely*(point%prim(3, &
&         nbh)-point%prim(3, i))
      END DO
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      one_by_det = 1.0d0/det
      du2_dx = (sum_delx_delu2*sum_dely_sqr-sum_dely_delu2*sum_delx_dely&
&       )*one_by_det
      du1_dy = (sum_dely_delu1*sum_delx_sqr-sum_delx_delu1*sum_delx_dely&
&       )*one_by_det
      temp = du2_dx - du1_dy
      point%vorticity(i) = temp
      point%vorticity_sqr(i) = temp*temp
      total_enstrophy = total_enstrophy + point%vorticity_sqr(i)*point%&
&       vor_area(i)
    END DO
    CALL MPI_REDUCE(total_enstrophy, gtotal_enstrophy, 1, mpi_double, &
&             mpi_sum, 0, petsc_comm_world, ierr)
    IF (rank .EQ. 0) WRITE(*, *) 'total enstrophy :', gtotal_enstrophy
  END SUBROUTINE COMPUTE_ENSTROPHY

!  Differentiation of compute_sum_div_enstrophy in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: total_sum_div_enstrophy *(point.prim)
!                *(point.vorticity_sqr) *(point.divergence_sqr)
!                *(point.du1_dx) *(point.du2_dy)
!   with respect to varying inputs: *(point.prim) *(point.vorticity_sqr)
!                *(point.divergence_sqr) *(point.du1_dx) *(point.du2_dy)
!   Plus diff mem management of: point.prim:in point.vorticity_sqr:in
!                point.divergence_sqr:in point.du1_dx:in point.du2_dy:in
  SUBROUTINE COMPUTE_SUM_DIV_ENSTROPHY_B()
    IMPLICIT NONE
    INTEGER :: i, k, r, nbh
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: delx, dely, dist, weights
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delu1, sum_delx_delu2, sum_dely_delu1, &
&   sum_dely_delu2
    REAL*8 :: sum_delx_delu1b, sum_delx_delu2b, sum_dely_delu1b, &
&   sum_dely_delu2b
    REAL*8 :: sum_delx_sqr_delu1_sqr, sum_delx_sqr_delu2_sqr, &
&   sum_dely_sqr_delu1_sqr, sum_dely_sqr_delu2_sqr
    REAL*8 :: sum_delx_sqr_delu1_sqrb, sum_delx_sqr_delu2_sqrb, &
&   sum_dely_sqr_delu1_sqrb, sum_dely_sqr_delu2_sqrb
    REAL*8 :: det
    REAL*8 :: one_by_det
    REAL*8 :: du1_dy, du2_dx, temp, du1_sqr_dx_sqr, du2_sqr_dy_sqr
    REAL*8 :: du1_dyb, du2_dxb, tempb, du1_sqr_dx_sqrb, du2_sqr_dy_sqrb
! real*8, dimension(local_points) :: du1_dx, du2_dy
! real*8 :: total_sum_div_enstrophy
    REAL*8 :: gtotal_sum_div_enstrophy
    INTRINSIC DSQRT
    REAL*8 :: tempb0
    REAL*8 :: tempb1
    REAL*8 :: tempb2
    REAL*8 :: tempb3
    REAL*8 :: tempb4
    REAL*8 :: tempb5
    REAL*8 :: tempb6
    REAL*8 :: tempb7
    REAL*8 :: tempb8
    INTEGER :: ad_to
    INTEGER :: ad_to0
    PetscErrorCode :: ierr
    total_sum_div_enstrophy = 0.d0
    DO i=1,local_points
      x_i = point%x(i)
      y_i = point%y(i)
      CALL PUSHREAL8(sum_delx_sqr)
      sum_delx_sqr = 0.d0
      CALL PUSHREAL8(sum_dely_sqr)
      sum_dely_sqr = 0.d0
      CALL PUSHREAL8(sum_delx_dely)
      sum_delx_dely = 0.d0
      sum_delx_delu1 = 0.d0
      sum_dely_delu1 = 0.d0
      sum_delx_delu2 = 0.d0
      sum_dely_delu2 = 0.d0
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        x_k = point%x(nbh)
        y_k = point%y(nbh)
        delx = x_k - x_i
        dely = y_k - y_i
        dist = DSQRT(delx*delx + dely*dely)
        CALL PUSHREAL8(weights)
        weights = dist**power
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        sum_delx_delu1 = sum_delx_delu1 + weights*delx*(point%prim(2, &
&         nbh)-point%prim(2, i))
        sum_delx_delu2 = sum_delx_delu2 + weights*delx*(point%prim(3, &
&         nbh)-point%prim(3, i))
        sum_dely_delu1 = sum_dely_delu1 + weights*dely*(point%prim(2, &
&         nbh)-point%prim(2, i))
        sum_dely_delu2 = sum_dely_delu2 + weights*dely*(point%prim(3, &
&         nbh)-point%prim(3, i))
      END DO
      CALL PUSHINTEGER4(k - 1)
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      CALL PUSHREAL8(one_by_det)
      one_by_det = 1.0d0/det
      du2_dx = (sum_delx_delu2*sum_dely_sqr-sum_dely_delu2*sum_delx_dely&
&       )*one_by_det
      du1_dy = (sum_dely_delu1*sum_delx_sqr-sum_delx_delu1*sum_delx_dely&
&       )*one_by_det
      CALL PUSHREAL8(temp)
      temp = du2_dx - du1_dy
      point%vorticity_sqr(i) = temp*temp
      point%du2_dy(i) = (sum_dely_delu2*sum_delx_sqr-sum_delx_delu2*&
&       sum_delx_dely)*one_by_det
      point%du1_dx(i) = (sum_delx_delu1*sum_dely_sqr-sum_dely_delu1*&
&       sum_delx_dely)*one_by_det
    END DO
    call update_begin_du1_dx_ghost()
    call update_end_du1_dx_ghost()
    call update_begin_du2_dy_ghost()
    call update_end_du2_dy_ghost()
    DO i=1,local_points
      x_i = point%x(i)
      y_i = point%y(i)
      CALL PUSHREAL8(sum_delx_sqr)
      sum_delx_sqr = 0.d0
      CALL PUSHREAL8(sum_dely_sqr)
      sum_dely_sqr = 0.d0
      CALL PUSHREAL8(sum_delx_dely)
      sum_delx_dely = 0.d0
      sum_delx_sqr_delu1_sqr = 0.d0
      sum_dely_sqr_delu1_sqr = 0.d0
      sum_delx_sqr_delu2_sqr = 0.d0
      sum_dely_sqr_delu2_sqr = 0.d0
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        x_k = point%x(nbh)
        y_k = point%y(nbh)
        delx = x_k - x_i
        dely = y_k - y_i
        dist = DSQRT(delx*delx + dely*dely)
        CALL PUSHREAL8(weights)
        weights = dist**power
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        sum_delx_sqr_delu1_sqr = sum_delx_sqr_delu1_sqr + weights*delx*(&
&         point%du1_dx(nbh)-point%du1_dx(i))
        sum_delx_sqr_delu2_sqr = sum_delx_sqr_delu2_sqr + weights*delx*(&
&         point%du2_dy(nbh)-point%du2_dy(i))
        sum_dely_sqr_delu1_sqr = sum_dely_sqr_delu1_sqr + weights*dely*(&
&         point%du1_dx(nbh)-point%du1_dx(i))
        sum_dely_sqr_delu2_sqr = sum_dely_sqr_delu2_sqr + weights*dely*(&
&         point%du2_dy(nbh)-point%du2_dy(i))
      END DO
      CALL PUSHINTEGER4(k - 1)
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      CALL PUSHREAL8(one_by_det)
      one_by_det = 1.0d0/det
      du2_sqr_dy_sqr = (sum_dely_sqr_delu2_sqr*sum_delx_sqr-&
&       sum_delx_sqr_delu2_sqr*sum_delx_dely)*one_by_det
      du1_sqr_dx_sqr = (sum_delx_sqr_delu1_sqr*sum_dely_sqr-&
&       sum_dely_sqr_delu1_sqr*sum_delx_dely)*one_by_det
      CALL PUSHREAL8(temp)
      temp = du2_sqr_dy_sqr + du1_sqr_dx_sqr
      point%divergence_sqr(i) = temp*temp
    END DO
!
!
    DO i=1,local_points
      total_sum_div_enstrophy = total_sum_div_enstrophy + (point%&
&       vorticity_sqr(i)+point%divergence_sqr(i))*point%vor_area(i)
    END DO
!                        
    CALL MPI_REDUCE(total_sum_div_enstrophy, gtotal_sum_div_enstrophy, 1&
&             , mpi_double, mpi_sum, 0, petsc_comm_world, ierr)
!               
    DO i=local_points,1,-1
      tempb8 = point%vor_area(i)*total_sum_div_enstrophyb
      pointb%vorticity_sqr(i) = pointb%vorticity_sqr(i) + tempb8
      pointb%divergence_sqr(i) = pointb%divergence_sqr(i) + tempb8
    END DO
    DO i=local_points,1,-1
      tempb = 2*temp*pointb%divergence_sqr(i)
      pointb%divergence_sqr(i) = 0.0_8
      CALL POPREAL8(temp)
      du2_sqr_dy_sqrb = tempb
      du1_sqr_dx_sqrb = tempb
      sum_delx_sqr_delu1_sqrb = one_by_det*sum_dely_sqr*du1_sqr_dx_sqrb
      sum_dely_sqr_delu1_sqrb = -(one_by_det*sum_delx_dely*&
&       du1_sqr_dx_sqrb)
      sum_dely_sqr_delu2_sqrb = one_by_det*sum_delx_sqr*du2_sqr_dy_sqrb
      sum_delx_sqr_delu2_sqrb = -(one_by_det*sum_delx_dely*&
&       du2_sqr_dy_sqrb)
      CALL POPREAL8(one_by_det)
      y_i = point%y(i)
      x_i = point%x(i)
      CALL POPINTEGER4(ad_to0)
      DO k=ad_to0,1,-1
        nbh = point%conn(i, k)
        y_k = point%y(nbh)
        dely = y_k - y_i
        tempb4 = weights*dely*sum_dely_sqr_delu2_sqrb
        pointb%du2_dy(nbh) = pointb%du2_dy(nbh) + tempb4
        pointb%du2_dy(i) = pointb%du2_dy(i) - tempb4
        tempb5 = weights*dely*sum_dely_sqr_delu1_sqrb
        pointb%du1_dx(nbh) = pointb%du1_dx(nbh) + tempb5
        pointb%du1_dx(i) = pointb%du1_dx(i) - tempb5
        x_k = point%x(nbh)
        delx = x_k - x_i
        tempb6 = weights*delx*sum_delx_sqr_delu2_sqrb
        pointb%du2_dy(nbh) = pointb%du2_dy(nbh) + tempb6
        pointb%du2_dy(i) = pointb%du2_dy(i) - tempb6
        tempb7 = weights*delx*sum_delx_sqr_delu1_sqrb
        pointb%du1_dx(nbh) = pointb%du1_dx(nbh) + tempb7
        pointb%du1_dx(i) = pointb%du1_dx(i) - tempb7
        CALL POPREAL8(weights)
      END DO
      CALL POPREAL8(sum_delx_dely)
      CALL POPREAL8(sum_dely_sqr)
      CALL POPREAL8(sum_delx_sqr)
    END DO

    call update_begin_du1_dxb_ghost()
    call update_end_du1_dxb_ghost()

    call update_begin_du2_dyb_ghost()
    call update_end_du2_dyb_ghost()

    do i = local_points+1, max_points
        pointb%du1_dx(i) = 0.0d0 
        pointb%du2_dy(i) = 0.0d0 
    end do

    DO i=local_points,1,-1
      tempb = 2*temp*pointb%vorticity_sqr(i)
      du2_dxb = tempb
      du1_dyb = -tempb
      sum_delx_delu1b = one_by_det*sum_dely_sqr*pointb%du1_dx(i) - &
&       one_by_det*sum_delx_dely*du1_dyb
      sum_dely_delu1b = one_by_det*sum_delx_sqr*du1_dyb - one_by_det*&
&       sum_delx_dely*pointb%du1_dx(i)
      pointb%du1_dx(i) = 0.0_8
      sum_dely_delu2b = one_by_det*sum_delx_sqr*pointb%du2_dy(i) - &
&       one_by_det*sum_delx_dely*du2_dxb
      sum_delx_delu2b = one_by_det*sum_dely_sqr*du2_dxb - one_by_det*&
&       sum_delx_dely*pointb%du2_dy(i)
      pointb%du2_dy(i) = 0.0_8
      pointb%vorticity_sqr(i) = 0.0_8
      CALL POPREAL8(temp)
      CALL POPREAL8(one_by_det)
      y_i = point%y(i)
      x_i = point%x(i)
      CALL POPINTEGER4(ad_to)
      DO k=ad_to,1,-1
        nbh = point%conn(i, k)
        y_k = point%y(nbh)
        dely = y_k - y_i
        tempb0 = weights*dely*sum_dely_delu2b
        pointb%prim(3, nbh) = pointb%prim(3, nbh) + tempb0
        pointb%prim(3, i) = pointb%prim(3, i) - tempb0
        tempb1 = weights*dely*sum_dely_delu1b
        pointb%prim(2, nbh) = pointb%prim(2, nbh) + tempb1
        pointb%prim(2, i) = pointb%prim(2, i) - tempb1
        x_k = point%x(nbh)
        delx = x_k - x_i
        tempb2 = weights*delx*sum_delx_delu2b
        pointb%prim(3, nbh) = pointb%prim(3, nbh) + tempb2
        pointb%prim(3, i) = pointb%prim(3, i) - tempb2
        tempb3 = weights*delx*sum_delx_delu1b
        pointb%prim(2, nbh) = pointb%prim(2, nbh) + tempb3
        pointb%prim(2, i) = pointb%prim(2, i) - tempb3
        CALL POPREAL8(weights)
      END DO
      CALL POPREAL8(sum_delx_dely)
      CALL POPREAL8(sum_dely_sqr)
      CALL POPREAL8(sum_delx_sqr)
    END DO

    call update_begin_du1_dxb_ghost()
    call update_end_du1_dxb_ghost()

    call update_begin_du2_dyb_ghost()
    call update_end_du2_dyb_ghost()

    do i = local_points+1, max_points
        pointb%du1_dx(i) = 0.0d0 
        pointb%du2_dy(i) = 0.0d0 
    end do

  END SUBROUTINE COMPUTE_SUM_DIV_ENSTROPHY_B

  SUBROUTINE COMPUTE_SUM_DIV_ENSTROPHY()
    IMPLICIT NONE
    INTEGER :: i, k, r, nbh
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: delx, dely, dist, weights
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delu1, sum_delx_delu2, sum_dely_delu1, &
&   sum_dely_delu2
    REAL*8 :: sum_delx_sqr_delu1_sqr, sum_delx_sqr_delu2_sqr, &
&   sum_dely_sqr_delu1_sqr, sum_dely_sqr_delu2_sqr
    REAL*8 :: det
    REAL*8 :: one_by_det
    REAL*8 :: du1_dy, du2_dx, temp, du1_sqr_dx_sqr, du2_sqr_dy_sqr
    REAL*8 :: gtotal_sum_div_enstrophy
    INTRINSIC DSQRT
    PetscErrorCode :: ierr
    total_sum_div_enstrophy = 0.d0
    DO i=1,local_points
      x_i = point%x(i)
      y_i = point%y(i)
      sum_delx_sqr = 0.d0
      sum_dely_sqr = 0.d0
      sum_delx_dely = 0.d0
      sum_delx_delu1 = 0.d0
      sum_dely_delu1 = 0.d0
      sum_delx_delu2 = 0.d0
      sum_dely_delu2 = 0.d0
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        x_k = point%x(nbh)
        y_k = point%y(nbh)
        delx = x_k - x_i
        dely = y_k - y_i
        dist = DSQRT(delx*delx + dely*dely)
        weights = dist**power
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        sum_delx_delu1 = sum_delx_delu1 + weights*delx*(point%prim(2, &
&         nbh)-point%prim(2, i))
        sum_delx_delu2 = sum_delx_delu2 + weights*delx*(point%prim(3, &
&         nbh)-point%prim(3, i))
        sum_dely_delu1 = sum_dely_delu1 + weights*dely*(point%prim(2, &
&         nbh)-point%prim(2, i))
        sum_dely_delu2 = sum_dely_delu2 + weights*dely*(point%prim(3, &
&         nbh)-point%prim(3, i))
      END DO
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      one_by_det = 1.0d0/det
      du2_dx = (sum_delx_delu2*sum_dely_sqr-sum_dely_delu2*sum_delx_dely&
&       )*one_by_det
      du1_dy = (sum_dely_delu1*sum_delx_sqr-sum_delx_delu1*sum_delx_dely&
&       )*one_by_det
      temp = du2_dx - du1_dy
      point%vorticity(i) = temp
      point%vorticity_sqr(i) = temp*temp
      point%du2_dy(i) = (sum_dely_delu2*sum_delx_sqr-sum_delx_delu2*&
&       sum_delx_dely)*one_by_det
      point%du1_dx(i) = (sum_delx_delu1*sum_dely_sqr-sum_dely_delu1*&
&       sum_delx_dely)*one_by_det
    END DO
    call update_begin_du1_dx_ghost()
    call update_end_du1_dx_ghost()
    call update_begin_du2_dy_ghost()
    call update_end_du2_dy_ghost()
    DO i=1,local_points
      x_i = point%x(i)
      y_i = point%y(i)
      sum_delx_sqr = 0.d0
      sum_dely_sqr = 0.d0
      sum_delx_dely = 0.d0
      sum_delx_sqr_delu1_sqr = 0.d0
      sum_dely_sqr_delu1_sqr = 0.d0
      sum_delx_sqr_delu2_sqr = 0.d0
      sum_dely_sqr_delu2_sqr = 0.d0
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        x_k = point%x(nbh)
        y_k = point%y(nbh)
        delx = x_k - x_i
        dely = y_k - y_i
        dist = DSQRT(delx*delx + dely*dely)
        weights = dist**power
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        sum_delx_sqr_delu1_sqr = sum_delx_sqr_delu1_sqr + weights*delx*(&
&         point%du1_dx(nbh)-point%du1_dx(i))
        sum_delx_sqr_delu2_sqr = sum_delx_sqr_delu2_sqr + weights*delx*(&
&         point%du2_dy(nbh)-point%du2_dy(i))
        sum_dely_sqr_delu1_sqr = sum_dely_sqr_delu1_sqr + weights*dely*(&
&         point%du1_dx(nbh)-point%du1_dx(i))
        sum_dely_sqr_delu2_sqr = sum_dely_sqr_delu2_sqr + weights*dely*(&
&         point%du2_dy(nbh)-point%du2_dy(i))
      END DO
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      one_by_det = 1.0d0/det
      du2_sqr_dy_sqr = (sum_dely_sqr_delu2_sqr*sum_delx_sqr-&
&       sum_delx_sqr_delu2_sqr*sum_delx_dely)*one_by_det
      du1_sqr_dx_sqr = (sum_delx_sqr_delu1_sqr*sum_dely_sqr-&
&       sum_dely_sqr_delu1_sqr*sum_delx_dely)*one_by_det
      temp = du2_sqr_dy_sqr + du1_sqr_dx_sqr
      point%divergence_sqr(i) = temp*temp
    END DO
!
!
    DO i=1,local_points
      total_sum_div_enstrophy = total_sum_div_enstrophy + (point%&
&       vorticity_sqr(i)+point%divergence_sqr(i))*point%vor_area(i)
    END DO
!                        
    CALL MPI_REDUCE(total_sum_div_enstrophy, gtotal_sum_div_enstrophy, 1&
&             , mpi_double, mpi_sum, 0, petsc_comm_world, ierr)
!               
    IF (rank .EQ. 0) WRITE(*, *) 'Objective Function (J)', &
&                    gtotal_sum_div_enstrophy
  END SUBROUTINE COMPUTE_SUM_DIV_ENSTROPHY

END MODULE COMPUTE_ENTROPY_MOD_DIFF
