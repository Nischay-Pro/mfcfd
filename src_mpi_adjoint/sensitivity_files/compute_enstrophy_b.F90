!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE COMPUTE_ENSTROPHY_MOD_DIFF
#include <petsc/finclude/petscsys.h>
  USE DATA_STRUCTURE_MOD_DIFF
  USE PETSC_DATA_STRUCTURE_MOD
  IMPLICIT NONE

CONTAINS
!  Differentiation of compute_enstrophy in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: total_enstrophy power *(point.x)
!                *(point.y) *(point.prim) *(point.vorticity_sqr)
!   with respect to varying inputs: power *(point.x) *(point.y)
!                *(point.prim) *(point.vorticity_sqr)
!   Plus diff mem management of: point.x:in point.y:in point.prim:in
!                point.vorticity_sqr:in
  SUBROUTINE COMPUTE_ENSTROPHY_B()
    IMPLICIT NONE
! call MPI_Allreduce(total_enstrophy, gtotal_enstrophy , 1, &
! & MPI_DOUBLE, MPI_SUM, PETSC_COMM_WORLD, ierr)
! if(rank == 0) then
!write(*,*)"total enstrophy :", gtotal_enstrophy
! end if
    INTEGER :: i, k, r, nbh
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: delx, dely, dist, weights
    REAL*8 :: delxb, delyb, distb, weightsb
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delu1, sum_delx_delu2, sum_dely_delu1, &
&   sum_dely_delu2
    REAL*8 :: sum_delx_delu1b, sum_delx_delu2b, sum_dely_delu1b, &
&   sum_dely_delu2b
    REAL*8 :: det
    REAL*8 :: detb
    REAL*8 :: one_by_det
    REAL*8 :: one_by_detb
    REAL*8 :: du1_dy, du2_dx, temp
    REAL*8 :: du1_dyb, du2_dxb, tempb
    REAL*8 :: gtotal_enstrophy
    INTRINSIC DSQRT
    PetscErrorCode :: ierr
    REAL*8 :: tempb0
    REAL*8 :: tempb1
    REAL*8 :: tempb2
    REAL*8 :: tempb3
    REAL*8 :: tempb4
    REAL*8 :: tempb5
    REAL*8 :: tempb6
    REAL*8 :: tempb7
    REAL*8 :: tempb8
    REAL*8 :: tempb9
    REAL*8 :: tempb10
    INTEGER :: ad_to
    DO i=1,local_points
      x_i = point%x(i)
      y_i = point%y(i)
      CALL PUSHREAL8(sum_delx_sqr)
      sum_delx_sqr = 0.d0
      CALL PUSHREAL8(sum_dely_sqr)
      sum_dely_sqr = 0.d0
      CALL PUSHREAL8(sum_delx_dely)
      sum_delx_dely = 0.d0
      CALL PUSHREAL8(sum_delx_delu1)
      sum_delx_delu1 = 0.d0
      CALL PUSHREAL8(sum_dely_delu1)
      sum_dely_delu1 = 0.d0
      CALL PUSHREAL8(sum_delx_delu2)
      sum_delx_delu2 = 0.d0
      CALL PUSHREAL8(sum_dely_delu2)
      sum_dely_delu2 = 0.d0
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        x_k = point%x(nbh)
        y_k = point%y(nbh)
        delx = x_k - x_i
        dely = y_k - y_i
        CALL PUSHREAL8(dist)
        dist = DSQRT(delx*delx + dely*dely)
        weights = dist**power
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        sum_delx_delu1 = sum_delx_delu1 + weights*delx*(point%prim(2, &
&         nbh)-point%prim(2, i))
        sum_delx_delu2 = sum_delx_delu2 + weights*delx*(point%prim(3, &
&         nbh)-point%prim(3, i))
        sum_dely_delu1 = sum_dely_delu1 + weights*dely*(point%prim(2, &
&         nbh)-point%prim(2, i))
        sum_dely_delu2 = sum_dely_delu2 + weights*dely*(point%prim(3, &
&         nbh)-point%prim(3, i))
      END DO
      CALL PUSHINTEGER4(k - 1)
    END DO
    DO i=local_points,1,-1
      pointb%vorticity_sqr(i) = pointb%vorticity_sqr(i) + &
&       total_enstrophyb
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      one_by_det = 1.0d0/det
      du2_dx = (sum_delx_delu2*sum_dely_sqr-sum_dely_delu2*sum_delx_dely&
&       )*one_by_det
      du1_dy = (sum_dely_delu1*sum_delx_sqr-sum_delx_delu1*sum_delx_dely&
&       )*one_by_det
      temp = du2_dx - du1_dy
      tempb = 2*temp*pointb%vorticity_sqr(i)
      pointb%vorticity_sqr(i) = 0.0_8
      du2_dxb = tempb
      du1_dyb = -tempb
      tempb9 = one_by_det*du1_dyb
      sum_dely_delu1b = sum_delx_sqr*tempb9
      sum_delx_delu1b = -(sum_delx_dely*tempb9)
      one_by_detb = (sum_delx_delu2*sum_dely_sqr-sum_dely_delu2*&
&       sum_delx_dely)*du2_dxb + (sum_dely_delu1*sum_delx_sqr-&
&       sum_delx_delu1*sum_delx_dely)*du1_dyb
      tempb10 = one_by_det*du2_dxb
      sum_delx_delu2b = sum_dely_sqr*tempb10
      sum_dely_delu2b = -(sum_delx_dely*tempb10)
      detb = -(one_by_detb/det**2)
      sum_delx_sqrb = sum_dely_sqr*detb + sum_dely_delu1*tempb9
      sum_delx_delyb = -(sum_dely_delu2*tempb10) - 2*sum_delx_dely*detb &
&       - sum_delx_delu1*tempb9
      sum_dely_sqrb = sum_delx_sqr*detb + sum_delx_delu2*tempb10
      y_i = point%y(i)
      x_i = point%x(i)
      y_ib = 0.0_8
      x_ib = 0.0_8
      CALL POPINTEGER4(ad_to)
      DO k=ad_to,1,-1
        weights = dist**power
        nbh = point%conn(i, k)
        y_k = point%y(nbh)
        dely = y_k - y_i
        tempb0 = (point%prim(3, nbh)-point%prim(3, i))*sum_dely_delu2b
        tempb1 = weights*dely*sum_dely_delu2b
        pointb%prim(3, nbh) = pointb%prim(3, nbh) + tempb1
        pointb%prim(3, i) = pointb%prim(3, i) - tempb1
        tempb2 = (point%prim(2, nbh)-point%prim(2, i))*sum_dely_delu1b
        tempb6 = weights*dely*sum_dely_delu1b
        pointb%prim(2, nbh) = pointb%prim(2, nbh) + tempb6
        pointb%prim(2, i) = pointb%prim(2, i) - tempb6
        x_k = point%x(nbh)
        delx = x_k - x_i
        tempb4 = (point%prim(3, nbh)-point%prim(3, i))*sum_delx_delu2b
        tempb7 = weights*delx*sum_delx_delu2b
        pointb%prim(3, nbh) = pointb%prim(3, nbh) + tempb7
        pointb%prim(3, i) = pointb%prim(3, i) - tempb7
        tempb3 = (point%prim(2, nbh)-point%prim(2, i))*sum_delx_delu1b
        weightsb = dely*tempb2 + delx*tempb3 + dely**2*sum_dely_sqrb + &
&         delx**2*sum_delx_sqrb + delx*dely*sum_delx_delyb + delx*tempb4&
&         + dely*tempb0
        tempb8 = weights*delx*sum_delx_delu1b
        pointb%prim(2, nbh) = pointb%prim(2, nbh) + tempb8
        pointb%prim(2, i) = pointb%prim(2, i) - tempb8
        IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(&
&           power))) THEN
          distb = 0.0
        ELSE
          distb = power*dist**(power-1)*weightsb
        END IF
        IF (.NOT.dist .LE. 0.0) powerb = powerb + dist**power*LOG(dist)*&
&           weightsb
        CALL POPREAL8(dist)
        IF (delx**2 + dely**2 .EQ. 0.0) THEN
          tempb5 = 0.0
        ELSE
          tempb5 = distb/(2.D0*DSQRT(delx**2+dely**2))
        END IF
        delyb = weights*tempb2 + weights*2*dely*sum_dely_sqrb + 2*dely*&
&         tempb5 + weights*delx*sum_delx_delyb + weights*tempb0
        delxb = weights*tempb3 + weights*2*delx*sum_delx_sqrb + 2*delx*&
&         tempb5 + weights*dely*sum_delx_delyb + weights*tempb4
        y_kb = delyb
        y_ib = y_ib - delyb
        x_kb = delxb
        x_ib = x_ib - delxb
        pointb%y(nbh) = pointb%y(nbh) + y_kb
        pointb%x(nbh) = pointb%x(nbh) + x_kb
      END DO
      CALL POPREAL8(sum_dely_delu2)
      CALL POPREAL8(sum_delx_delu2)
      CALL POPREAL8(sum_dely_delu1)
      CALL POPREAL8(sum_delx_delu1)
      CALL POPREAL8(sum_delx_dely)
      CALL POPREAL8(sum_dely_sqr)
      CALL POPREAL8(sum_delx_sqr)
      pointb%y(i) = pointb%y(i) + y_ib
      pointb%x(i) = pointb%x(i) + x_ib
    END DO
  END SUBROUTINE COMPUTE_ENSTROPHY_B

  SUBROUTINE COMPUTE_ENSTROPHY()
    IMPLICIT NONE
! call MPI_Allreduce(total_enstrophy, gtotal_enstrophy , 1, &
! & MPI_DOUBLE, MPI_SUM, PETSC_COMM_WORLD, ierr)
! if(rank == 0) then
!write(*,*)"total enstrophy :", gtotal_enstrophy
! end if
    INTEGER :: i, k, r, nbh
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: delx, dely, dist, weights
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delu1, sum_delx_delu2, sum_dely_delu1, &
&   sum_dely_delu2
    REAL*8 :: det
    REAL*8 :: one_by_det
    REAL*8 :: du1_dy, du2_dx, temp
    REAL*8 :: gtotal_enstrophy
    INTRINSIC DSQRT
PetscErrorCode :: ierr
    total_enstrophy = 0.d0
    DO i=1,local_points
      x_i = point%x(i)
      y_i = point%y(i)
      sum_delx_sqr = 0.d0
      sum_dely_sqr = 0.d0
      sum_delx_dely = 0.d0
      sum_delx_delu1 = 0.d0
      sum_dely_delu1 = 0.d0
      sum_delx_delu2 = 0.d0
      sum_dely_delu2 = 0.d0
      DO k=1,point%nbhs(i)
        nbh = point%conn(i, k)
        x_k = point%x(nbh)
        y_k = point%y(nbh)
        delx = x_k - x_i
        dely = y_k - y_i
        dist = DSQRT(delx*delx + dely*dely)
        weights = dist**power
        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
        sum_dely_sqr = sum_dely_sqr + dely*dely*weights
        sum_delx_dely = sum_delx_dely + delx*dely*weights
        sum_delx_delu1 = sum_delx_delu1 + weights*delx*(point%prim(2, &
&         nbh)-point%prim(2, i))
        sum_delx_delu2 = sum_delx_delu2 + weights*delx*(point%prim(3, &
&         nbh)-point%prim(3, i))
        sum_dely_delu1 = sum_dely_delu1 + weights*dely*(point%prim(2, &
&         nbh)-point%prim(2, i))
        sum_dely_delu2 = sum_dely_delu2 + weights*dely*(point%prim(3, &
&         nbh)-point%prim(3, i))
      END DO
      det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
      one_by_det = 1.0d0/det
      du2_dx = (sum_delx_delu2*sum_dely_sqr-sum_dely_delu2*sum_delx_dely&
&       )*one_by_det
      du1_dy = (sum_dely_delu1*sum_delx_sqr-sum_delx_delu1*sum_delx_dely&
&       )*one_by_det
      temp = du2_dx - du1_dy
      point%vorticity(i) = temp
      point%vorticity_sqr(i) = temp*temp
      total_enstrophy = total_enstrophy + point%vorticity_sqr(i)
    END DO
  END SUBROUTINE COMPUTE_ENSTROPHY

END MODULE COMPUTE_ENSTROPHY_MOD_DIFF
