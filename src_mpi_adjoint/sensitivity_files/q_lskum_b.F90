!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE Q_LSKUM_MOD_DIFF
    !	First written on 14.10.2016
    !	updated on Dec 26, 2016
    !	updated on Dec 29, 2016
    USE DATA_STRUCTURE_MOD_DIFF
    USE POINT_NORMALS_MOD_DIFF
    USE GENERATE_CONNECTIVITY_MOD_DIFF
    USE FPI_SOLVER_MOD_DIFF
    USE INITIAL_CONDITIONS_MOD
    USE POST_PROCESSING_MOD
    IMPLICIT NONE
    
    CONTAINS
    !  Differentiation of q_lskum in reverse (adjoint) mode (with options fixinterface):
    !   gradient     of useful results: *vector_cost_func
    !   with respect to varying inputs: mach q_inf theta euler cfl
    !                power *clcd *cd *vector_cost_func *cl *cm vl_const
    !                *(point.x) *(point.y) *(point.nx) *(point.ny)
    !                *(point.min_dist) *(point.prim) *(point.prim_old)
    !                *(point.flux_res) *(point.q) *(point.dq) *(point.qm)
    !                *(point.temp) *(point.vorticity_sqr) *(point.delta)
    !   RW status of diff variables: mach:out q_inf:out theta:out aoa:(loc)
    !                q_init:(loc) euler:out res_new:(loc) cfl:out t:(loc)
    !                sum_res_sqr:(loc) cfv:(loc) *cfv:(loc) max_res:(loc)
    !                cm_flag:(loc) tfinal:(loc) total_enstrophy:(loc)
    !                ens_flag:(loc) total_loss_stagpressure:(loc) power:out
    !                res_old:(loc) cl_cd_flag:(loc) clcd:(loc) *clcd:out
    !                cd:(loc) *cd:out vector_cost_func:(loc) *vector_cost_func:in-out
    !                cl:(loc) *cl:out cm:(loc) *cm:out vl_const:out
    !                cd_flag:(loc) residue:(loc) total_entropy:(loc)
    !                point.original_id:(loc) point.x:(loc) *(point.x):out
    !                point.y:(loc) *(point.y):out point.left:(loc)
    !                point.right:(loc) point.flag_1:(loc) point.flag_2:(loc)
    !                point.qtdepth:(loc) point.nx:(loc) *(point.nx):out
    !                point.ny:(loc) *(point.ny):out point.nbhs:(loc)
    !                point.conn:(loc) point.min_dist:(loc) *(point.min_dist):out
    !                point.prim:(loc) *(point.prim):out point.prim_old:(loc)
    !                *(point.prim_old):out point.flux_res:(loc) *(point.flux_res):out
    !                point.q:(loc) *(point.q):out point.u:(loc) *(point.u):(loc)
    !                point.dq:(loc) *(point.dq):out point.qm:(loc)
    !                *(point.qm):out point.temp:(loc) *(point.temp):out
    !                point.entropy:(loc) *(point.entropy):(loc) point.vorticity:(loc)
    !                *(point.vorticity):(loc) point.vorticity_sqr:(loc)
    !                *(point.vorticity_sqr):out point.xpos_nbhs:(loc)
    !                point.xneg_nbhs:(loc) point.ypos_nbhs:(loc) point.yneg_nbhs:(loc)
    !                point.xpos_conn:(loc) point.xneg_conn:(loc) point.ypos_conn:(loc)
    !                point.yneg_conn:(loc) point.delta:(loc) *(point.delta):out
    !                point.u_old:(loc) *(point.u_old):(loc) fo_flag:(loc)
    !                cl_flag:(loc) gsum_res_sqr:(loc) ent_flag:(loc)
    !                dtg:(loc)
    !   Plus diff mem management of: clcd:in cd:in vector_cost_func:in
    !                cl:in cm:in point.x:in point.y:in point.nx:in
    !                point.ny:in point.min_dist:in point.prim:in point.prim_old:in
    !                point.flux_res:in point.q:in point.dq:in point.qm:in
    !                point.temp:in point.vorticity_sqr:in point.delta:in
    SUBROUTINE Q_LSKUM_B()
        IMPLICIT NONE
        INTEGER :: i
        ! IF (rank .EQ. 0) OPEN(unit=301, file='residue', form='FORMATTED', &
        ! &                   status='REPLACE', action='WRITE') 
        vector_cost_funcb = 1.0d0
        CALL COMPUTE_NORMALS()
        CALL GENERATE_CONNECTIVITY()
        IF (rank .EQ. 0) THEN
            WRITE(*, *) 
            WRITE(*, *) '%%%%-Normals and connectivity generated-%%%'
            WRITE(*, *) 
        END IF
        IF (rank .EQ. 0) THEN
            WRITE(*, *) '%%%%%%%%%%%%%-Iterations begin-%%%%%%%%%%%%'
            WRITE(*, *) 
        END IF
        IF (restart .EQ. 0) itr = 0
        DO it=itr+1,itr+max_iters
            CALL PUSHREAL8ARRAY(point%delta, max_points)
            CALL PUSHREAL8ARRAY(point%temp, 3*4*max_points)
            CALL PUSHREAL8ARRAY(point%qm, 2*4*max_points)
            CALL PUSHREAL8ARRAY(point%dq, 2*4*max_points)
            CALL PUSHREAL8ARRAY(point%q, 4* max_points)
            CALL PUSHREAL8ARRAY(point%flux_res, 4* max_points)
            CALL PUSHREAL8ARRAY(point%prim_old, 4*max_points)
            CALL PUSHREAL8ARRAY(point%prim, 4*max_points)
            CALL FPI_SOLVER(it)
        !     IF (rank .EQ. 0) THEN
        !         WRITE(*, '(a12,i8,a15,e30.20)') 'iterations:', it, 'residue:', &
        !         &     residue
        !         WRITE(301, *) it, residue
        !     end if
        ! CLOSE(unit=301) 
        END DO
        
        IF (rank .EQ. 0) THEN
            WRITE(*, *) '%%%%%%%%%%%%%-Backward Pass Begins-%%%%%%%%%%%%'
            WRITE(*, *) 
        END IF
        IF (ALLOCATED(clb)) clb = 0.0_8
        pointb%x = 0.0_8
        pointb%y = 0.0_8
        pointb%nx = 0.0_8
        pointb%ny = 0.0_8
        pointb%prim = 0.0_8
        pointb%prim_old = 0.0_8
        pointb%flux_res = 0.0_8
        pointb%q = 0.0_8
        pointb%dq = 0.0_8
        pointb%qm = 0.0_8
        pointb%temp = 0.0_8
        pointb%delta = 0.0_8
        DO it=itr+max_iters,itr+1,-1
            CALL POPREAL8ARRAY(point%prim, 4*max_points)
            CALL POPREAL8ARRAY(point%prim_old, 4*max_points)
            CALL POPREAL8ARRAY(point%flux_res, 4*max_points)
            CALL POPREAL8ARRAY(point%q, 4*max_points)
            CALL POPREAL8ARRAY(point%dq, 2*4*max_points)
            CALL POPREAL8ARRAY(point%qm, 2*4*max_points)
            CALL POPREAL8ARRAY(point%temp, 3*4*max_points)
            CALL POPREAL8ARRAY(point%delta, max_points)
            CALL FPI_SOLVER_B(it)
            IF (rank .EQ. 0) THEN
                WRITE(*,*) 'iterations:', it 
            end if
        END DO
        CALL COMPUTE_NORMALS_B()
        CALL PRINT_SENSITIVITY_OUTPUT()
    END SUBROUTINE Q_LSKUM_B
    
END MODULE Q_LSKUM_MOD_DIFF
