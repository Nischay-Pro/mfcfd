!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE OUTER_FLUXES_MOD_DIFF
!
!	First written on 14.10.2016
!
  USE DATA_STRUCTURE_MOD_DIFF
  USE QUADRANT_FLUXES_MOD_DIFF
  USE SPLIT_FLUXES_MOD_DIFF
  USE Q_VARIABLES_MOD_DIFF
  USE LIMITERS_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of outer_dgx_pos in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: power vl_const *(point.x) *(point.y)
!                *(point.nx) *(point.ny) *(point.min_dist) *(point.q)
!                *(point.dq) *(point.qm) g
!   with respect to varying inputs: power vl_const *(point.x) *(point.y)
!                *(point.nx) *(point.ny) *(point.min_dist) *(point.q)
!                *(point.dq) *(point.qm)
!   Plus diff mem management of: point.x:in point.y:in point.nx:in
!                point.ny:in point.min_dist:in point.q:in point.dq:in
!                point.qm:in
!	This subroutine evaluates the wall flux derivative dGs_pos
  SUBROUTINE OUTER_DGX_POS_B(g, gb, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txb, tyb, nxb, nyb
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: delxb, delyb, detb
    REAL*8 :: dels, deln
    REAL*8 :: delsb, delnb
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: dist, weights
    REAL*8 :: distb, weightsb
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_ib(4), phi_kb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsb, deln_weightsb
    REAL*8 :: one_by_det
    REAL*8 :: one_by_detb
    INTRINSIC DSQRT
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    REAL*8, DIMENSION(4) :: tempb1
    REAL*8, DIMENSION(4) :: tempb2
    REAL*8 :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      CALL PUSHREAL8(dist)
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL PUSHREAL8ARRAY(phi_i, 4)
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL PUSHREAL8ARRAY(phi_k, 4)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_i, 4)
      CALL FLUX_QUAD_GXIII(g_i, nx, ny, u1, u2, rho, pr)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_k, 4)
      CALL FLUX_QUAD_GXIII(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    one_by_detb = SUM((sum_delx_delf*sum_dely_sqr-sum_dely_delf*&
&     sum_delx_dely)*gb)
    detb = -(one_by_detb/det**2)
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    tempb4 = one_by_det*gb
    sum_delx_delfb = sum_dely_sqr*tempb4
    sum_dely_sqrb = sum_delx_sqr*detb + SUM(sum_delx_delf*tempb4)
    sum_dely_delfb = -(sum_delx_dely*tempb4)
    sum_delx_delyb = -(2*sum_delx_dely*detb) - SUM(sum_dely_delf*tempb4)
    sum_delx_sqrb = sum_dely_sqr*detb
    txb = 0.0_8
    tyb = 0.0_8
    nxb = 0.0_8
    y_ib = 0.0_8
    nyb = 0.0_8
    g_ib = 0.0_8
    g_kb = 0.0_8
    x_ib = 0.0_8
    phi_ib = 0.0_8
    phi_kb = 0.0_8
    DO j=point%xpos_nbhs(i),1,-1
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      delx = x_k - x_i
      y_k = point%y(k)
      dely = y_k - y_i
      deln = delx*nx + dely*ny
      weights = dist**power
      deln_weights = deln*weights
      dels = delx*tx + dely*ty
      deln_weightsb = dels*sum_delx_delyb + deln*sum_dely_sqrb + SUM((&
&       g_k-g_i)*sum_dely_delfb)
      dels_weights = dels*weights
      g_kb = g_kb + dels_weights*sum_delx_delfb + deln_weights*&
&       sum_dely_delfb
      g_ib = g_ib - dels_weights*sum_delx_delfb - deln_weights*&
&       sum_dely_delfb
      dels_weightsb = dels*sum_delx_sqrb + SUM((g_k-g_i)*sum_delx_delfb)
      CALL POPREAL8ARRAY(g_k, 4)
      CALL FLUX_QUAD_GXIII_B(g_k, g_kb, nx, nxb, ny, nyb, u1, u1b, u2, &
&                      u2b, rho, rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_k, qtilde_kb, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPREAL8ARRAY(g_i, 4)
      CALL FLUX_QUAD_GXIII_B(g_i, g_ib, nx, nxb, ny, nyb, u1, u1b, u2, &
&                      u2b, rho, rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_i, qtilde_ib, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      tempb = -(0.5d0*phi_k*qtilde_kb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      phi_kb = phi_kb - 0.5d0*(delx*point%dq(1, :, k)+dely*point%dq(2, :&
&       , k))*qtilde_kb
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb
      tempb0 = -(0.5d0*phi_i*qtilde_ib)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      phi_ib = phi_ib - 0.5d0*(delx*point%dq(1, :, i)+dely*point%dq(2, :&
&       , i))*qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb0
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb0
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL POPREAL8ARRAY(phi_k, 4)
      CALL VENKAT_LIMITER_B(qtilde_k, qtilde_kb, phi_k, phi_kb, k)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL POPREAL8ARRAY(phi_i, 4)
      CALL VENKAT_LIMITER_B(qtilde_i, qtilde_ib, phi_i, phi_ib, i)
      CALL POPREAL8ARRAY(qtilde_k, 4)
      tempb2 = -(0.5d0*qtilde_kb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb2
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb2
      CALL POPREAL8ARRAY(qtilde_i, 4)
      tempb1 = -(0.5d0*qtilde_ib)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb1
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb1
      weightsb = dels*dels_weightsb + deln*deln_weightsb
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        distb = 0.0
      ELSE
        distb = power*dist**(power-1)*weightsb
      END IF
      CALL POPREAL8(dist)
      IF (dels**2 + deln**2 .EQ. 0.0) THEN
        tempb3 = 0.0
      ELSE
        tempb3 = distb/(2.D0*DSQRT(dels**2+deln**2))
      END IF
      delsb = dels_weights*sum_delx_sqrb + 2*dels*tempb3 + weights*&
&       dels_weightsb + deln_weights*sum_delx_delyb
      delnb = weights*deln_weightsb + 2*deln*tempb3 + deln_weights*&
&       sum_dely_sqrb
      delxb = SUM(point%dq(1, :, i)*tempb0) + SUM(point%dq(1, :, i)*&
&       tempb1) + tx*delsb + nx*delnb + SUM(point%dq(1, :, k)*tempb2) + &
&       SUM(point%dq(1, :, k)*tempb)
      delyb = SUM(point%dq(2, :, i)*tempb0) + SUM(point%dq(2, :, i)*&
&       tempb1) + ty*delsb + ny*delnb + SUM(point%dq(2, :, k)*tempb2) + &
&       SUM(point%dq(2, :, k)*tempb)
      nxb = nxb + delx*delnb
      nyb = nyb + dely*delnb
      txb = txb + delx*delsb
      tyb = tyb + dely*delsb
      y_kb = delyb
      y_ib = y_ib - delyb
      x_kb = delxb
      x_ib = x_ib - delxb
      pointb%y(k) = pointb%y(k) + y_kb
      pointb%x(k) = pointb%x(k) + x_kb
    END DO
    nxb = nxb - tyb
    nyb = nyb + txb
    pointb%ny(i) = pointb%ny(i) + nyb
    pointb%nx(i) = pointb%nx(i) + nxb
    pointb%y(i) = pointb%y(i) + y_ib
    pointb%x(i) = pointb%x(i) + x_ib
  END SUBROUTINE OUTER_DGX_POS_B

!	This subroutine evaluates the wall flux derivative dGs_pos
  SUBROUTINE OUTER_DGX_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXIII(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXIII(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE OUTER_DGX_POS

!  Differentiation of outer_dgx_neg in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: power vl_const *(point.x) *(point.y)
!                *(point.nx) *(point.ny) *(point.min_dist) *(point.q)
!                *(point.dq) *(point.qm) g
!   with respect to varying inputs: power vl_const *(point.x) *(point.y)
!                *(point.nx) *(point.ny) *(point.min_dist) *(point.q)
!                *(point.dq) *(point.qm)
!   Plus diff mem management of: point.x:in point.y:in point.nx:in
!                point.ny:in point.min_dist:in point.q:in point.dq:in
!                point.qm:in
!	This subroutine evaluates the wall flux derivative dGs_neg
  SUBROUTINE OUTER_DGX_NEG_B(g, gb, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txb, tyb, nxb, nyb
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: delxb, delyb, detb
    REAL*8 :: dels, deln
    REAL*8 :: delsb, delnb
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: dist, weights
    REAL*8 :: distb, weightsb
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_ib(4), phi_kb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsb, deln_weightsb
    REAL*8 :: one_by_det
    REAL*8 :: one_by_detb
    INTRINSIC DSQRT
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    REAL*8, DIMENSION(4) :: tempb1
    REAL*8, DIMENSION(4) :: tempb2
    REAL*8 :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      CALL PUSHREAL8(dist)
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL PUSHREAL8ARRAY(phi_i, 4)
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL PUSHREAL8ARRAY(phi_k, 4)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_i, 4)
      CALL FLUX_QUAD_GXIV(g_i, nx, ny, u1, u2, rho, pr)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_k, 4)
      CALL FLUX_QUAD_GXIV(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    one_by_detb = SUM((sum_delx_delf*sum_dely_sqr-sum_dely_delf*&
&     sum_delx_dely)*gb)
    detb = -(one_by_detb/det**2)
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    tempb4 = one_by_det*gb
    sum_delx_delfb = sum_dely_sqr*tempb4
    sum_dely_sqrb = sum_delx_sqr*detb + SUM(sum_delx_delf*tempb4)
    sum_dely_delfb = -(sum_delx_dely*tempb4)
    sum_delx_delyb = -(2*sum_delx_dely*detb) - SUM(sum_dely_delf*tempb4)
    sum_delx_sqrb = sum_dely_sqr*detb
    txb = 0.0_8
    tyb = 0.0_8
    nxb = 0.0_8
    y_ib = 0.0_8
    nyb = 0.0_8
    g_ib = 0.0_8
    g_kb = 0.0_8
    x_ib = 0.0_8
    phi_ib = 0.0_8
    phi_kb = 0.0_8
    DO j=point%xneg_nbhs(i),1,-1
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      delx = x_k - x_i
      y_k = point%y(k)
      dely = y_k - y_i
      deln = delx*nx + dely*ny
      weights = dist**power
      deln_weights = deln*weights
      dels = delx*tx + dely*ty
      deln_weightsb = dels*sum_delx_delyb + deln*sum_dely_sqrb + SUM((&
&       g_k-g_i)*sum_dely_delfb)
      dels_weights = dels*weights
      g_kb = g_kb + dels_weights*sum_delx_delfb + deln_weights*&
&       sum_dely_delfb
      g_ib = g_ib - dels_weights*sum_delx_delfb - deln_weights*&
&       sum_dely_delfb
      dels_weightsb = dels*sum_delx_sqrb + SUM((g_k-g_i)*sum_delx_delfb)
      CALL POPREAL8ARRAY(g_k, 4)
      CALL FLUX_QUAD_GXIV_B(g_k, g_kb, nx, nxb, ny, nyb, u1, u1b, u2, &
&                     u2b, rho, rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_k, qtilde_kb, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPREAL8ARRAY(g_i, 4)
      CALL FLUX_QUAD_GXIV_B(g_i, g_ib, nx, nxb, ny, nyb, u1, u1b, u2, &
&                     u2b, rho, rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_i, qtilde_ib, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      tempb = -(0.5d0*phi_k*qtilde_kb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      phi_kb = phi_kb - 0.5d0*(delx*point%dq(1, :, k)+dely*point%dq(2, :&
&       , k))*qtilde_kb
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb
      tempb0 = -(0.5d0*phi_i*qtilde_ib)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      phi_ib = phi_ib - 0.5d0*(delx*point%dq(1, :, i)+dely*point%dq(2, :&
&       , i))*qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb0
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb0
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL POPREAL8ARRAY(phi_k, 4)
      CALL VENKAT_LIMITER_B(qtilde_k, qtilde_kb, phi_k, phi_kb, k)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL POPREAL8ARRAY(phi_i, 4)
      CALL VENKAT_LIMITER_B(qtilde_i, qtilde_ib, phi_i, phi_ib, i)
      CALL POPREAL8ARRAY(qtilde_k, 4)
      tempb2 = -(0.5d0*qtilde_kb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb2
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb2
      CALL POPREAL8ARRAY(qtilde_i, 4)
      tempb1 = -(0.5d0*qtilde_ib)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb1
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb1
      weightsb = dels*dels_weightsb + deln*deln_weightsb
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        distb = 0.0
      ELSE
        distb = power*dist**(power-1)*weightsb
      END IF
      CALL POPREAL8(dist)
      IF (dels**2 + deln**2 .EQ. 0.0) THEN
        tempb3 = 0.0
      ELSE
        tempb3 = distb/(2.D0*DSQRT(dels**2+deln**2))
      END IF
      delsb = dels_weights*sum_delx_sqrb + 2*dels*tempb3 + weights*&
&       dels_weightsb + deln_weights*sum_delx_delyb
      delnb = weights*deln_weightsb + 2*deln*tempb3 + deln_weights*&
&       sum_dely_sqrb
      delxb = SUM(point%dq(1, :, i)*tempb0) + SUM(point%dq(1, :, i)*&
&       tempb1) + tx*delsb + nx*delnb + SUM(point%dq(1, :, k)*tempb2) + &
&       SUM(point%dq(1, :, k)*tempb)
      delyb = SUM(point%dq(2, :, i)*tempb0) + SUM(point%dq(2, :, i)*&
&       tempb1) + ty*delsb + ny*delnb + SUM(point%dq(2, :, k)*tempb2) + &
&       SUM(point%dq(2, :, k)*tempb)
      nxb = nxb + delx*delnb
      nyb = nyb + dely*delnb
      txb = txb + delx*delsb
      tyb = tyb + dely*delsb
      y_kb = delyb
      y_ib = y_ib - delyb
      x_kb = delxb
      x_ib = x_ib - delxb
      pointb%y(k) = pointb%y(k) + y_kb
      pointb%x(k) = pointb%x(k) + x_kb
    END DO
    nxb = nxb - tyb
    nyb = nyb + txb
    pointb%ny(i) = pointb%ny(i) + nyb
    pointb%nx(i) = pointb%nx(i) + nxb
    pointb%y(i) = pointb%y(i) + y_ib
    pointb%x(i) = pointb%x(i) + x_ib
  END SUBROUTINE OUTER_DGX_NEG_B

!	This subroutine evaluates the wall flux derivative dGs_neg
  SUBROUTINE OUTER_DGX_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXIV(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXIV(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE OUTER_DGX_NEG

!  Differentiation of outer_dgy_pos in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: power vl_const *(point.x) *(point.y)
!                *(point.nx) *(point.ny) *(point.min_dist) *(point.q)
!                *(point.dq) *(point.qm) g
!   with respect to varying inputs: power vl_const *(point.x) *(point.y)
!                *(point.nx) *(point.ny) *(point.min_dist) *(point.q)
!                *(point.dq) *(point.qm)
!   Plus diff mem management of: point.x:in point.y:in point.nx:in
!                point.ny:in point.min_dist:in point.q:in point.dq:in
!                point.qm:in
  SUBROUTINE OUTER_DGY_POS_B(g, gb, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txb, tyb, nxb, nyb
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: delxb, delyb, detb
    REAL*8 :: dels, deln
    REAL*8 :: delsb, delnb
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: dist, weights
    REAL*8 :: distb, weightsb
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_ib(4), phi_kb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsb, deln_weightsb
    REAL*8 :: one_by_det
    REAL*8 :: one_by_detb
    INTRINSIC DSQRT
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    REAL*8, DIMENSION(4) :: tempb1
    REAL*8, DIMENSION(4) :: tempb2
    REAL*8 :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%ypos_nbhs(i)
      k = point%ypos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      CALL PUSHREAL8(dist)
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL PUSHREAL8ARRAY(phi_i, 4)
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL PUSHREAL8ARRAY(phi_k, 4)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_i, 4)
      CALL FLUX_GYP(g_i, nx, ny, u1, u2, rho, pr)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL PUSHREAL8ARRAY(g_k, 4)
      CALL FLUX_GYP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    one_by_detb = SUM((sum_dely_delf*sum_delx_sqr-sum_delx_delf*&
&     sum_delx_dely)*gb)
    detb = -(one_by_detb/det**2)
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    tempb4 = one_by_det*gb
    sum_dely_delfb = sum_delx_sqr*tempb4
    sum_delx_sqrb = sum_dely_sqr*detb + SUM(sum_dely_delf*tempb4)
    sum_delx_delfb = -(sum_delx_dely*tempb4)
    sum_delx_delyb = -(2*sum_delx_dely*detb) - SUM(sum_delx_delf*tempb4)
    sum_dely_sqrb = sum_delx_sqr*detb
    txb = 0.0_8
    tyb = 0.0_8
    nxb = 0.0_8
    y_ib = 0.0_8
    nyb = 0.0_8
    g_ib = 0.0_8
    g_kb = 0.0_8
    x_ib = 0.0_8
    phi_ib = 0.0_8
    phi_kb = 0.0_8
    DO j=point%ypos_nbhs(i),1,-1
      k = point%ypos_conn(i, j)
      x_k = point%x(k)
      delx = x_k - x_i
      y_k = point%y(k)
      dely = y_k - y_i
      deln = delx*nx + dely*ny
      weights = dist**power
      deln_weights = deln*weights
      dels = delx*tx + dely*ty
      deln_weightsb = dels*sum_delx_delyb + deln*sum_dely_sqrb + SUM((&
&       g_k-g_i)*sum_dely_delfb)
      dels_weights = dels*weights
      g_kb = g_kb + dels_weights*sum_delx_delfb + deln_weights*&
&       sum_dely_delfb
      g_ib = g_ib - dels_weights*sum_delx_delfb - deln_weights*&
&       sum_dely_delfb
      dels_weightsb = dels*sum_delx_sqrb + SUM((g_k-g_i)*sum_delx_delfb)
      CALL POPREAL8ARRAY(g_k, 4)
      CALL FLUX_GYP_B(g_k, g_kb, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_k, qtilde_kb, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      CALL POPREAL8ARRAY(g_i, 4)
      CALL FLUX_GYP_B(g_i, g_ib, nx, nxb, ny, nyb, u1, u1b, u2, u2b, rho&
&               , rhob, pr, prb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u2)
      CALL POPREAL8(rho)
      CALL POPREAL8(pr)
      CALL QTILDE_TO_PRIMITIVE_B(qtilde_i, qtilde_ib, u1, u1b, u2, u2b, &
&                          rho, rhob, pr, prb)
      tempb = -(0.5d0*phi_k*qtilde_kb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      phi_kb = phi_kb - 0.5d0*(delx*point%dq(1, :, k)+dely*point%dq(2, :&
&       , k))*qtilde_kb
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb
      tempb0 = -(0.5d0*phi_i*qtilde_ib)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      phi_ib = phi_ib - 0.5d0*(delx*point%dq(1, :, i)+dely*point%dq(2, :&
&       , i))*qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb0
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb0
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL POPREAL8ARRAY(phi_k, 4)
      CALL VENKAT_LIMITER_B(qtilde_k, qtilde_kb, phi_k, phi_kb, k)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL POPREAL8ARRAY(phi_i, 4)
      CALL VENKAT_LIMITER_B(qtilde_i, qtilde_ib, phi_i, phi_ib, i)
      CALL POPREAL8ARRAY(qtilde_k, 4)
      tempb2 = -(0.5d0*qtilde_kb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb2
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb2
      CALL POPREAL8ARRAY(qtilde_i, 4)
      tempb1 = -(0.5d0*qtilde_ib)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb1
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb1
      weightsb = dels*dels_weightsb + deln*deln_weightsb
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        distb = 0.0
      ELSE
        distb = power*dist**(power-1)*weightsb
      END IF
      CALL POPREAL8(dist)
      IF (dels**2 + deln**2 .EQ. 0.0) THEN
        tempb3 = 0.0
      ELSE
        tempb3 = distb/(2.D0*DSQRT(dels**2+deln**2))
      END IF
      delsb = dels_weights*sum_delx_sqrb + 2*dels*tempb3 + weights*&
&       dels_weightsb + deln_weights*sum_delx_delyb
      delnb = weights*deln_weightsb + 2*deln*tempb3 + deln_weights*&
&       sum_dely_sqrb
      delxb = SUM(point%dq(1, :, i)*tempb0) + SUM(point%dq(1, :, i)*&
&       tempb1) + tx*delsb + nx*delnb + SUM(point%dq(1, :, k)*tempb2) + &
&       SUM(point%dq(1, :, k)*tempb)
      delyb = SUM(point%dq(2, :, i)*tempb0) + SUM(point%dq(2, :, i)*&
&       tempb1) + ty*delsb + ny*delnb + SUM(point%dq(2, :, k)*tempb2) + &
&       SUM(point%dq(2, :, k)*tempb)
      nxb = nxb + delx*delnb
      nyb = nyb + dely*delnb
      txb = txb + delx*delsb
      tyb = tyb + dely*delsb
      y_kb = delyb
      y_ib = y_ib - delyb
      x_kb = delxb
      x_ib = x_ib - delxb
      pointb%y(k) = pointb%y(k) + y_kb
      pointb%x(k) = pointb%x(k) + x_kb
    END DO
    nxb = nxb - tyb
    nyb = nyb + txb
    pointb%ny(i) = pointb%ny(i) + nyb
    pointb%nx(i) = pointb%nx(i) + nxb
    pointb%y(i) = pointb%y(i) + y_ib
    pointb%x(i) = pointb%x(i) + x_ib
  END SUBROUTINE OUTER_DGY_POS_B

  SUBROUTINE OUTER_DGY_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%ypos_nbhs(i)
      k = point%ypos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      dist = DSQRT(dels*dels + deln*deln)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
      CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
      qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&       dely*point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&       dely*point%dq(2, :, k))
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GYP(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GYP(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE OUTER_DGY_POS

END MODULE OUTER_FLUXES_MOD_DIFF
