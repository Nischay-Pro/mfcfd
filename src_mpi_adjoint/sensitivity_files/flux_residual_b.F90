!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:36
!
MODULE FLUX_RESIDUAL_MOD_DIFF
  USE PARAMETER_MOD_DIFF
  USE DATA_STRUCTURE_MOD_DIFF
  USE INTERIOR_FLUXES_MOD_DIFF
  USE WALL_FLUXES_MOD_DIFF
  USE OUTER_FLUXES_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of cal_flux_residual in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: power vl_const *(point.x) *(point.y)
!                *(point.nx) *(point.ny) *(point.min_dist) *(point.flux_res)
!                *(point.q) *(point.dq) *(point.qm) *(point.delta)
!   with respect to varying inputs: power vl_const *(point.x) *(point.y)
!                *(point.nx) *(point.ny) *(point.min_dist) *(point.flux_res)
!                *(point.q) *(point.dq) *(point.qm) *(point.delta)
!   Plus diff mem management of: point.x:in point.y:in point.nx:in
!                point.ny:in point.min_dist:in point.flux_res:in
!                point.q:in point.dq:in point.qm:in point.delta:in
  SUBROUTINE CAL_FLUX_RESIDUAL_B()
    IMPLICIT NONE
    INTEGER :: i, k
    REAL*8 :: gxp(4), gxn(4), gyp(4), gyn(4)
    REAL*8 :: gxpb(4), gxnb(4), gypb(4), gynb(4)
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    DO i=1,wall_points
      k = wall_points_index(i)
      CALL WALL_DGX_POS(gxp, k)
      CALL WALL_DGX_NEG(gxn, k)
      CALL WALL_DGY_NEG(gyn, k)
      CALL PUSHREAL8ARRAY(point%flux_res(:, k), 4)
      point%flux_res(:, k) = gxp + gxn + gyn
      CALL PUSHREAL8ARRAY(point%flux_res(:, k), 4)
      point%flux_res(:, k) = 2.0d0*point%delta(k)*point%flux_res(:, k)
    END DO
    DO i=1,outer_points
      k = outer_points_index(i)
      CALL PUSHREAL8ARRAY(gxp, 4)
      CALL OUTER_DGX_POS(gxp, k)
      CALL PUSHREAL8ARRAY(gxn, 4)
      CALL OUTER_DGX_NEG(gxn, k)
      CALL PUSHREAL8ARRAY(gyp, 4)
      CALL OUTER_DGY_POS(gyp, k)
    END DO
    DO i=1,interior_points
      k = interior_points_index(i)
      CALL PUSHREAL8ARRAY(gxp, 4)
      CALL INTERIOR_DGX_POS(gxp, k)
      CALL PUSHREAL8ARRAY(gxn, 4)
      CALL INTERIOR_DGX_NEG(gxn, k)
      CALL PUSHREAL8ARRAY(gyp, 4)
      CALL INTERIOR_DGY_POS(gyp, k)
      CALL PUSHREAL8ARRAY(gyn, 4)
      CALL INTERIOR_DGY_NEG(gyn, k)
    END DO
    DO i=interior_points,1,-1
      k = interior_points_index(i)
      gxnb = 0.0_8
      gxpb = 0.0_8
      gynb = 0.0_8
      gypb = 0.0_8
      tempb0 = point%delta(k)*pointb%flux_res(:, k)
      pointb%delta(k) = pointb%delta(k) + SUM((gxp+gxn+gyp+gyn)*pointb%&
&       flux_res(:, k))
      gxpb = tempb0
      gxnb = tempb0
      gypb = tempb0
      gynb = tempb0
      pointb%flux_res(:, k) = 0.0_8
      CALL POPREAL8ARRAY(gyn, 4)
      CALL INTERIOR_DGY_NEG_B(gyn, gynb, k)
      CALL POPREAL8ARRAY(gyp, 4)
      CALL INTERIOR_DGY_POS_B(gyp, gypb, k)
      CALL POPREAL8ARRAY(gxn, 4)
      CALL INTERIOR_DGX_NEG_B(gxn, gxnb, k)
      CALL POPREAL8ARRAY(gxp, 4)
      CALL INTERIOR_DGX_POS_B(gxp, gxpb, k)
    END DO
    DO i=outer_points,1,-1
      k = outer_points_index(i)
      gxnb = 0.0_8
      gxpb = 0.0_8
      gypb = 0.0_8
      tempb = point%delta(k)*pointb%flux_res(:, k)
      pointb%delta(k) = pointb%delta(k) + SUM((gxp+gxn+gyp)*pointb%&
&       flux_res(:, k))
      gxpb = tempb
      gxnb = tempb
      gypb = tempb
      pointb%flux_res(:, k) = 0.0_8
      CALL POPREAL8ARRAY(gyp, 4)
      CALL OUTER_DGY_POS_B(gyp, gypb, k)
      CALL POPREAL8ARRAY(gxn, 4)
      CALL OUTER_DGX_NEG_B(gxn, gxnb, k)
      CALL POPREAL8ARRAY(gxp, 4)
      CALL OUTER_DGX_POS_B(gxp, gxpb, k)
    END DO
    DO i=wall_points,1,-1
      k = wall_points_index(i)
      CALL POPREAL8ARRAY(point%flux_res(:, k), 4)
      pointb%delta(k) = pointb%delta(k) + 2.0d0*SUM(point%flux_res(:, k)&
&       *pointb%flux_res(:, k))
      pointb%flux_res(:, k) = 2.0d0*point%delta(k)*pointb%flux_res(:, k)
      gxnb = 0.0_8
      gxpb = 0.0_8
      gynb = 0.0_8
      CALL POPREAL8ARRAY(point%flux_res(:, k), 4)
      gxpb = pointb%flux_res(:, k)
      gxnb = pointb%flux_res(:, k)
      gynb = pointb%flux_res(:, k)
      pointb%flux_res(:, k) = 0.0_8
      CALL WALL_DGY_NEG_B(gyn, gynb, k)
      CALL WALL_DGX_NEG_B(gxn, gxnb, k)
      CALL WALL_DGX_POS_B(gxp, gxpb, k)
    END DO
  END SUBROUTINE CAL_FLUX_RESIDUAL_B

  SUBROUTINE CAL_FLUX_RESIDUAL()
    IMPLICIT NONE
    INTEGER :: i, k
    REAL*8 :: gxp(4), gxn(4), gyp(4), gyn(4)
    DO i=1,wall_points
      k = wall_points_index(i)
      CALL WALL_DGX_POS(gxp, k)
      CALL WALL_DGX_NEG(gxn, k)
      CALL WALL_DGY_NEG(gyn, k)
      point%flux_res(:, k) = gxp + gxn + gyn
      point%flux_res(:, k) = 2.0d0*point%delta(k)*point%flux_res(:, k)
    END DO
    DO i=1,outer_points
      k = outer_points_index(i)
      CALL OUTER_DGX_POS(gxp, k)
      CALL OUTER_DGX_NEG(gxn, k)
      CALL OUTER_DGY_POS(gyp, k)
      point%flux_res(:, k) = point%delta(k)*(gxp+gxn+gyp)
    END DO
    DO i=1,interior_points
      k = interior_points_index(i)
      CALL INTERIOR_DGX_POS(gxp, k)
      CALL INTERIOR_DGX_NEG(gxn, k)
      CALL INTERIOR_DGY_POS(gyp, k)
      CALL INTERIOR_DGY_NEG(gyn, k)
      point%flux_res(:, k) = point%delta(k)*(gxp+gxn+gyp+gyn)
    END DO
  END SUBROUTINE CAL_FLUX_RESIDUAL

END MODULE FLUX_RESIDUAL_MOD_DIFF
