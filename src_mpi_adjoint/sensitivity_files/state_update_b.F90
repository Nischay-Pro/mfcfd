!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:47
!
MODULE STATE_UPDATE_MOD_DIFF
#include <petsc/finclude/petscsys.h>
  USE DATA_STRUCTURE_MOD_DIFF
  USE PETSC_DATA_STRUCTURE_MOD
  USE FLUX_RESIDUAL_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of state_update in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: *(point.nx) *(point.ny) *(point.prim)
!                *(point.prim_old) *(point.flux_res)
!   with respect to varying inputs: *(point.nx) *(point.ny) *(point.prim)
!                *(point.prim_old) *(point.flux_res)
!   Plus diff mem management of: point.nx:in point.ny:in point.prim:in
!                point.prim_old:in point.flux_res:in
  SUBROUTINE STATE_UPDATE_B(rk)
    IMPLICIT NONE
    INTEGER :: i, k, r, rk
    REAL*8 :: delt, u(4), temp, u_old(4)
    REAL*8 :: ub(4), tempb, u_oldb(4)
    REAL*8 :: res_sqr
    REAL*8 :: nx, ny
    REAL*8 :: nxb, nyb
    REAL*8 :: u2_rot, u3_rot
    REAL*8 :: u2_rotb, u3_rotb
    REAL*8, PARAMETER :: obt=1.0d0/3.0d0
    REAL*8, PARAMETER :: tbt=2.0d0/3.0d0
    REAL*8 :: tempb0
    INTEGER :: branch
    DO i=1,wall_points
      k = wall_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PUSHREAL8ARRAY(u, 4)
      CALL PRIMITIVE_TO_CONSERVED(point%prim(:, k), nx, ny, u)
      CALL PRIMITIVE_TO_CONSERVED(point%prim_old(:, k), nx, ny, u_old)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
        CALL PUSHCONTROL1B(0)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
        CALL PUSHCONTROL1B(1)
      END IF
      u(3) = 0.d0
      CALL PUSHREAL8(u2_rot)
      u2_rot = u(2)
      CALL PUSHREAL8(u3_rot)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      CALL PUSHREAL8(point%prim(1, k))
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      CALL PUSHREAL8(point%prim(2, k))
      point%prim(2, k) = u(2)*temp
      CALL PUSHREAL8(point%prim(3, k))
      point%prim(3, k) = u(3)*temp
      CALL PUSHREAL8(point%prim(4, k))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,outer_points
      k = outer_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PUSHREAL8ARRAY(u, 4)
      CALL CONSERVED_VECTOR_UBAR(point%prim(:, k), u, nx, ny)
      CALL CONSERVED_VECTOR_UBAR(point%prim_old(:, k), u_old, nx, ny)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
        CALL PUSHCONTROL1B(0)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8(u2_rot)
      u2_rot = u(2)
      CALL PUSHREAL8(u3_rot)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      CALL PUSHREAL8(point%prim(1, k))
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      CALL PUSHREAL8(point%prim(2, k))
      point%prim(2, k) = u(2)*temp
      CALL PUSHREAL8(point%prim(3, k))
      point%prim(3, k) = u(3)*temp
      CALL PUSHREAL8(point%prim(4, k))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,interior_points
      k = interior_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PUSHREAL8ARRAY(u, 4)
      CALL PRIMITIVE_TO_CONSERVED(point%prim(:, k), nx, ny, u)
      CALL PRIMITIVE_TO_CONSERVED(point%prim_old(:, k), nx, ny, u_old)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
        CALL PUSHCONTROL1B(0)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8(u2_rot)
      u2_rot = u(2)
      CALL PUSHREAL8(u3_rot)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      CALL PUSHREAL8(point%prim(1, k))
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      CALL PUSHREAL8(point%prim(2, k))
      point%prim(2, k) = u(2)*temp
      CALL PUSHREAL8(point%prim(3, k))
      point%prim(3, k) = u(3)*temp
      CALL PUSHREAL8(point%prim(4, k))
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    ub = 0.0_8
    u_oldb = 0.0_8
    DO i=interior_points,1,-1
      k = interior_points_index(i)
      temp = 1.0d0/u(1)
      CALL POPREAL8(point%prim(4, k))
      ub(4) = ub(4) + 0.4d0*pointb%prim(4, k)
      tempb = -((u(2)**2+u(3)**2)*0.2d0*pointb%prim(4, k))
      tempb0 = -(temp*0.2d0*pointb%prim(4, k))
      pointb%prim(4, k) = 0.0_8
      ub(3) = ub(3) + 2*u(3)*tempb0 + temp*pointb%prim(3, k)
      CALL POPREAL8(point%prim(3, k))
      tempb = tempb + u(3)*pointb%prim(3, k)
      pointb%prim(3, k) = 0.0_8
      ub(2) = ub(2) + 2*u(2)*tempb0 + temp*pointb%prim(2, k)
      CALL POPREAL8(point%prim(2, k))
      tempb = tempb + u(2)*pointb%prim(2, k)
      pointb%prim(2, k) = 0.0_8
      ub(1) = ub(1) + pointb%prim(1, k) - tempb/u(1)**2
      CALL POPREAL8(point%prim(1, k))
      pointb%prim(1, k) = 0.0_8
      nx = point%nx(k)
      ny = point%ny(k)
      u3_rotb = ny*ub(3) + nx*ub(2)
      nyb = u3_rot*ub(3) + u2_rot*ub(2)
      u2_rotb = ny*ub(2) - nx*ub(3)
      nxb = u3_rot*ub(2) - u2_rot*ub(3)
      ub(3) = u3_rotb
      ub(2) = u2_rotb
      CALL POPREAL8(u3_rot)
      CALL POPREAL8(u2_rot)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        pointb%flux_res(:, k) = pointb%flux_res(:, k) - euler*0.5d0*ub
      ELSE
        u_oldb = u_oldb + tbt*ub
        pointb%flux_res(:, k) = pointb%flux_res(:, k) - 0.5d0*obt*ub
        ub = obt*ub
      END IF
      CALL PRIMITIVE_TO_CONSERVED_B(point%prim_old(:, k), pointb%&
&                             prim_old(:, k), nx, nxb, ny, nyb, u_old, &
&                             u_oldb)
      CALL POPREAL8ARRAY(u, 4)
      CALL PRIMITIVE_TO_CONSERVED_B(point%prim(:, k), pointb%prim(:, k)&
&                             , nx, nxb, ny, nyb, u, ub)
      pointb%ny(k) = pointb%ny(k) + nyb
      pointb%nx(k) = pointb%nx(k) + nxb
    END DO
    DO i=outer_points,1,-1
      k = outer_points_index(i)
      temp = 1.0d0/u(1)
      CALL POPREAL8(point%prim(4, k))
      ub(4) = ub(4) + 0.4d0*pointb%prim(4, k)
      tempb = -((u(2)**2+u(3)**2)*0.2d0*pointb%prim(4, k))
      tempb0 = -(temp*0.2d0*pointb%prim(4, k))
      pointb%prim(4, k) = 0.0_8
      ub(3) = ub(3) + 2*u(3)*tempb0 + temp*pointb%prim(3, k)
      CALL POPREAL8(point%prim(3, k))
      tempb = tempb + u(3)*pointb%prim(3, k)
      pointb%prim(3, k) = 0.0_8
      ub(2) = ub(2) + 2*u(2)*tempb0 + temp*pointb%prim(2, k)
      CALL POPREAL8(point%prim(2, k))
      tempb = tempb + u(2)*pointb%prim(2, k)
      pointb%prim(2, k) = 0.0_8
      ub(1) = ub(1) + pointb%prim(1, k) - tempb/u(1)**2
      CALL POPREAL8(point%prim(1, k))
      pointb%prim(1, k) = 0.0_8
      nx = point%nx(k)
      ny = point%ny(k)
      u3_rotb = ny*ub(3) + nx*ub(2)
      nyb = u3_rot*ub(3) + u2_rot*ub(2)
      u2_rotb = ny*ub(2) - nx*ub(3)
      nxb = u3_rot*ub(2) - u2_rot*ub(3)
      ub(3) = u3_rotb
      ub(2) = u2_rotb
      CALL POPREAL8(u3_rot)
      CALL POPREAL8(u2_rot)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        pointb%flux_res(:, k) = pointb%flux_res(:, k) - euler*0.5d0*ub
      ELSE
        u_oldb = u_oldb + tbt*ub
        pointb%flux_res(:, k) = pointb%flux_res(:, k) - 0.5d0*obt*ub
        ub = obt*ub
      END IF
      CALL CONSERVED_VECTOR_UBAR_B(point%prim_old(:, k), pointb%prim_old&
&                            (:, k), u_old, u_oldb, nx, nxb, ny, nyb)
      CALL POPREAL8ARRAY(u, 4)
      CALL CONSERVED_VECTOR_UBAR_B(point%prim(:, k), pointb%prim(:, k), &
&                            u, ub, nx, nxb, ny, nyb)
      pointb%ny(k) = pointb%ny(k) + nyb
      pointb%nx(k) = pointb%nx(k) + nxb
    END DO
    DO i=wall_points,1,-1
      k = wall_points_index(i)
      temp = 1.0d0/u(1)
      CALL POPREAL8(point%prim(4, k))
      ub(4) = ub(4) + 0.4d0*pointb%prim(4, k)
      tempb = -((u(2)**2+u(3)**2)*0.2d0*pointb%prim(4, k))
      tempb0 = -(temp*0.2d0*pointb%prim(4, k))
      pointb%prim(4, k) = 0.0_8
      ub(3) = ub(3) + 2*u(3)*tempb0 + temp*pointb%prim(3, k)
      CALL POPREAL8(point%prim(3, k))
      tempb = tempb + u(3)*pointb%prim(3, k)
      pointb%prim(3, k) = 0.0_8
      ub(2) = ub(2) + 2*u(2)*tempb0 + temp*pointb%prim(2, k)
      CALL POPREAL8(point%prim(2, k))
      tempb = tempb + u(2)*pointb%prim(2, k)
      pointb%prim(2, k) = 0.0_8
      ub(1) = ub(1) + pointb%prim(1, k) - tempb/u(1)**2
      CALL POPREAL8(point%prim(1, k))
      pointb%prim(1, k) = 0.0_8
      nx = point%nx(k)
      ny = point%ny(k)
      u3_rotb = ny*ub(3) + nx*ub(2)
      nyb = u3_rot*ub(3) + u2_rot*ub(2)
      u2_rotb = ny*ub(2) - nx*ub(3)
      nxb = u3_rot*ub(2) - u2_rot*ub(3)
      ub(2) = u2_rotb
      CALL POPREAL8(u3_rot)
      CALL POPREAL8(u2_rot)
      ub(3) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        pointb%flux_res(:, k) = pointb%flux_res(:, k) - euler*0.5d0*ub
      ELSE
        u_oldb = u_oldb + tbt*ub
        pointb%flux_res(:, k) = pointb%flux_res(:, k) - 0.5d0*obt*ub
        ub = obt*ub
      END IF
      CALL PRIMITIVE_TO_CONSERVED_B(point%prim_old(:, k), pointb%&
&                             prim_old(:, k), nx, nxb, ny, nyb, u_old, &
&                             u_oldb)
      CALL POPREAL8ARRAY(u, 4)
      CALL PRIMITIVE_TO_CONSERVED_B(point%prim(:, k), pointb%prim(:, k)&
&                             , nx, nxb, ny, nyb, u, ub)
      pointb%ny(k) = pointb%ny(k) + nyb
      pointb%nx(k) = pointb%nx(k) + nxb
    END DO
  END SUBROUTINE STATE_UPDATE_B

  SUBROUTINE STATE_UPDATE(rk)
    IMPLICIT NONE
    INTEGER :: i, k, r, rk
    REAL*8 :: delt, u(4), temp, u_old(4)
    REAL*8 :: res_sqr
    REAL*8 :: nx, ny
    REAL*8 :: u2_rot, u3_rot
    REAL*8, PARAMETER :: obt=1.0d0/3.0d0
    REAL*8, PARAMETER :: tbt=2.0d0/3.0d0
    max_res = 0.0d0
    sum_res_sqr = 0.0d0
    DO i=1,wall_points
      k = wall_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PRIMITIVE_TO_CONSERVED(point%prim(:, k), nx, ny, u)
      CALL PRIMITIVE_TO_CONSERVED(point%prim_old(:, k), nx, ny, u_old)
      temp = u(1)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u(3) = 0.d0
      u2_rot = u(2)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      res_sqr = (u(1)-temp)*(u(1)-temp)
      IF (res_sqr .GT. max_res) THEN
        max_res = res_sqr
        max_res_point = k
      END IF
      sum_res_sqr = sum_res_sqr + res_sqr
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      point%prim(2, k) = u(2)*temp
      point%prim(3, k) = u(3)*temp
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,outer_points
      k = outer_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL CONSERVED_VECTOR_UBAR(point%prim(:, k), u, nx, ny)
      CALL CONSERVED_VECTOR_UBAR(point%prim_old(:, k), u_old, nx, ny)
      temp = u(1)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u2_rot = u(2)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      point%prim(2, k) = u(2)*temp
      point%prim(3, k) = u(3)*temp
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
    DO i=1,interior_points
      k = interior_points_index(i)
      nx = point%nx(k)
      ny = point%ny(k)
      CALL PRIMITIVE_TO_CONSERVED(point%prim(:, k), nx, ny, u)
      CALL PRIMITIVE_TO_CONSERVED(point%prim_old(:, k), nx, ny, u_old)
      temp = u(1)
      IF (rk .NE. 3) THEN
        u = u - 0.5d0*euler*point%flux_res(:, k)
      ELSE
        u = tbt*u_old + obt*(u-0.5d0*point%flux_res(:, k))
      END IF
      u2_rot = u(2)
      u3_rot = u(3)
      u(2) = u2_rot*ny + u3_rot*nx
      u(3) = u3_rot*ny - u2_rot*nx
      res_sqr = (u(1)-temp)*(u(1)-temp)
      IF (res_sqr .GT. max_res) THEN
        max_res = res_sqr
        max_res_point = k
      END IF
      sum_res_sqr = sum_res_sqr + res_sqr
      point%prim(1, k) = u(1)
      temp = 1.0d0/u(1)
      point%prim(2, k) = u(2)*temp
      point%prim(3, k) = u(3)*temp
      point%prim(4, k) = 0.4d0*u(4) - 0.2d0*temp*(u(2)*u(2)+u(3)*u(3))
    END DO
  END SUBROUTINE STATE_UPDATE

!  Differentiation of primitive_to_conserved in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: prim u nx ny
!   with respect to varying inputs: prim u nx ny
  SUBROUTINE PRIMITIVE_TO_CONSERVED_B(prim, primb, nx, nxb, ny, nyb, u, &
&   ub)
    IMPLICIT NONE
    REAL*8 :: rho, prim(4)
    REAL*8 :: rhob, primb(4)
    REAL*8 :: u(4), nx, ny
    REAL*8 :: ub(4), nxb, nyb
    REAL*8 :: temp1, temp2
    REAL*8 :: temp1b, temp2b
    REAL*8 :: tempb
    rho = prim(1)
    temp1 = rho*prim(2)
    temp2 = rho*prim(3)
    tempb = 0.5d0*ub(4)/rho
    temp1b = nx*ub(3) + ny*ub(2) + 2*temp1*tempb
    nxb = nxb + temp1*ub(3) - temp2*ub(2)
    temp2b = ny*ub(3) + 2*temp2*tempb - nx*ub(2)
    nyb = nyb + temp2*ub(3) + temp1*ub(2)
    ub(3) = 0.0_8
    ub(2) = 0.0_8
    primb(4) = primb(4) + 2.5d0*ub(4)
    ub(4) = 0.0_8
    rhob = prim(3)*temp2b - (temp1**2+temp2**2)*tempb/rho + prim(2)*&
&     temp1b + ub(1)
    primb(3) = primb(3) + rho*temp2b
    primb(2) = primb(2) + rho*temp1b
    ub(1) = 0.0_8
    primb(1) = primb(1) + rhob
  END SUBROUTINE PRIMITIVE_TO_CONSERVED_B

  SUBROUTINE PRIMITIVE_TO_CONSERVED(prim, nx, ny, u)
    IMPLICIT NONE
    REAL*8 :: rho, prim(4)
    REAL*8 :: u(4), nx, ny
    REAL*8 :: temp1, temp2
    rho = prim(1)
    u(1) = rho
    temp1 = rho*prim(2)
    temp2 = rho*prim(3)
    u(4) = 2.5d0*prim(4) + 0.5d0*(temp1*temp1+temp2*temp2)/rho
    u(2) = temp1*ny - temp2*nx
    u(3) = temp1*nx + temp2*ny
  END SUBROUTINE PRIMITIVE_TO_CONSERVED

  SUBROUTINE CONSERVED_TO_PRIMITIVE(u, prim)
    IMPLICIT NONE
    REAL*8 :: temp, u(4), prim(4)
    prim(1) = u(1)
    temp = 1.0d0/u(1)
    prim(2) = u(2)*temp
    prim(3) = u(3)*temp
    temp = u(4) - 0.5d0*temp*(u(2)*u(2)+u(3)*u(3))
    prim(4) = 0.4d0*temp
  END SUBROUTINE CONSERVED_TO_PRIMITIVE

!  Differentiation of func_delta in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: *(point.x) *(point.y) *(point.prim)
!                *(point.delta)
!   with respect to varying inputs: *(point.x) *(point.y) *(point.prim)
!                *(point.delta)
!   Plus diff mem management of: point.x:in point.y:in point.prim:in
!                point.delta:in
!	This subroutine computes the delta_t (local time step) at a given point ..
  SUBROUTINE FUNC_DELTA_B()
    IMPLICIT NONE
    INTEGER :: i, k, r
    REAL*8 :: delta_t
    REAL*8 :: delta_tb
    REAL*8 :: min_dist
    REAL*8, SAVE :: lmin=1.0d0
    REAL*8 :: gmin
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: u1, u2, rho, pr, mod_u
    REAL*8 :: u1b, u2b, rhob, prb, mod_ub
    REAL*8 :: dist
    REAL*8 :: distb
    REAL*8 :: min_delt
    REAL*8 :: min_deltb
    INTRINSIC DSQRT
    REAL*8 :: tempb
    REAL*8 :: temp
    REAL*8 :: tempb0
    DOUBLE PRECISION :: temp0
    REAL*8 :: tempb1
    INTEGER :: ad_to
    INTEGER :: branch
    PetscErrorCode :: ierr
    DO i=1,local_points
      min_delt = 1.0d0
      DO r=1,point%nbhs(i)
        k = point%conn(i, r)
        rho = point%prim(1, k)
        u1 = point%prim(2, k)
        u2 = point%prim(3, k)
        pr = point%prim(4, k)
        x_i = point%x(i)
        y_i = point%y(i)
        x_k = point%x(k)
        y_k = point%y(k)
        CALL PUSHREAL8(dist)
        dist = (x_k-x_i)*(x_k-x_i) + (y_k-y_i)*(y_k-y_i)
        CALL PUSHREAL8(dist)
        dist = DSQRT(dist)
        CALL PUSHREAL8(mod_u)
        mod_u = DSQRT(u1*u1 + u2*u2)
        delta_t = dist/(mod_u+3.0d0*DSQRT(pr/rho))
        delta_t = cfl*delta_t
        IF (min_delt .GT. delta_t) THEN
          min_delt = delta_t
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
      CALL PUSHINTEGER4(r - 1)
    END DO
    DO i=local_points,1,-1
      min_deltb = pointb%delta(i)
      pointb%delta(i) = 0.0_8
      CALL POPINTEGER4(ad_to)
      DO r=ad_to,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          delta_tb = 0.0_8
        ELSE
          delta_tb = min_deltb
          min_deltb = 0.0_8
        END IF
        delta_tb = cfl*delta_tb
        k = point%conn(i, r)
        pr = point%prim(4, k)
        rho = point%prim(1, k)
        temp = pr/rho
        temp0 = DSQRT(temp)
        tempb = delta_tb/(mod_u+3.0d0*temp0)
        distb = tempb
        tempb1 = -(dist*tempb/(mod_u+3.0d0*temp0))
        mod_ub = tempb1
        IF (temp .EQ. 0.0) THEN
          tempb0 = 0.0_8
        ELSE
          tempb0 = 3.0d0*tempb1/(rho*2.D0*DSQRT(temp))
        END IF
        prb = tempb0
        rhob = -(temp*tempb0)
        u1 = point%prim(2, k)
        u2 = point%prim(3, k)
        CALL POPREAL8(mod_u)
        IF (u1**2 + u2**2 .EQ. 0.0) THEN
          tempb0 = 0.0_8
        ELSE
          tempb0 = mod_ub/(2.D0*DSQRT(u1**2+u2**2))
        END IF
        u1b = 2*u1*tempb0
        u2b = 2*u2*tempb0
        y_i = point%y(i)
        y_k = point%y(k)
        x_i = point%x(i)
        x_k = point%x(k)
        CALL POPREAL8(dist)
        IF (dist .EQ. 0.0) THEN
          distb = 0.0_8
        ELSE
          distb = distb/(2.D0*DSQRT(dist))
        END IF
        CALL POPREAL8(dist)
        tempb = 2*(x_k-x_i)*distb
        tempb0 = 2*(y_k-y_i)*distb
        y_kb = tempb0
        y_ib = -tempb0
        x_kb = tempb
        x_ib = -tempb
        pointb%y(k) = pointb%y(k) + y_kb
        pointb%x(k) = pointb%x(k) + x_kb
        pointb%y(i) = pointb%y(i) + y_ib
        pointb%x(i) = pointb%x(i) + x_ib
        pointb%prim(4, k) = pointb%prim(4, k) + prb
        pointb%prim(3, k) = pointb%prim(3, k) + u2b
        pointb%prim(2, k) = pointb%prim(2, k) + u1b
        pointb%prim(1, k) = pointb%prim(1, k) + rhob
      END DO
    END DO
  END SUBROUTINE FUNC_DELTA_B

!	This subroutine computes the delta_t (local time step) at a given point ..
  SUBROUTINE FUNC_DELTA()
    IMPLICIT NONE
    INTEGER :: i, k, r
    REAL*8 :: delta_t
    REAL*8 :: min_dist
    REAL*8, SAVE :: lmin=1.0d0
    REAL*8 :: gmin
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: u1, u2, rho, pr, mod_u
    REAL*8 :: dist
    REAL*8 :: min_delt
    INTRINSIC DSQRT
    PetscErrorCode :: ierr
    DO i=1,local_points
      min_delt = 1.0d0
      DO r=1,point%nbhs(i)
        k = point%conn(i, r)
        rho = point%prim(1, k)
        u1 = point%prim(2, k)
        u2 = point%prim(3, k)
        pr = point%prim(4, k)
        x_i = point%x(i)
        y_i = point%y(i)
        x_k = point%x(k)
        y_k = point%y(k)
        dist = (x_k-x_i)*(x_k-x_i) + (y_k-y_i)*(y_k-y_i)
        dist = DSQRT(dist)
        mod_u = DSQRT(u1*u1 + u2*u2)
        delta_t = dist/(mod_u+3.0d0*DSQRT(pr/rho))
        delta_t = cfl*delta_t
        IF (min_delt .GT. delta_t) min_delt = delta_t
      END DO
      point%delta(i) = min_delt
    END DO
  END SUBROUTINE FUNC_DELTA

!  Differentiation of conserved_vector_ubar in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: prim nx ny ubar
!   with respect to varying inputs: prim nx ny ubar
  SUBROUTINE CONSERVED_VECTOR_UBAR_B(prim, primb, ubar, ubarb, nx, nxb, &
&   ny, nyb)
    IMPLICIT NONE
    REAL*8 :: u1_inf, u2_inf, u1_inf_rot, u2_inf_rot, e_inf
    REAL*8 :: u1_inf_rotb, u2_inf_rotb, e_infb
    REAL*8 :: u1, u2, pr, rho, u1_rot, u2_rot, e
    REAL*8 :: u1b, u2b, prb, rhob, u1_rotb, u2_rotb, eb
    REAL*8 :: beta, s2, b2_inf, a2n_inf
    REAL*8 :: betab, s2b, b2_infb, a2n_infb
    REAL*8 :: b2, a2p, temp1, temp2
    REAL*8 :: b2b, a2pb, temp1b, temp2b
    REAL*8 :: ubar(4), prim(4)
    REAL*8 :: ubarb(4), primb(4)
    REAL*8 :: nx, ny, tx, ty
    REAL*8 :: nxb, nyb, txb, tyb
    INTRINSIC DSQRT
    INTRINSIC DEXP
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    REAL*8 :: temp
    REAL*8 :: tempb
    REAL*8 :: tempb0
    u1_inf = q_inf(2)
    u2_inf = q_inf(3)
    tx = ny
    ty = -nx
    u1_inf_rot = u1_inf*tx + u2_inf*ty
    u2_inf_rot = u1_inf*nx + u2_inf*ny
    temp1 = u1_inf_rot*u1_inf_rot + u2_inf_rot*u2_inf_rot
    e_inf = pr_inf/(rho_inf*(gamma-1.0d0)) + 0.5d0*temp1
    beta = 0.5d0*rho_inf/pr_inf
    s2 = u2_inf_rot*DSQRT(beta)
    b2_inf = DEXP(-(s2*s2))/(2.0d0*DSQRT(pi*beta))
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2n_inf = 0.5d0*(1.0d0-result1)
    rho = prim(1)
    u1 = prim(2)
    u2 = prim(3)
    pr = prim(4)
    u1_rot = u1*tx + u2*ty
    u2_rot = u1*nx + u2*ny
    temp1 = u1_rot*u1_rot + u2_rot*u2_rot
    e = pr/(rho*(gamma-1.0d0)) + 0.5d0*temp1
    beta = rho/(2.0d0*pr)
    s2 = u2_rot*SQRT(beta)
    b2 = EXP(-(s2*s2))/(2.0d0*SQRT(pi*beta))
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2p = 0.5d0*(1.0d0+result1)
    temp1b = ubarb(4)
    temp2b = ubarb(4)
    ubarb(4) = 0.0_8
    a2pb = rho*e*temp2b
    eb = rho*a2p*temp2b
    tempb0 = b2*0.5d0*temp2b
    rhob = a2p*e*temp2b + u2_rot*tempb0
    b2b = rho*u2_rot*0.5d0*temp2b
    u2_rotb = rho*tempb0
    a2n_infb = e_inf*rho_inf*temp1b
    e_infb = a2n_inf*rho_inf*temp1b
    tempb0 = -(rho_inf*0.5d0*temp1b)
    u2_inf_rotb = b2_inf*tempb0
    b2_infb = u2_inf_rot*tempb0
    temp1b = ubarb(3)
    temp2b = ubarb(3)
    ubarb(3) = 0.0_8
    tempb0 = rho*temp2b
    u2_rotb = u2_rotb + a2p*tempb0
    a2pb = a2pb + u2_rot*tempb0 + rho*u1_rot*ubarb(2) + rho*ubarb(1)
    b2b = b2b + tempb0
    tempb0 = rho_inf*temp1b
    u2_inf_rotb = u2_inf_rotb + a2n_inf*tempb0
    a2n_infb = a2n_infb + u2_inf_rot*tempb0 + u1_inf_rot*rho_inf*ubarb(2&
&     ) + rho_inf*ubarb(1)
    b2_infb = b2_infb - tempb0
    result1b = 0.5d0*a2pb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.0_8
    ! CALL DERF_B(s2, s2b, result1b)
    s2b = s2b + (2.0d0/dsqrt(pi))*dexp(-s2**2)*result1b
    CALL POPREAL8(s2)
    temp = SQRT(pi*beta)
    tempb0 = b2b/(2.0d0*temp)
    s2b = s2b - 2*s2*EXP(-(s2**2))*tempb0
    IF (pi*beta .EQ. 0.0) THEN
      betab = 0.0_8
    ELSE
      betab = -(pi*EXP(-(s2**2))*tempb0/(2.0*temp**2))
    END IF
    temp = SQRT(beta)
    IF (.NOT.beta .EQ. 0.0) betab = betab + u2_rot*s2b/(2.0*temp)
    tempb = betab/(2.0d0*pr)
    rhob = rhob + (u2_rot*a2p+b2)*temp2b + u1_rot*a2p*ubarb(2) + a2p*&
&     ubarb(1) + tempb
    ubarb(1) = 0.0_8
    prb = -(rho*tempb/pr)
    tempb = eb/((gamma-1.0d0)*rho)
    temp1b = 0.5d0*eb
    u1_rotb = rho*a2p*ubarb(2) + 2*u1_rot*temp1b
    u2_rotb = u2_rotb + temp*s2b + 2*u2_rot*temp1b
    prb = prb + tempb
    rhob = rhob - pr*tempb/rho
    u1b = nx*u2_rotb + tx*u1_rotb
    u2b = ny*u2_rotb + ty*u1_rotb
    primb(4) = primb(4) + prb
    primb(3) = primb(3) + u2b
    primb(2) = primb(2) + u1b
    primb(1) = primb(1) + rhob
    result1b = -(0.5d0*a2n_infb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.0_8
    ! CALL DERF_B(s2, s2b, result1b)
    s2b = s2b + (2.0d0/dsqrt(pi))*dexp(-s2**2)*result1b
    CALL POPREAL8(s2)
    beta = 0.5d0*rho_inf/pr_inf
    s2b = s2b - 2*s2*DEXP(-(s2**2))*b2_infb/(2.0d0*DSQRT(pi*beta))
    temp1b = 0.5d0*e_infb
    u1_inf_rotb = a2n_inf*rho_inf*ubarb(2) + 2*u1_inf_rot*temp1b
    ubarb(2) = 0.0_8
    txb = u1*u1_rotb + u1_inf*u1_inf_rotb
    tyb = u2*u1_rotb + u2_inf*u1_inf_rotb
    u2_inf_rotb = u2_inf_rotb + DSQRT(beta)*s2b + 2*u2_inf_rot*temp1b
    nxb = nxb + u1*u2_rotb + u1_inf*u2_inf_rotb - tyb
    nyb = nyb + u2*u2_rotb + u2_inf*u2_inf_rotb + txb
  END SUBROUTINE CONSERVED_VECTOR_UBAR_B

  SUBROUTINE CONSERVED_VECTOR_UBAR(prim, ubar, nx, ny)
    IMPLICIT NONE
    REAL*8 :: u1_inf, u2_inf, u1_inf_rot, u2_inf_rot, e_inf
    REAL*8 :: u1, u2, pr, rho, u1_rot, u2_rot, e
    REAL*8 :: beta, s2, b2_inf, a2n_inf
    REAL*8 :: b2, a2p, temp1, temp2
    REAL*8 :: ubar(4), prim(4)
    REAL*8 :: nx, ny, tx, ty
    DOUBLE PRECISION :: result1
    u1_inf = q_inf(2)
    u2_inf = q_inf(3)
    tx = ny
    ty = -nx
    u1_inf_rot = u1_inf*tx + u2_inf*ty
    u2_inf_rot = u1_inf*nx + u2_inf*ny
    temp1 = u1_inf_rot*u1_inf_rot + u2_inf_rot*u2_inf_rot
    e_inf = pr_inf/(rho_inf*(gamma-1.0d0)) + 0.5d0*temp1
    beta = 0.5d0*rho_inf/pr_inf
    s2 = u2_inf_rot*DSQRT(beta)
    b2_inf = DEXP(-(s2*s2))/(2.0d0*DSQRT(pi*beta))
    result1 = DERF(s2)
    a2n_inf = 0.5d0*(1.0d0-result1)
    rho = prim(1)
    u1 = prim(2)
    u2 = prim(3)
    pr = prim(4)
    u1_rot = u1*tx + u2*ty
    u2_rot = u1*nx + u2*ny
    temp1 = u1_rot*u1_rot + u2_rot*u2_rot
    e = pr/(rho*(gamma-1.0d0)) + 0.5d0*temp1
    beta = rho/(2.0d0*pr)
    s2 = u2_rot*SQRT(beta)
    b2 = EXP(-(s2*s2))/(2.0d0*SQRT(pi*beta))
    result1 = DERF(s2)
    a2p = 0.5d0*(1.0d0+result1)
    ubar(1) = rho_inf*a2n_inf + rho*a2p
    ubar(2) = rho_inf*u1_inf_rot*a2n_inf + rho*u1_rot*a2p
    temp1 = rho_inf*(u2_inf_rot*a2n_inf-b2_inf)
    temp2 = rho*(u2_rot*a2p+b2)
    ubar(3) = temp1 + temp2
    temp1 = rho_inf*a2n_inf*e_inf - 0.5d0*rho_inf*u2_inf_rot*b2_inf
    temp2 = rho*a2p*e + 0.5d0*rho*u2_rot*b2
    ubar(4) = temp1 + temp2
  END SUBROUTINE CONSERVED_VECTOR_UBAR

END MODULE STATE_UPDATE_MOD_DIFF
