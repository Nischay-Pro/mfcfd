!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
MODULE POINT_NORMALS_MOD_DIFF
  USE DATA_STRUCTURE_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of compute_normals in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: point.x point.y point.nx point.ny
!   with respect to varying inputs: point.x point.y
  SUBROUTINE COMPUTE_NORMALS_B()
    IMPLICIT NONE
    DOUBLE PRECISION :: lx, ly, mx, my, rx, ry
    DOUBLE PRECISION :: lxb, lyb, mxb, myb, rxb, ryb
    DOUBLE PRECISION :: nx1, nx2, ny1, ny2, nx, ny
    DOUBLE PRECISION :: nx1b, nx2b, ny1b, ny2b, nxb, nyb
    DOUBLE PRECISION :: det
    DOUBLE PRECISION :: detb
    INTEGER :: i, j, k, l, m, r
    INTRINSIC DSQRT
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
!Finding the normals for the points on the shapes ..   
    DO i=1,wall_points
      CALL PUSHINTEGER4(m)
      m = wall_points_index(i)
      CALL PUSHINTEGER4(l)
      l = point%left(m)
      CALL PUSHINTEGER4(r)
      r = point%right(m)
      lx = point%x(l)
      ly = point%y(l)
      mx = point%x(m)
      my = point%y(m)
      rx = point%x(r)
      ry = point%y(r)
      nx1 = my - ly
      nx2 = ry - my
      ny1 = mx - lx
      ny2 = rx - mx
      CALL PUSHREAL8(nx)
      nx = 0.5d0*(nx1+nx2)
      CALL PUSHREAL8(ny)
      ny = 0.5d0*(ny1+ny2)
      CALL PUSHREAL8(det)
      det = DSQRT(nx*nx + ny*ny)
    END DO
!	Finding the normals for the outer boundary points ..
    DO i=1,outer_points
      CALL PUSHINTEGER4(m)
      m = outer_points_index(i)
      CALL PUSHINTEGER4(l)
      l = point%left(m)
      CALL PUSHINTEGER4(r)
      r = point%right(m)
      lx = point%x(l)
      ly = point%y(l)
      mx = point%x(m)
      my = point%y(m)
      rx = point%x(r)
      ry = point%y(r)
      nx1 = my - ly
      nx2 = ry - my
      ny1 = mx - lx
      ny2 = rx - mx
      CALL PUSHREAL8(nx)
      nx = 0.5d0*(nx1+nx2)
      CALL PUSHREAL8(ny)
      ny = 0.5d0*(ny1+ny2)
      CALL PUSHREAL8(det)
      det = DSQRT(nx*nx + ny*ny)
    END DO
!	Suppose the normals of the interior points are available
!	and we still want to do upwinding along the cartesian coordinates
!	then the following portion of the code ensures it ..
    IF (interior_points_normal_flag .EQ. 0) THEN
      DO i=interior_points,1,-1
        k = interior_points_index(i)
        pointb%ny(k) = 0.0_8
        pointb%nx(k) = 0.0_8
      END DO
    END IF
    DO i=interior_points,1,-1
      k = interior_points_index(i)
      pointb%ny(k) = 0.0_8
      pointb%nx(k) = 0.0_8
    END DO
    DO i=outer_points,1,-1
      nyb = pointb%ny(m)
      pointb%ny(m) = 0.0_8
      nxb = pointb%nx(m)
      pointb%nx(m) = 0.0_8
      detb = nx*nxb/det**2 - ny*nyb/det**2
      IF (nx**2 + ny**2 .EQ. 0.0) THEN
        tempb0 = 0.0
      ELSE
        tempb0 = detb/(2.D0*DSQRT(nx**2+ny**2))
      END IF
      nyb = 2*ny*tempb0 + nyb/det
      nxb = 2*nx*tempb0 - nxb/det
      CALL POPREAL8(det)
      CALL POPREAL8(ny)
      ny1b = 0.5d0*nyb
      ny2b = 0.5d0*nyb
      CALL POPREAL8(nx)
      nx1b = 0.5d0*nxb
      nx2b = 0.5d0*nxb
      rxb = ny2b
      mxb = ny1b - ny2b
      lxb = -ny1b
      ryb = nx2b
      myb = nx1b - nx2b
      lyb = -nx1b
      pointb%y(r) = pointb%y(r) + ryb
      pointb%x(r) = pointb%x(r) + rxb
      pointb%y(m) = pointb%y(m) + myb
      pointb%x(m) = pointb%x(m) + mxb
      pointb%y(l) = pointb%y(l) + lyb
      pointb%x(l) = pointb%x(l) + lxb
      CALL POPINTEGER4(r)
      CALL POPINTEGER4(l)
      CALL POPINTEGER4(m)
    END DO
    DO i=wall_points,1,-1
      nyb = pointb%ny(m)
      pointb%ny(m) = 0.0_8
      nxb = pointb%nx(m)
      pointb%nx(m) = 0.0_8
      detb = nx*nxb/det**2 - ny*nyb/det**2
      IF (nx**2 + ny**2 .EQ. 0.0) THEN
        tempb = 0.0
      ELSE
        tempb = detb/(2.D0*DSQRT(nx**2+ny**2))
      END IF
      nyb = 2*ny*tempb + nyb/det
      nxb = 2*nx*tempb - nxb/det
      CALL POPREAL8(det)
      CALL POPREAL8(ny)
      ny1b = 0.5d0*nyb
      ny2b = 0.5d0*nyb
      CALL POPREAL8(nx)
      nx1b = 0.5d0*nxb
      nx2b = 0.5d0*nxb
      rxb = ny2b
      mxb = ny1b - ny2b
      lxb = -ny1b
      ryb = nx2b
      myb = nx1b - nx2b
      lyb = -nx1b
      pointb%y(r) = pointb%y(r) + ryb
      pointb%x(r) = pointb%x(r) + rxb
      pointb%y(m) = pointb%y(m) + myb
      pointb%x(m) = pointb%x(m) + mxb
      pointb%y(l) = pointb%y(l) + lyb
      pointb%x(l) = pointb%x(l) + lxb
      CALL POPINTEGER4(r)
      CALL POPINTEGER4(l)
      CALL POPINTEGER4(m)
    END DO
  END SUBROUTINE COMPUTE_NORMALS_B

  SUBROUTINE COMPUTE_NORMALS()
    IMPLICIT NONE
    DOUBLE PRECISION :: lx, ly, mx, my, rx, ry
    DOUBLE PRECISION :: nx1, nx2, ny1, ny2, nx, ny
    DOUBLE PRECISION :: det
    INTEGER :: i, j, k, l, m, r
    INTRINSIC DSQRT
!Finding the normals for the points on the shapes ..   
    DO i=1,wall_points
      m = wall_points_index(i)
      l = point%left(m)
      r = point%right(m)
      lx = point%x(l)
      ly = point%y(l)
      mx = point%x(m)
      my = point%y(m)
      rx = point%x(r)
      ry = point%y(r)
      nx1 = my - ly
      nx2 = ry - my
      ny1 = mx - lx
      ny2 = rx - mx
      nx = 0.5d0*(nx1+nx2)
      ny = 0.5d0*(ny1+ny2)
      det = DSQRT(nx*nx + ny*ny)
      nx = -(nx/det)
      ny = ny/det
      point%nx(m) = nx
      point%ny(m) = ny
    END DO
!	Finding the normals for the outer boundary points ..
    DO i=1,outer_points
      m = outer_points_index(i)
      l = point%left(m)
      r = point%right(m)
      lx = point%x(l)
      ly = point%y(l)
      mx = point%x(m)
      my = point%y(m)
      rx = point%x(r)
      ry = point%y(r)
      nx1 = my - ly
      nx2 = ry - my
      ny1 = mx - lx
      ny2 = rx - mx
      nx = 0.5d0*(nx1+nx2)
      ny = 0.5d0*(ny1+ny2)
      det = DSQRT(nx*nx + ny*ny)
      nx = -(nx/det)
      ny = ny/det
      point%nx(m) = nx
      point%ny(m) = ny
    END DO
!	The below lines of code are temporary. In future
!	when we want the normals of the interior points
!	to be taken into account then we need to evaluate 
!	the normals here ..
!
    DO i=1,interior_points
      k = interior_points_index(i)
      point%nx(k) = 0.0d0
      point%ny(k) = 1.0d0
    END DO
!	Suppose the normals of the interior points are available
!	and we still want to do upwinding along the cartesian coordinates
!	then the following portion of the code ensures it ..
    IF (interior_points_normal_flag .EQ. 0) THEN
      DO i=1,interior_points
        k = interior_points_index(i)
        point%nx(k) = 0.d0
        point%ny(k) = 1.d0
      END DO
    END IF
  END SUBROUTINE COMPUTE_NORMALS

END MODULE POINT_NORMALS_MOD_DIFF

