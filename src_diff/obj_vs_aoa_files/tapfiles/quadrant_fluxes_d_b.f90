!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
MODULE QUADRANT_FLUXES_MOD_DIFF_DIFF
!	This module consists of quadrant split fluxes 
!	with respect to the x-coordinate direction ..
  USE PARAMETER_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of flux_quad_gxi_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: g nx ny gd
!   with respect to varying inputs: g nx ny u1d rhod prd u1 u2
!                pr u2d rho gd
!  Differentiation of flux_quad_gxi in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: g u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXI_D_B(g, gb, gd, gdb, nx, nxb, ny, nyb, u1, u1b&
&   , u1d, u1db, u2, u2b, u2d, u2db, rho, rhob, rhod, rhodb, pr, prb, &
&   prd, prdb)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: gdb(4), u1db, u2db, rhodb, prdb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: utdb, undb
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betab
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: betadb
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1b, b1b, s2b, b2b
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: s1db, b1db, s2db, b2db
    DOUBLE PRECISION :: a1neg, a2neg
    DOUBLE PRECISION :: a1negb, a2negb
    DOUBLE PRECISION :: a1negd, a2negd
    DOUBLE PRECISION :: a1negdb, a2negdb
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: temp1db, temp2db, temp3db, temp4db
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: pr_by_rhodb, u_sqrdb
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: result1db
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: DERF
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: tempb2
    DOUBLE PRECISION :: temp5
    REAL*8 :: tempb3
    DOUBLE PRECISION :: temp6
    DOUBLE PRECISION :: temp7
    DOUBLE PRECISION :: temp8
    DOUBLE PRECISION :: tempb4
    DOUBLE PRECISION :: tempb5
    DOUBLE PRECISION :: tempb6
    DOUBLE PRECISION :: tempb7
    DOUBLE PRECISION :: temp9
    REAL*8 :: tempb8
    DOUBLE PRECISION :: temp10
    DOUBLE PRECISION :: temp11
    DOUBLE PRECISION :: temp12
    REAL*8 :: temp13
    REAL*8 :: temp14
    DOUBLE PRECISION :: tempb9
    DOUBLE PRECISION :: tempb10
    DOUBLE PRECISION :: tempb11
    DOUBLE PRECISION :: tempb12
    DOUBLE PRECISION :: tempb13
    DOUBLE PRECISION :: tempb14
    DOUBLE PRECISION :: tempb15
    DOUBLE PRECISION :: tempb16
    DOUBLE PRECISION :: tempb17
    DOUBLE PRECISION :: tempb18
    DOUBLE PRECISION :: tempb19
    DOUBLE PRECISION :: tempb20
    DOUBLE PRECISION :: tempb21
    DOUBLE PRECISION :: tempb22
    DOUBLE PRECISION :: tempb23
    DOUBLE PRECISION :: tempb24
    DOUBLE PRECISION :: tempb25
    DOUBLE PRECISION :: tempb26
    DOUBLE PRECISION :: tempb27
    DOUBLE PRECISION :: tempb28
    DOUBLE PRECISION :: tempb29
    DOUBLE PRECISION :: tempb30
    DOUBLE PRECISION :: tempb31
    DOUBLE PRECISION :: tempb32
    DOUBLE PRECISION :: tempb33
    DOUBLE PRECISION :: tempb34
    DOUBLE PRECISION :: tempb35
    DOUBLE PRECISION :: tempb36
    INTEGER :: branch
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      CALL PUSHCONTROL1B(0)
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
      CALL PUSHCONTROL1B(1)
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    IF (beta .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = betad/(2.d0*DSQRT(beta))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = arg1d/(2.d0*DSQRT(arg1))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = arg1d/(2.d0*DSQRT(arg1))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!result1d = DERF_D(s1, s1d, result1)
    CALL PUSHREAL8(result1d)
    result1d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    CALL PUSHREAL8(result1)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1negd = -(0.5d0*result1d)
    a1neg = 0.5d0*(1.0d0-result1)
!result1d = DERF_D(s2, s2d, result1)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2negd = -(0.5d0*result1d)
    a2neg = 0.5d0*(1.0d0-result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1neg+ut*temp1*a1negd)
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(b1d*temp1+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
    temp1d = utd*a1neg + ut*a1negd - b1d
    temp1 = ut*a1neg - b1
    tempb11 = (rhod*a2neg+rho*a2negd)*gdb(4)
    tempb10 = (temp2-temp3)*gdb(4)
    tempb9 = rho*a2neg*gb(4)
    rhob = a2negd*tempb10 + (temp2d-temp3d)*a2neg*gdb(4) + (temp2-temp3)&
&     *a2neg*gb(4)
    a2negb = rhod*tempb10 + (temp2d-temp3d)*rho*gdb(4) + (temp2-temp3)*&
&     rho*gb(4)
    temp2b = tempb11 + tempb9
    temp3b = -tempb11 - tempb9
    temp4b = -gb(4)
    gb(4) = 0.D0
    tempb12 = rho*a2neg*gdb(4)
    temp2db = tempb12
    temp3db = -tempb12
    temp4db = -gdb(4)
    gdb(4) = 0.D0
    tempb15 = 0.5d0*b2*temp1*temp4b
    tempb16 = 0.5d0*rho*un*temp4b
    tempb20 = 0.5d0*temp4db
    tempb13 = b2*temp1*tempb20
    tempb18 = (rhod*un+rho*und)*tempb20
    tempb17 = (b2d*temp1+b2*temp1d)*tempb20
    tempb19 = rho*un*tempb20
    b2b = temp1*tempb18 + temp1d*tempb19 + temp1*tempb16
    temp1b = b2*tempb18 + b2d*tempb19 + b2*tempb16
    b2db = temp1*tempb19
    temp1db = b2*tempb19
    utb = a1negd*temp1db + a1neg*temp1b
    temp1 = 6.0d0*pr_by_rho + u_sqr
    utdb = a1neg*temp1db
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    tempb22 = 0.5d0*temp3db
    b1b = 0.5d0*temp1*temp3b + temp1d*tempb22 - temp1b
    b1db = temp1*tempb22 - temp1db
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    tempb23 = 0.5d0*a1neg*temp2b
    tempb21 = 0.5d0*temp2db
    a1negb = utd*temp1db + (utd*temp1+ut*temp1d)*tempb21 + 0.5d0*ut*&
&     temp1*temp2b + ut*temp1b
    a1negdb = ut*temp1*tempb21 + ut*temp1db
    temp1b = b1d*tempb22 + 0.5d0*b1*temp3b
    temp1db = b1*tempb22
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    pr_by_rhodb = 6.0d0*temp1db
    u_sqrdb = temp1db
    tempb24 = a1neg*tempb21
    temp1b = utd*tempb24 + a1negd*ut*tempb21 + ut*tempb23
    temp1db = ut*tempb24
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    pr_by_rhodb = pr_by_rhodb + 7.0d0*temp1db
    u_sqrdb = u_sqrdb + temp1db
    temp2 = un*a2neg - b2
    temp2d = und*a2neg + un*a2negd - b2d
    tempb14 = temp2*gdb(3)
    temp1b = rhod*tempb14 + temp2d*rho*gdb(3) + temp2*rho*gb(3)
    temp1db = rho*tempb14
    utb = utb + temp1d*tempb24 + a1negd*temp1*tempb21 + a1negd*temp1db +&
&     a1neg*temp1b + temp1*tempb23
    utdb = utdb + a1neg*temp1db + temp1*tempb24
    temp1 = ut*a1neg - b1
    rhodb = un*tempb13 + temp1*tempb14 + a2neg*tempb10
    temp1d = utd*a1neg + ut*a1negd - b1d
    rhob = rhob + und*tempb13 + un*tempb17 + temp1d*tempb14 + temp2d*&
&     temp1*gdb(3) + temp2*temp1*gb(3) + un*tempb15
    temp2b = (rhod*temp1+rho*temp1d)*gdb(3) + rho*temp1*gb(3)
    gb(3) = 0.D0
    temp2db = rho*temp1*gdb(3)
    a2negdb = un*temp2db + rho*tempb10
    unb = rhod*tempb13 + rho*tempb17 + a2negd*temp2db + 2*und*u_sqrdb + &
&     2*un*u_sqrb + a2neg*temp2b + rho*tempb15
    undb = a2neg*temp2db + 2*un*u_sqrdb + rho*tempb13
    gdb(3) = 0.D0
    b2b = b2b - temp2b
    b2db = b2db - temp2db
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp2d = temp1d*a1neg + temp1*a1negd - utd*b1 - ut*b1d
    tempb25 = temp2*gdb(2)
    a2negb = a2negb + und*temp2db + rhod*tempb25 + temp2d*rho*gdb(2) + &
&     temp2*rho*gb(2) + un*temp2b
    rhob = rhob + a2negd*tempb25 + temp2d*a2neg*gdb(2) + temp2*a2neg*gb(&
&     2)
    temp2b = (rhod*a2neg+rho*a2negd)*gdb(2) + rho*a2neg*gb(2)
    gb(2) = 0.D0
    temp2db = rho*a2neg*gdb(2)
    gdb(2) = 0.D0
    tempb31 = (ut*a1neg-b1)*gb(1)
    tempb28 = rho*a2neg*gb(1)
    gb(1) = 0.D0
    tempb29 = (ut*a1neg-b1)*gdb(1)
    a2negdb = a2negdb + rho*tempb29 + rho*tempb25
    tempb26 = (rhod*a2neg+rho*a2negd)*gdb(1)
    b1b = b1b - ut*temp2b - tempb28 - tempb26 - utd*temp2db - temp1b
    tempb32 = (utd*a1neg+ut*a1negd-b1d)*gdb(1)
    a2negb = a2negb + rhod*tempb29 + rho*tempb32 + rho*tempb31
    tempb27 = rho*a2neg*gdb(1)
    a1negb = a1negb + utd*temp1db + temp1d*temp2db + ut*tempb26 + utd*&
&     tempb27 + ut*tempb28 + temp1*temp2b + ut*temp1b
    a1negdb = a1negdb + temp1*temp2db + ut*tempb27 + ut*temp1db
    b1db = b1db - ut*temp2db - tempb27 - temp1db
    temp1b = a1negd*temp2db + a1neg*temp2b
    temp1db = a1neg*temp2db
    utb = utb + 2*utd*temp1db - b1d*temp2db + a1neg*tempb26 + a1negd*&
&     tempb27 + 2*utd*u_sqrdb + 2*ut*u_sqrb + a1neg*tempb28 + 2*ut*&
&     temp1b - b1*temp2b
    utdb = utdb + 2*ut*temp1db + 2*ut*u_sqrdb + a1neg*tempb27 - b1*&
&     temp2db
    pr_by_rhob = pr_by_rhob + temp1b
    pr_by_rhodb = pr_by_rhodb + temp1db
    gdb(1) = 0.D0
    tempb30 = pr_by_rhodb/rho**2
    rhodb = rhodb + a2neg*tempb29 - pr*tempb30 + a2neg*tempb25
    rhob = rhob + a2negd*tempb29 + a2neg*tempb32 + (prd-(prd*rho-pr*rhod&
&     )*2/rho)*tempb30 - pr*pr_by_rhob/rho**2 + a2neg*tempb31
    prb = pr_by_rhob/rho - rhod*tempb30
    prdb = rho*tempb30
    result1b = -(0.5d0*a2negb)
    result1db = -(0.5d0*a2negdb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0
    CALL DERF_B(s2, s2b, result1b)
    CALL POPREAL8(s2)
    temp14 = SQRT(pi)
    result1b = -(0.5d0*a1negb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL POPREAL8(result1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0
    CALL DERF_B(s1, s1b, result1b)
    CALL POPREAL8(s1)
    CALL POPREAL8(result1)
    CALL POPREAL8(result1d)
    temp13 = SQRT(pi)
    tempb33 = 0.5d0*b2b/result1
    tempb34 = b2db/result1**2
    temp12 = DEXP(-(s2**2))
    temp10 = s2d*s2 + s2*s2d
    tempb36 = -(0.5d0*temp12*tempb34)
    tempb35 = result1*tempb36
    s2b = s2b + (DEXP(-(s2**2))*result1d*0.5d0*2*s2+DEXP(-(s2**2))*&
&     temp10*result1*0.5d0*2*s2)*tempb34 - DEXP(-(s2**2))*2*s2*tempb33 +&
&     2*s2d*tempb35 - DEXP(-(s2**2))*s2d*2.d0*2*s2*result1db/temp14
    s2db = 2*s2*tempb35 + DEXP(-(s2**2))*2.d0*result1db/temp14
    result1db = -(0.5d0*a1negdb)
    s1b = s1b - DEXP(-(s1**2))*s1d*2.d0*2*s1*result1db/temp13
    s1db = DEXP(-(s1**2))*2.d0*result1db/temp13
    temp11 = DEXP(-(s2**2))
    result1b = temp10*tempb36 - (-(0.5d0*(temp10*result1*temp12))-0.5d0*&
&     (temp11*result1d))*2*tempb34/result1 - DEXP(-(s2**2))*tempb33/&
&     result1
    result1db = -(0.5d0*temp11*tempb34)
    CALL POPREAL8(result1)
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.D0*DSQRT(arg1))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
      arg1db = 0.0_8
    ELSE
      CALL POPREAL8(result1d)
      temp9 = DSQRT(arg1)
      tempb8 = result1db/(2.d0*temp9)
      arg1db = tempb8
      IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb8/(temp9*2.D0*&
&         DSQRT(arg1))
    END IF
    temp7 = DEXP(-(s1**2))
    tempb6 = b1db/result1**2
    temp8 = DEXP(-(s1**2))
    temp6 = s1d*s1 + s1*s1d
    tempb7 = -(0.5d0*temp8*tempb6)
    tempb5 = result1*tempb7
    betab = pi*arg1b
    betadb = pi*arg1db
    tempb4 = 0.5d0*b1b/result1
    s1b = s1b + 2*s1d*tempb5 + (DEXP(-(s1**2))*result1d*0.5d0*2*s1+DEXP(&
&     -(s1**2))*temp6*result1*0.5d0*2*s1)*tempb6 - DEXP(-(s1**2))*2*s1*&
&     tempb4
    result1b = temp6*tempb7 - (-(0.5d0*(temp6*result1*temp8))-0.5d0*(&
&     temp7*result1d))*2*tempb6/result1 - DEXP(-(s1**2))*tempb4/result1
    s1db = s1db + 2*s1*tempb5
    result1db = -(0.5d0*temp7*tempb6)
    arg1 = pi*beta
    CALL POPREAL8(result1)
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.D0*DSQRT(arg1))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
      arg1db = 0.0_8
    ELSE
      arg1d = pi*betad
      CALL POPREAL8(result1d)
      temp5 = DSQRT(arg1)
      tempb3 = result1db/(2.d0*temp5)
      arg1db = tempb3
      IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb3/(temp5*2.D0*&
&         DSQRT(arg1))
    END IF
    result1b = und*s2db + un*s2b
    IF (beta .EQ. 0.0) THEN
      betab = betab + pi*arg1b
    ELSE
      betab = betab + result1b/(2.D0*DSQRT(beta)) + pi*arg1b
    END IF
    betadb = betadb + pi*arg1db
    unb = unb + result1d*s2db + result1*s2b
    undb = undb + result1*s2db
    result1db = un*s2db
    CALL POPREAL8(result1)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
    ELSE
      CALL POPREAL8(result1d)
      temp0 = DSQRT(beta)
      tempb2 = result1db/(2.d0*temp0)
      betadb = betadb + tempb2
      IF (.NOT.beta .EQ. 0.0) betab = betab - betad*tempb2/(temp0*2.D0*&
&         DSQRT(beta))
    END IF
    utb = utb + result1d*s1db + result1*s1b
    result1b = utd*s1db + ut*s1b
    utdb = utdb + result1*s1db
    result1db = ut*s1db
    IF (.NOT.beta .EQ. 0.0) betab = betab + result1b/(2.D0*DSQRT(beta))
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      temp = DSQRT(beta)
      tempb1 = result1db/(2.d0*temp)
      betadb = betadb + tempb1
      IF (.NOT.beta .EQ. 0.0) betab = betab - betad*tempb1/(temp*2.D0*&
&         DSQRT(beta))
    END IF
    tyb = u2d*utdb + u2*utb
    txb = u1d*utdb + u1*utb
    tempb0 = betadb/pr**2
    tempb = 0.5d0*betab/pr
    rhob = rhob + tempb - 0.5d0*prd*tempb0
    prb = prb + (0.5d0*rhod-(0.5d0*(rhod*pr)-0.5d0*(rho*prd))*2/pr)*&
&     tempb0 - rho*tempb/pr
    rhodb = rhodb + 0.5d0*pr*tempb0
    prdb = prdb - 0.5d0*rho*tempb0
    u1b = tx*utb + nx*unb
    nxb = nxb + u1d*undb - tyb + u1*unb
    u2b = ty*utb + ny*unb
    nyb = nyb + u2d*undb + txb + u2*unb
    u1db = tx*utdb + nx*undb
    u2db = ty*utdb + ny*undb
  END SUBROUTINE FLUX_QUAD_GXI_D_B

!  Differentiation of flux_quad_gxi in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: g u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXI_D(g, gd, nx, ny, u1, u1d, u2, u2d, rho, rhod&
&   , pr, prd)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: a1neg, a2neg
    DOUBLE PRECISION :: a1negd, a2negd
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    IF (beta .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!result1d = DERF_D(s1, s1d, result1)
    result1d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    result1 = DERF(s1)
    a1negd = -(0.5d0*result1d)
    a1neg = 0.5d0*(1.0d0-result1)
!result1d = DERF_D(s2, s2d, result1)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    result1 = DERF(s2)
    a2negd = -(0.5d0*result1d)
    a2neg = 0.5d0*(1.0d0-result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    gd(1) = (rhod*a2neg+rho*a2negd)*(ut*a1neg-b1) + rho*a2neg*(utd*a1neg&
&     +ut*a1negd-b1d)
    g(1) = rho*a2neg*(ut*a1neg-b1)
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp1 = pr_by_rho + ut*ut
    temp2d = temp1d*a1neg + temp1*a1negd - utd*b1 - ut*b1d
    temp2 = temp1*a1neg - ut*b1
    gd(2) = (rhod*a2neg+rho*a2negd)*temp2 + rho*a2neg*temp2d
    g(2) = rho*a2neg*temp2
    temp1d = utd*a1neg + ut*a1negd - b1d
    temp1 = ut*a1neg - b1
    temp2d = und*a2neg + un*a2negd - b2d
    temp2 = un*a2neg - b2
    gd(3) = (rhod*temp1+rho*temp1d)*temp2 + rho*temp1*temp2d
    g(3) = rho*temp1*temp2
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1neg+ut*temp1*a1negd)
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(b1d*temp1+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
    temp1d = utd*a1neg + ut*a1negd - b1d
    temp1 = ut*a1neg - b1
    temp4d = 0.5d0*((rhod*un+rho*und)*b2*temp1+rho*un*(b2d*temp1+b2*&
&     temp1d))
    temp4 = 0.5d0*rho*un*b2*temp1
    gd(4) = (rhod*a2neg+rho*a2negd)*(temp2-temp3) + rho*a2neg*(temp2d-&
&     temp3d) - temp4d
    g(4) = rho*a2neg*(temp2-temp3) - temp4
  END SUBROUTINE FLUX_QUAD_GXI_D

  SUBROUTINE FLUX_QUAD_GXI(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1neg, a2neg
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    result1 = DSQRT(beta)
    s1 = ut*result1
    result1 = DSQRT(beta)
    s2 = un*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.0d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    g(1) = rho*a2neg*(ut*a1neg-b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    g(2) = rho*a2neg*temp2
    temp1 = ut*a1neg - b1
    temp2 = un*a2neg - b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1neg - b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2neg*(temp2-temp3) - temp4
  END SUBROUTINE FLUX_QUAD_GXI

!  Differentiation of flux_quad_gxii_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: g nx ny gd
!   with respect to varying inputs: g nx ny u1d rhod prd u1 u2
!                pr u2d rho gd
!  Differentiation of flux_quad_gxii in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: g u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXII_D_B(g, gb, gd, gdb, nx, nxb, ny, nyb, u1, &
&   u1b, u1d, u1db, u2, u2b, u2d, u2db, rho, rhob, rhod, rhodb, pr, prb&
&   , prd, prdb)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: gdb(4), u1db, u2db, rhodb, prdb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: utdb, undb
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betab
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: betadb
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1b, b1b, s2b, b2b
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: s1db, b1db, s2db, b2db
    DOUBLE PRECISION :: a1pos, a2neg
    DOUBLE PRECISION :: a1posb, a2negb
    DOUBLE PRECISION :: a1posd, a2negd
    DOUBLE PRECISION :: a1posdb, a2negdb
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: temp1db, temp2db, temp3db, temp4db
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: pr_by_rhodb, u_sqrdb
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: result1db
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: DERF
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: tempb2
    DOUBLE PRECISION :: temp5
    REAL*8 :: tempb3
    DOUBLE PRECISION :: temp6
    DOUBLE PRECISION :: temp7
    DOUBLE PRECISION :: temp8
    DOUBLE PRECISION :: tempb4
    DOUBLE PRECISION :: tempb5
    DOUBLE PRECISION :: tempb6
    DOUBLE PRECISION :: tempb7
    DOUBLE PRECISION :: temp9
    REAL*8 :: tempb8
    DOUBLE PRECISION :: temp10
    DOUBLE PRECISION :: temp11
    DOUBLE PRECISION :: temp12
    REAL*8 :: temp13
    REAL*8 :: temp14
    DOUBLE PRECISION :: tempb9
    DOUBLE PRECISION :: tempb10
    DOUBLE PRECISION :: tempb11
    DOUBLE PRECISION :: tempb12
    DOUBLE PRECISION :: tempb13
    DOUBLE PRECISION :: tempb14
    DOUBLE PRECISION :: tempb15
    DOUBLE PRECISION :: tempb16
    DOUBLE PRECISION :: tempb17
    DOUBLE PRECISION :: tempb18
    DOUBLE PRECISION :: tempb19
    DOUBLE PRECISION :: tempb20
    DOUBLE PRECISION :: tempb21
    DOUBLE PRECISION :: tempb22
    DOUBLE PRECISION :: tempb23
    DOUBLE PRECISION :: tempb24
    DOUBLE PRECISION :: tempb25
    DOUBLE PRECISION :: tempb26
    DOUBLE PRECISION :: tempb27
    DOUBLE PRECISION :: tempb28
    DOUBLE PRECISION :: tempb29
    DOUBLE PRECISION :: tempb30
    DOUBLE PRECISION :: tempb31
    DOUBLE PRECISION :: tempb32
    DOUBLE PRECISION :: tempb33
    DOUBLE PRECISION :: tempb34
    DOUBLE PRECISION :: tempb35
    DOUBLE PRECISION :: tempb36
    INTEGER :: branch
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      CALL PUSHCONTROL1B(0)
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
      CALL PUSHCONTROL1B(1)
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    IF (beta .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = betad/(2.d0*DSQRT(beta))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = arg1d/(2.d0*DSQRT(arg1))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = arg1d/(2.d0*DSQRT(arg1))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!result1d = DERF_D(s1, s1d, result1)
    CALL PUSHREAL8(result1d)
    result1d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    CALL PUSHREAL8(result1)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1posd = 0.5d0*result1d
    a1pos = 0.5d0*(1.d0+result1)
!result1d = DERF_D(s2, s2d, result1)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2negd = -(0.5d0*result1d)
    a2neg = 0.5d0*(1.d0-result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1pos+ut*temp1*a1posd)
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(b1d*temp1+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
    temp1d = utd*a1pos + ut*a1posd + b1d
    temp1 = ut*a1pos + b1
    tempb11 = (rhod*a2neg+rho*a2negd)*gdb(4)
    tempb10 = (temp2+temp3)*gdb(4)
    tempb9 = rho*a2neg*gb(4)
    rhob = a2negd*tempb10 + (temp2d+temp3d)*a2neg*gdb(4) + (temp2+temp3)&
&     *a2neg*gb(4)
    a2negb = rhod*tempb10 + (temp2d+temp3d)*rho*gdb(4) + (temp2+temp3)*&
&     rho*gb(4)
    temp2b = tempb11 + tempb9
    temp3b = tempb11 + tempb9
    temp4b = -gb(4)
    gb(4) = 0.D0
    tempb12 = rho*a2neg*gdb(4)
    temp2db = tempb12
    temp3db = tempb12
    temp4db = -gdb(4)
    gdb(4) = 0.D0
    tempb15 = 0.5d0*b2*temp1*temp4b
    tempb16 = 0.5d0*rho*un*temp4b
    tempb20 = 0.5d0*temp4db
    tempb13 = b2*temp1*tempb20
    tempb18 = (rhod*un+rho*und)*tempb20
    tempb17 = (b2d*temp1+b2*temp1d)*tempb20
    tempb19 = rho*un*tempb20
    b2b = temp1*tempb18 + temp1d*tempb19 + temp1*tempb16
    temp1b = b2*tempb18 + b2d*tempb19 + b2*tempb16
    b2db = temp1*tempb19
    temp1db = b2*tempb19
    utb = a1posd*temp1db + a1pos*temp1b
    temp1 = 6.0d0*pr_by_rho + u_sqr
    utdb = a1pos*temp1db
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    tempb22 = 0.5d0*temp3db
    b1b = 0.5d0*temp1*temp3b + temp1d*tempb22 + temp1b
    b1db = temp1*tempb22 + temp1db
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    tempb23 = 0.5d0*a1pos*temp2b
    tempb21 = 0.5d0*temp2db
    a1posb = utd*temp1db + (utd*temp1+ut*temp1d)*tempb21 + 0.5d0*ut*&
&     temp1*temp2b + ut*temp1b
    a1posdb = ut*temp1*tempb21 + ut*temp1db
    temp1b = b1d*tempb22 + 0.5d0*b1*temp3b
    temp1db = b1*tempb22
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    pr_by_rhodb = 6.0d0*temp1db
    u_sqrdb = temp1db
    tempb24 = a1pos*tempb21
    temp1b = utd*tempb24 + a1posd*ut*tempb21 + ut*tempb23
    temp1db = ut*tempb24
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    pr_by_rhodb = pr_by_rhodb + 7.0d0*temp1db
    u_sqrdb = u_sqrdb + temp1db
    temp2 = un*a2neg - b2
    temp2d = und*a2neg + un*a2negd - b2d
    tempb14 = temp2*gdb(3)
    temp1b = rhod*tempb14 + temp2d*rho*gdb(3) + temp2*rho*gb(3)
    temp1db = rho*tempb14
    utb = utb + temp1d*tempb24 + a1posd*temp1*tempb21 + a1posd*temp1db +&
&     a1pos*temp1b + temp1*tempb23
    utdb = utdb + a1pos*temp1db + temp1*tempb24
    temp1 = ut*a1pos + b1
    rhodb = un*tempb13 + temp1*tempb14 + a2neg*tempb10
    temp1d = utd*a1pos + ut*a1posd + b1d
    rhob = rhob + und*tempb13 + un*tempb17 + temp1d*tempb14 + temp2d*&
&     temp1*gdb(3) + temp2*temp1*gb(3) + un*tempb15
    temp2b = (rhod*temp1+rho*temp1d)*gdb(3) + rho*temp1*gb(3)
    gb(3) = 0.D0
    temp2db = rho*temp1*gdb(3)
    a2negdb = un*temp2db + rho*tempb10
    unb = rhod*tempb13 + rho*tempb17 + a2negd*temp2db + 2*und*u_sqrdb + &
&     2*un*u_sqrb + a2neg*temp2b + rho*tempb15
    undb = a2neg*temp2db + 2*un*u_sqrdb + rho*tempb13
    gdb(3) = 0.D0
    b2b = b2b - temp2b
    b2db = b2db - temp2db
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp2d = temp1d*a1pos + temp1*a1posd + utd*b1 + ut*b1d
    tempb25 = temp2*gdb(2)
    a2negb = a2negb + und*temp2db + rhod*tempb25 + temp2d*rho*gdb(2) + &
&     temp2*rho*gb(2) + un*temp2b
    rhob = rhob + a2negd*tempb25 + temp2d*a2neg*gdb(2) + temp2*a2neg*gb(&
&     2)
    temp2b = (rhod*a2neg+rho*a2negd)*gdb(2) + rho*a2neg*gb(2)
    gb(2) = 0.D0
    temp2db = rho*a2neg*gdb(2)
    gdb(2) = 0.D0
    tempb31 = (ut*a1pos+b1)*gb(1)
    tempb28 = rho*a2neg*gb(1)
    gb(1) = 0.D0
    tempb29 = (ut*a1pos+b1)*gdb(1)
    a2negdb = a2negdb + rho*tempb29 + rho*tempb25
    tempb26 = (rhod*a2neg+rho*a2negd)*gdb(1)
    b1b = b1b + ut*temp2b + tempb28 + tempb26 + utd*temp2db + temp1b
    tempb32 = (utd*a1pos+ut*a1posd+b1d)*gdb(1)
    a2negb = a2negb + rhod*tempb29 + rho*tempb32 + rho*tempb31
    tempb27 = rho*a2neg*gdb(1)
    a1posb = a1posb + utd*temp1db + temp1d*temp2db + ut*tempb26 + utd*&
&     tempb27 + ut*tempb28 + temp1*temp2b + ut*temp1b
    a1posdb = a1posdb + temp1*temp2db + ut*tempb27 + ut*temp1db
    b1db = b1db + ut*temp2db + tempb27 + temp1db
    temp1b = a1posd*temp2db + a1pos*temp2b
    temp1db = a1pos*temp2db
    utb = utb + b1d*temp2db + 2*utd*temp1db + a1pos*tempb26 + a1posd*&
&     tempb27 + 2*utd*u_sqrdb + 2*ut*u_sqrb + a1pos*tempb28 + 2*ut*&
&     temp1b + b1*temp2b
    utdb = utdb + 2*ut*temp1db + 2*ut*u_sqrdb + a1pos*tempb27 + b1*&
&     temp2db
    pr_by_rhob = pr_by_rhob + temp1b
    pr_by_rhodb = pr_by_rhodb + temp1db
    gdb(1) = 0.D0
    tempb30 = pr_by_rhodb/rho**2
    rhodb = rhodb + a2neg*tempb29 - pr*tempb30 + a2neg*tempb25
    rhob = rhob + a2negd*tempb29 + a2neg*tempb32 + (prd-(prd*rho-pr*rhod&
&     )*2/rho)*tempb30 - pr*pr_by_rhob/rho**2 + a2neg*tempb31
    prb = pr_by_rhob/rho - rhod*tempb30
    prdb = rho*tempb30
    result1b = -(0.5d0*a2negb)
    result1db = -(0.5d0*a2negdb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0
    CALL DERF_B(s2, s2b, result1b)
    CALL POPREAL8(s2)
    temp14 = SQRT(pi)
    result1b = 0.5d0*a1posb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL POPREAL8(result1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0
    CALL DERF_B(s1, s1b, result1b)
    CALL POPREAL8(s1)
    CALL POPREAL8(result1)
    CALL POPREAL8(result1d)
    temp13 = SQRT(pi)
    tempb33 = 0.5d0*b2b/result1
    tempb34 = b2db/result1**2
    temp12 = DEXP(-(s2**2))
    temp10 = s2d*s2 + s2*s2d
    tempb36 = -(0.5d0*temp12*tempb34)
    tempb35 = result1*tempb36
    s2b = s2b + (DEXP(-(s2**2))*result1d*0.5d0*2*s2+DEXP(-(s2**2))*&
&     temp10*result1*0.5d0*2*s2)*tempb34 - DEXP(-(s2**2))*2*s2*tempb33 +&
&     2*s2d*tempb35 - DEXP(-(s2**2))*s2d*2.d0*2*s2*result1db/temp14
    s2db = 2*s2*tempb35 + DEXP(-(s2**2))*2.d0*result1db/temp14
    result1db = 0.5d0*a1posdb
    s1b = s1b - DEXP(-(s1**2))*s1d*2.d0*2*s1*result1db/temp13
    s1db = DEXP(-(s1**2))*2.d0*result1db/temp13
    temp11 = DEXP(-(s2**2))
    result1b = temp10*tempb36 - (-(0.5d0*(temp10*result1*temp12))-0.5d0*&
&     (temp11*result1d))*2*tempb34/result1 - DEXP(-(s2**2))*tempb33/&
&     result1
    result1db = -(0.5d0*temp11*tempb34)
    CALL POPREAL8(result1)
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.D0*DSQRT(arg1))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
      arg1db = 0.0_8
    ELSE
      CALL POPREAL8(result1d)
      temp9 = DSQRT(arg1)
      tempb8 = result1db/(2.d0*temp9)
      arg1db = tempb8
      IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb8/(temp9*2.D0*&
&         DSQRT(arg1))
    END IF
    temp7 = DEXP(-(s1**2))
    tempb6 = b1db/result1**2
    temp8 = DEXP(-(s1**2))
    temp6 = s1d*s1 + s1*s1d
    tempb7 = -(0.5d0*temp8*tempb6)
    tempb5 = result1*tempb7
    betab = pi*arg1b
    betadb = pi*arg1db
    tempb4 = 0.5d0*b1b/result1
    s1b = s1b + 2*s1d*tempb5 + (DEXP(-(s1**2))*result1d*0.5d0*2*s1+DEXP(&
&     -(s1**2))*temp6*result1*0.5d0*2*s1)*tempb6 - DEXP(-(s1**2))*2*s1*&
&     tempb4
    result1b = temp6*tempb7 - (-(0.5d0*(temp6*result1*temp8))-0.5d0*(&
&     temp7*result1d))*2*tempb6/result1 - DEXP(-(s1**2))*tempb4/result1
    s1db = s1db + 2*s1*tempb5
    result1db = -(0.5d0*temp7*tempb6)
    arg1 = pi*beta
    CALL POPREAL8(result1)
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.D0*DSQRT(arg1))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
      arg1db = 0.0_8
    ELSE
      arg1d = pi*betad
      CALL POPREAL8(result1d)
      temp5 = DSQRT(arg1)
      tempb3 = result1db/(2.d0*temp5)
      arg1db = tempb3
      IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb3/(temp5*2.D0*&
&         DSQRT(arg1))
    END IF
    result1b = und*s2db + un*s2b
    IF (beta .EQ. 0.0) THEN
      betab = betab + pi*arg1b
    ELSE
      betab = betab + result1b/(2.D0*DSQRT(beta)) + pi*arg1b
    END IF
    betadb = betadb + pi*arg1db
    unb = unb + result1d*s2db + result1*s2b
    undb = undb + result1*s2db
    result1db = un*s2db
    CALL POPREAL8(result1)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
    ELSE
      CALL POPREAL8(result1d)
      temp0 = DSQRT(beta)
      tempb2 = result1db/(2.d0*temp0)
      betadb = betadb + tempb2
      IF (.NOT.beta .EQ. 0.0) betab = betab - betad*tempb2/(temp0*2.D0*&
&         DSQRT(beta))
    END IF
    utb = utb + result1d*s1db + result1*s1b
    result1b = utd*s1db + ut*s1b
    utdb = utdb + result1*s1db
    result1db = ut*s1db
    IF (.NOT.beta .EQ. 0.0) betab = betab + result1b/(2.D0*DSQRT(beta))
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      temp = DSQRT(beta)
      tempb1 = result1db/(2.d0*temp)
      betadb = betadb + tempb1
      IF (.NOT.beta .EQ. 0.0) betab = betab - betad*tempb1/(temp*2.D0*&
&         DSQRT(beta))
    END IF
    tyb = u2d*utdb + u2*utb
    txb = u1d*utdb + u1*utb
    tempb0 = betadb/pr**2
    tempb = 0.5d0*betab/pr
    rhob = rhob + tempb - 0.5d0*prd*tempb0
    prb = prb + (0.5d0*rhod-(0.5d0*(rhod*pr)-0.5d0*(rho*prd))*2/pr)*&
&     tempb0 - rho*tempb/pr
    rhodb = rhodb + 0.5d0*pr*tempb0
    prdb = prdb - 0.5d0*rho*tempb0
    u1b = tx*utb + nx*unb
    nxb = nxb + u1d*undb - tyb + u1*unb
    u2b = ty*utb + ny*unb
    nyb = nyb + u2d*undb + txb + u2*unb
    u1db = tx*utdb + nx*undb
    u2db = ty*utdb + ny*undb
  END SUBROUTINE FLUX_QUAD_GXII_D_B

!  Differentiation of flux_quad_gxii in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: g u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXII_D(g, gd, nx, ny, u1, u1d, u2, u2d, rho, rhod&
&   , pr, prd)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: a1pos, a2neg
    DOUBLE PRECISION :: a1posd, a2negd
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    IF (beta .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!result1d = DERF_D(s1, s1d, result1)
    result1d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    result1 = DERF(s1)
    a1posd = 0.5d0*result1d
    a1pos = 0.5d0*(1.d0+result1)
!result1d = DERF_D(s2, s2d, result1)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    result1 = DERF(s2)
    a2negd = -(0.5d0*result1d)
    a2neg = 0.5d0*(1.d0-result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    gd(1) = (rhod*a2neg+rho*a2negd)*(ut*a1pos+b1) + rho*a2neg*(utd*a1pos&
&     +ut*a1posd+b1d)
    g(1) = rho*a2neg*(ut*a1pos+b1)
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp1 = pr_by_rho + ut*ut
    temp2d = temp1d*a1pos + temp1*a1posd + utd*b1 + ut*b1d
    temp2 = temp1*a1pos + ut*b1
    gd(2) = (rhod*a2neg+rho*a2negd)*temp2 + rho*a2neg*temp2d
    g(2) = rho*a2neg*temp2
    temp1d = utd*a1pos + ut*a1posd + b1d
    temp1 = ut*a1pos + b1
    temp2d = und*a2neg + un*a2negd - b2d
    temp2 = un*a2neg - b2
    gd(3) = (rhod*temp1+rho*temp1d)*temp2 + rho*temp1*temp2d
    g(3) = rho*temp1*temp2
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1pos+ut*temp1*a1posd)
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(b1d*temp1+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
    temp1d = utd*a1pos + ut*a1posd + b1d
    temp1 = ut*a1pos + b1
    temp4d = 0.5d0*((rhod*un+rho*und)*b2*temp1+rho*un*(b2d*temp1+b2*&
&     temp1d))
    temp4 = 0.5d0*rho*un*b2*temp1
    gd(4) = (rhod*a2neg+rho*a2negd)*(temp2+temp3) + rho*a2neg*(temp2d+&
&     temp3d) - temp4d
    g(4) = rho*a2neg*(temp2+temp3) - temp4
  END SUBROUTINE FLUX_QUAD_GXII_D

  SUBROUTINE FLUX_QUAD_GXII(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1pos, a2neg
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    result1 = DSQRT(beta)
    s1 = ut*result1
    result1 = DSQRT(beta)
    s2 = un*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.d0+result1)
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    g(1) = rho*a2neg*(ut*a1pos+b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    g(2) = rho*a2neg*temp2
    temp1 = ut*a1pos + b1
    temp2 = un*a2neg - b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1pos + b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2neg*(temp2+temp3) - temp4
  END SUBROUTINE FLUX_QUAD_GXII

!  Differentiation of flux_quad_gxiii_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: g nx ny gd
!   with respect to varying inputs: g nx ny u1d rhod prd u1 u2
!                pr u2d rho gd
!  Differentiation of flux_quad_gxiii in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: g u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXIII_D_B(g, gb, gd, gdb, nx, nxb, ny, nyb, u1, &
&   u1b, u1d, u1db, u2, u2b, u2d, u2db, rho, rhob, rhod, rhodb, pr, prb&
&   , prd, prdb)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: gdb(4), u1db, u2db, rhodb, prdb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: utdb, undb
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betab
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: betadb
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1b, b1b, s2b, b2b
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: s1db, b1db, s2db, b2db
    DOUBLE PRECISION :: a1pos, a2pos
    DOUBLE PRECISION :: a1posb, a2posb
    DOUBLE PRECISION :: a1posd, a2posd
    DOUBLE PRECISION :: a1posdb, a2posdb
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: temp1db, temp2db, temp3db, temp4db
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: pr_by_rhodb, u_sqrdb
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: result1db
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: DERF
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: tempb2
    DOUBLE PRECISION :: temp5
    REAL*8 :: tempb3
    DOUBLE PRECISION :: temp6
    DOUBLE PRECISION :: temp7
    DOUBLE PRECISION :: temp8
    DOUBLE PRECISION :: tempb4
    DOUBLE PRECISION :: tempb5
    DOUBLE PRECISION :: tempb6
    DOUBLE PRECISION :: tempb7
    DOUBLE PRECISION :: temp9
    REAL*8 :: tempb8
    DOUBLE PRECISION :: temp10
    DOUBLE PRECISION :: temp11
    DOUBLE PRECISION :: temp12
    REAL*8 :: temp13
    REAL*8 :: temp14
    DOUBLE PRECISION :: tempb9
    DOUBLE PRECISION :: tempb10
    DOUBLE PRECISION :: tempb11
    DOUBLE PRECISION :: tempb12
    DOUBLE PRECISION :: tempb13
    DOUBLE PRECISION :: tempb14
    DOUBLE PRECISION :: tempb15
    DOUBLE PRECISION :: tempb16
    DOUBLE PRECISION :: tempb17
    DOUBLE PRECISION :: tempb18
    DOUBLE PRECISION :: tempb19
    DOUBLE PRECISION :: tempb20
    DOUBLE PRECISION :: tempb21
    DOUBLE PRECISION :: tempb22
    DOUBLE PRECISION :: tempb23
    DOUBLE PRECISION :: tempb24
    DOUBLE PRECISION :: tempb25
    DOUBLE PRECISION :: tempb26
    DOUBLE PRECISION :: tempb27
    DOUBLE PRECISION :: tempb28
    DOUBLE PRECISION :: tempb29
    DOUBLE PRECISION :: tempb30
    DOUBLE PRECISION :: tempb31
    DOUBLE PRECISION :: tempb32
    DOUBLE PRECISION :: tempb33
    DOUBLE PRECISION :: tempb34
    DOUBLE PRECISION :: tempb35
    DOUBLE PRECISION :: tempb36
    INTEGER :: branch
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      CALL PUSHCONTROL1B(0)
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
      CALL PUSHCONTROL1B(1)
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    IF (beta .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = betad/(2.d0*DSQRT(beta))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = arg1d/(2.d0*DSQRT(arg1))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = arg1d/(2.d0*DSQRT(arg1))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!result1d = DERF_D(s1, s1d, result1)
    CALL PUSHREAL8(result1d)
    result1d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    CALL PUSHREAL8(result1)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1posd = 0.5d0*result1d
    a1pos = 0.5d0*(1.0d0+result1)
!result1d = DERF_D(s2, s2d, result1)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2posd = 0.5d0*result1d
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1pos+ut*temp1*a1posd)
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(b1d*temp1+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
    temp1d = utd*a1pos + ut*a1posd + b1d
    temp1 = ut*a1pos + b1
    tempb11 = (rhod*a2pos+rho*a2posd)*gdb(4)
    tempb10 = (temp2+temp3)*gdb(4)
    tempb9 = rho*a2pos*gb(4)
    rhob = a2posd*tempb10 + (temp2d+temp3d)*a2pos*gdb(4) + (temp2+temp3)&
&     *a2pos*gb(4)
    a2posb = rhod*tempb10 + (temp2d+temp3d)*rho*gdb(4) + (temp2+temp3)*&
&     rho*gb(4)
    temp2b = tempb11 + tempb9
    temp3b = tempb11 + tempb9
    temp4b = gb(4)
    gb(4) = 0.D0
    tempb12 = rho*a2pos*gdb(4)
    temp2db = tempb12
    temp3db = tempb12
    temp4db = gdb(4)
    gdb(4) = 0.D0
    tempb15 = 0.5d0*b2*temp1*temp4b
    tempb16 = 0.5d0*rho*un*temp4b
    tempb20 = 0.5d0*temp4db
    tempb13 = b2*temp1*tempb20
    tempb18 = (rhod*un+rho*und)*tempb20
    tempb17 = (b2d*temp1+b2*temp1d)*tempb20
    tempb19 = rho*un*tempb20
    b2b = temp1*tempb18 + temp1d*tempb19 + temp1*tempb16
    temp1b = b2*tempb18 + b2d*tempb19 + b2*tempb16
    b2db = temp1*tempb19
    temp1db = b2*tempb19
    utb = a1posd*temp1db + a1pos*temp1b
    temp1 = 6.0d0*pr_by_rho + u_sqr
    utdb = a1pos*temp1db
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    tempb22 = 0.5d0*temp3db
    b1b = 0.5d0*temp1*temp3b + temp1d*tempb22 + temp1b
    b1db = temp1*tempb22 + temp1db
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    tempb23 = 0.5d0*a1pos*temp2b
    tempb21 = 0.5d0*temp2db
    a1posb = utd*temp1db + (utd*temp1+ut*temp1d)*tempb21 + 0.5d0*ut*&
&     temp1*temp2b + ut*temp1b
    a1posdb = ut*temp1*tempb21 + ut*temp1db
    temp1b = b1d*tempb22 + 0.5d0*b1*temp3b
    temp1db = b1*tempb22
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    pr_by_rhodb = 6.0d0*temp1db
    u_sqrdb = temp1db
    tempb24 = a1pos*tempb21
    temp1b = utd*tempb24 + a1posd*ut*tempb21 + ut*tempb23
    temp1db = ut*tempb24
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    pr_by_rhodb = pr_by_rhodb + 7.0d0*temp1db
    u_sqrdb = u_sqrdb + temp1db
    temp2 = un*a2pos + b2
    temp2d = und*a2pos + un*a2posd + b2d
    tempb14 = temp2*gdb(3)
    temp1b = rhod*tempb14 + temp2d*rho*gdb(3) + temp2*rho*gb(3)
    temp1db = rho*tempb14
    utb = utb + temp1d*tempb24 + a1posd*temp1*tempb21 + a1posd*temp1db +&
&     a1pos*temp1b + temp1*tempb23
    utdb = utdb + a1pos*temp1db + temp1*tempb24
    temp1 = ut*a1pos + b1
    rhodb = un*tempb13 + temp1*tempb14 + a2pos*tempb10
    temp1d = utd*a1pos + ut*a1posd + b1d
    rhob = rhob + und*tempb13 + un*tempb17 + temp1d*tempb14 + temp2d*&
&     temp1*gdb(3) + temp2*temp1*gb(3) + un*tempb15
    temp2b = (rhod*temp1+rho*temp1d)*gdb(3) + rho*temp1*gb(3)
    gb(3) = 0.D0
    temp2db = rho*temp1*gdb(3)
    a2posdb = un*temp2db + rho*tempb10
    unb = rhod*tempb13 + rho*tempb17 + a2posd*temp2db + 2*und*u_sqrdb + &
&     2*un*u_sqrb + a2pos*temp2b + rho*tempb15
    undb = a2pos*temp2db + 2*un*u_sqrdb + rho*tempb13
    gdb(3) = 0.D0
    b2b = b2b + temp2b
    b2db = b2db + temp2db
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp2d = temp1d*a1pos + temp1*a1posd + utd*b1 + ut*b1d
    tempb25 = temp2*gdb(2)
    a2posb = a2posb + und*temp2db + rhod*tempb25 + temp2d*rho*gdb(2) + &
&     temp2*rho*gb(2) + un*temp2b
    rhob = rhob + a2posd*tempb25 + temp2d*a2pos*gdb(2) + temp2*a2pos*gb(&
&     2)
    temp2b = (rhod*a2pos+rho*a2posd)*gdb(2) + rho*a2pos*gb(2)
    gb(2) = 0.D0
    temp2db = rho*a2pos*gdb(2)
    gdb(2) = 0.D0
    tempb31 = (ut*a1pos+b1)*gb(1)
    tempb28 = rho*a2pos*gb(1)
    gb(1) = 0.D0
    tempb29 = (ut*a1pos+b1)*gdb(1)
    a2posdb = a2posdb + rho*tempb29 + rho*tempb25
    tempb26 = (rhod*a2pos+rho*a2posd)*gdb(1)
    b1b = b1b + ut*temp2b + tempb28 + tempb26 + utd*temp2db + temp1b
    tempb32 = (utd*a1pos+ut*a1posd+b1d)*gdb(1)
    a2posb = a2posb + rhod*tempb29 + rho*tempb32 + rho*tempb31
    tempb27 = rho*a2pos*gdb(1)
    a1posb = a1posb + utd*temp1db + temp1d*temp2db + ut*tempb26 + utd*&
&     tempb27 + ut*tempb28 + temp1*temp2b + ut*temp1b
    a1posdb = a1posdb + temp1*temp2db + ut*tempb27 + ut*temp1db
    b1db = b1db + ut*temp2db + tempb27 + temp1db
    temp1b = a1posd*temp2db + a1pos*temp2b
    temp1db = a1pos*temp2db
    utb = utb + b1d*temp2db + 2*utd*temp1db + a1pos*tempb26 + a1posd*&
&     tempb27 + 2*utd*u_sqrdb + 2*ut*u_sqrb + a1pos*tempb28 + 2*ut*&
&     temp1b + b1*temp2b
    utdb = utdb + 2*ut*temp1db + 2*ut*u_sqrdb + a1pos*tempb27 + b1*&
&     temp2db
    pr_by_rhob = pr_by_rhob + temp1b
    pr_by_rhodb = pr_by_rhodb + temp1db
    gdb(1) = 0.D0
    tempb30 = pr_by_rhodb/rho**2
    rhodb = rhodb + a2pos*tempb29 - pr*tempb30 + a2pos*tempb25
    rhob = rhob + a2posd*tempb29 + a2pos*tempb32 + (prd-(prd*rho-pr*rhod&
&     )*2/rho)*tempb30 - pr*pr_by_rhob/rho**2 + a2pos*tempb31
    prb = pr_by_rhob/rho - rhod*tempb30
    prdb = rho*tempb30
    result1b = 0.5d0*a2posb
    result1db = 0.5d0*a2posdb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0
    CALL DERF_B(s2, s2b, result1b)
    CALL POPREAL8(s2)
    temp14 = SQRT(pi)
    result1b = 0.5d0*a1posb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL POPREAL8(result1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0
    CALL DERF_B(s1, s1b, result1b)
    CALL POPREAL8(s1)
    CALL POPREAL8(result1)
    CALL POPREAL8(result1d)
    temp13 = SQRT(pi)
    tempb33 = 0.5d0*b2b/result1
    tempb34 = b2db/result1**2
    temp12 = DEXP(-(s2**2))
    temp10 = s2d*s2 + s2*s2d
    tempb36 = -(0.5d0*temp12*tempb34)
    tempb35 = result1*tempb36
    s2b = s2b + (DEXP(-(s2**2))*result1d*0.5d0*2*s2+DEXP(-(s2**2))*&
&     temp10*result1*0.5d0*2*s2)*tempb34 - DEXP(-(s2**2))*2*s2*tempb33 +&
&     2*s2d*tempb35 - DEXP(-(s2**2))*s2d*2.d0*2*s2*result1db/temp14
    s2db = 2*s2*tempb35 + DEXP(-(s2**2))*2.d0*result1db/temp14
    result1db = 0.5d0*a1posdb
    s1b = s1b - DEXP(-(s1**2))*s1d*2.d0*2*s1*result1db/temp13
    s1db = DEXP(-(s1**2))*2.d0*result1db/temp13
    temp11 = DEXP(-(s2**2))
    result1b = temp10*tempb36 - (-(0.5d0*(temp10*result1*temp12))-0.5d0*&
&     (temp11*result1d))*2*tempb34/result1 - DEXP(-(s2**2))*tempb33/&
&     result1
    result1db = -(0.5d0*temp11*tempb34)
    CALL POPREAL8(result1)
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.D0*DSQRT(arg1))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
      arg1db = 0.0_8
    ELSE
      CALL POPREAL8(result1d)
      temp9 = DSQRT(arg1)
      tempb8 = result1db/(2.d0*temp9)
      arg1db = tempb8
      IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb8/(temp9*2.D0*&
&         DSQRT(arg1))
    END IF
    temp7 = DEXP(-(s1**2))
    tempb6 = b1db/result1**2
    temp8 = DEXP(-(s1**2))
    temp6 = s1d*s1 + s1*s1d
    tempb7 = -(0.5d0*temp8*tempb6)
    tempb5 = result1*tempb7
    betab = pi*arg1b
    betadb = pi*arg1db
    tempb4 = 0.5d0*b1b/result1
    s1b = s1b + 2*s1d*tempb5 + (DEXP(-(s1**2))*result1d*0.5d0*2*s1+DEXP(&
&     -(s1**2))*temp6*result1*0.5d0*2*s1)*tempb6 - DEXP(-(s1**2))*2*s1*&
&     tempb4
    result1b = temp6*tempb7 - (-(0.5d0*(temp6*result1*temp8))-0.5d0*(&
&     temp7*result1d))*2*tempb6/result1 - DEXP(-(s1**2))*tempb4/result1
    s1db = s1db + 2*s1*tempb5
    result1db = -(0.5d0*temp7*tempb6)
    arg1 = pi*beta
    CALL POPREAL8(result1)
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.D0*DSQRT(arg1))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
      arg1db = 0.0_8
    ELSE
      arg1d = pi*betad
      CALL POPREAL8(result1d)
      temp5 = DSQRT(arg1)
      tempb3 = result1db/(2.d0*temp5)
      arg1db = tempb3
      IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb3/(temp5*2.D0*&
&         DSQRT(arg1))
    END IF
    result1b = und*s2db + un*s2b
    IF (beta .EQ. 0.0) THEN
      betab = betab + pi*arg1b
    ELSE
      betab = betab + result1b/(2.D0*DSQRT(beta)) + pi*arg1b
    END IF
    betadb = betadb + pi*arg1db
    unb = unb + result1d*s2db + result1*s2b
    undb = undb + result1*s2db
    result1db = un*s2db
    CALL POPREAL8(result1)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
    ELSE
      CALL POPREAL8(result1d)
      temp0 = DSQRT(beta)
      tempb2 = result1db/(2.d0*temp0)
      betadb = betadb + tempb2
      IF (.NOT.beta .EQ. 0.0) betab = betab - betad*tempb2/(temp0*2.D0*&
&         DSQRT(beta))
    END IF
    utb = utb + result1d*s1db + result1*s1b
    result1b = utd*s1db + ut*s1b
    utdb = utdb + result1*s1db
    result1db = ut*s1db
    IF (.NOT.beta .EQ. 0.0) betab = betab + result1b/(2.D0*DSQRT(beta))
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      temp = DSQRT(beta)
      tempb1 = result1db/(2.d0*temp)
      betadb = betadb + tempb1
      IF (.NOT.beta .EQ. 0.0) betab = betab - betad*tempb1/(temp*2.D0*&
&         DSQRT(beta))
    END IF
    tyb = u2d*utdb + u2*utb
    txb = u1d*utdb + u1*utb
    tempb0 = betadb/pr**2
    tempb = 0.5d0*betab/pr
    rhob = rhob + tempb - 0.5d0*prd*tempb0
    prb = prb + (0.5d0*rhod-(0.5d0*(rhod*pr)-0.5d0*(rho*prd))*2/pr)*&
&     tempb0 - rho*tempb/pr
    rhodb = rhodb + 0.5d0*pr*tempb0
    prdb = prdb - 0.5d0*rho*tempb0
    u1b = tx*utb + nx*unb
    nxb = nxb + u1d*undb - tyb + u1*unb
    u2b = ty*utb + ny*unb
    nyb = nyb + u2d*undb + txb + u2*unb
    u1db = tx*utdb + nx*undb
    u2db = ty*utdb + ny*undb
  END SUBROUTINE FLUX_QUAD_GXIII_D_B

!  Differentiation of flux_quad_gxiii in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: g u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXIII_D(g, gd, nx, ny, u1, u1d, u2, u2d, rho, &
&   rhod, pr, prd)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: a1pos, a2pos
    DOUBLE PRECISION :: a1posd, a2posd
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    IF (beta .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!result1d = DERF_D(s1, s1d, result1)
    result1d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    result1 = DERF(s1)
    a1posd = 0.5d0*result1d
    a1pos = 0.5d0*(1.0d0+result1)
!result1d = DERF_D(s2, s2d, result1)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    result1 = DERF(s2)
    a2posd = 0.5d0*result1d
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    gd(1) = (rhod*a2pos+rho*a2posd)*(ut*a1pos+b1) + rho*a2pos*(utd*a1pos&
&     +ut*a1posd+b1d)
    g(1) = rho*a2pos*(ut*a1pos+b1)
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp1 = pr_by_rho + ut*ut
    temp2d = temp1d*a1pos + temp1*a1posd + utd*b1 + ut*b1d
    temp2 = temp1*a1pos + ut*b1
    gd(2) = (rhod*a2pos+rho*a2posd)*temp2 + rho*a2pos*temp2d
    g(2) = rho*a2pos*temp2
    temp1d = utd*a1pos + ut*a1posd + b1d
    temp1 = ut*a1pos + b1
    temp2d = und*a2pos + un*a2posd + b2d
    temp2 = un*a2pos + b2
    gd(3) = (rhod*temp1+rho*temp1d)*temp2 + rho*temp1*temp2d
    g(3) = rho*temp1*temp2
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1pos+ut*temp1*a1posd)
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(b1d*temp1+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
    temp1d = utd*a1pos + ut*a1posd + b1d
    temp1 = ut*a1pos + b1
    temp4d = 0.5d0*((rhod*un+rho*und)*b2*temp1+rho*un*(b2d*temp1+b2*&
&     temp1d))
    temp4 = 0.5d0*rho*un*b2*temp1
    gd(4) = (rhod*a2pos+rho*a2posd)*(temp2+temp3) + rho*a2pos*(temp2d+&
&     temp3d) + temp4d
    g(4) = rho*a2pos*(temp2+temp3) + temp4
  END SUBROUTINE FLUX_QUAD_GXIII_D

  SUBROUTINE FLUX_QUAD_GXIII(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1pos, a2pos
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    result1 = DSQRT(beta)
    s1 = ut*result1
    result1 = DSQRT(beta)
    s2 = un*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.0d0+result1)
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    g(1) = rho*a2pos*(ut*a1pos+b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    g(2) = rho*a2pos*temp2
    temp1 = ut*a1pos + b1
    temp2 = un*a2pos + b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1pos + b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2pos*(temp2+temp3) + temp4
  END SUBROUTINE FLUX_QUAD_GXIII

!  Differentiation of flux_quad_gxiv_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: g nx ny gd
!   with respect to varying inputs: g nx ny u1d rhod prd u1 u2
!                pr u2d rho gd
!  Differentiation of flux_quad_gxiv in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: g u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXIV_D_B(g, gb, gd, gdb, nx, nxb, ny, nyb, u1, &
&   u1b, u1d, u1db, u2, u2b, u2d, u2db, rho, rhob, rhod, rhodb, pr, prb&
&   , prd, prdb)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: gdb(4), u1db, u2db, rhodb, prdb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: utdb, undb
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betab
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: betadb
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1b, b1b, s2b, b2b
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: s1db, b1db, s2db, b2db
    DOUBLE PRECISION :: a1neg, a2pos
    DOUBLE PRECISION :: a1negb, a2posb
    DOUBLE PRECISION :: a1negd, a2posd
    DOUBLE PRECISION :: a1negdb, a2posdb
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1b, temp2b, temp3b, temp4b
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: temp1db, temp2db, temp3db, temp4db
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: pr_by_rhodb, u_sqrdb
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: result1db
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: DERF
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: temp0
    DOUBLE PRECISION :: tempb2
    DOUBLE PRECISION :: temp5
    REAL*8 :: tempb3
    DOUBLE PRECISION :: temp6
    DOUBLE PRECISION :: temp7
    DOUBLE PRECISION :: temp8
    DOUBLE PRECISION :: tempb4
    DOUBLE PRECISION :: tempb5
    DOUBLE PRECISION :: tempb6
    DOUBLE PRECISION :: tempb7
    DOUBLE PRECISION :: temp9
    REAL*8 :: tempb8
    DOUBLE PRECISION :: temp10
    DOUBLE PRECISION :: temp11
    DOUBLE PRECISION :: temp12
    REAL*8 :: temp13
    REAL*8 :: temp14
    DOUBLE PRECISION :: tempb9
    DOUBLE PRECISION :: tempb10
    DOUBLE PRECISION :: tempb11
    DOUBLE PRECISION :: tempb12
    DOUBLE PRECISION :: tempb13
    DOUBLE PRECISION :: tempb14
    DOUBLE PRECISION :: tempb15
    DOUBLE PRECISION :: tempb16
    DOUBLE PRECISION :: tempb17
    DOUBLE PRECISION :: tempb18
    DOUBLE PRECISION :: tempb19
    DOUBLE PRECISION :: tempb20
    DOUBLE PRECISION :: tempb21
    DOUBLE PRECISION :: tempb22
    DOUBLE PRECISION :: tempb23
    DOUBLE PRECISION :: tempb24
    DOUBLE PRECISION :: tempb25
    DOUBLE PRECISION :: tempb26
    DOUBLE PRECISION :: tempb27
    DOUBLE PRECISION :: tempb28
    DOUBLE PRECISION :: tempb29
    DOUBLE PRECISION :: tempb30
    DOUBLE PRECISION :: tempb31
    DOUBLE PRECISION :: tempb32
    DOUBLE PRECISION :: tempb33
    DOUBLE PRECISION :: tempb34
    DOUBLE PRECISION :: tempb35
    DOUBLE PRECISION :: tempb36
    INTEGER :: branch
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      CALL PUSHCONTROL1B(0)
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
      CALL PUSHCONTROL1B(1)
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    IF (beta .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = betad/(2.d0*DSQRT(beta))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = arg1d/(2.d0*DSQRT(arg1))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = arg1d/(2.d0*DSQRT(arg1))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!result1d = DERF_D(s1, s1d, result1)
    CALL PUSHREAL8(result1d)
    result1d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    CALL PUSHREAL8(result1)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1negd = -(0.5d0*result1d)
    a1neg = 0.5d0*(1.0d0-result1)
!result1d = DERF_D(s2, s2d, result1)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2posd = 0.5d0*result1d
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1neg+ut*temp1*a1negd)
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(b1d*temp1+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
    temp1d = utd*a1neg + ut*a1negd - b1d
    temp1 = ut*a1neg - b1
    tempb11 = (rhod*a2pos+rho*a2posd)*gdb(4)
    tempb10 = (temp2-temp3)*gdb(4)
    tempb9 = rho*a2pos*gb(4)
    rhob = a2posd*tempb10 + (temp2d-temp3d)*a2pos*gdb(4) + (temp2-temp3)&
&     *a2pos*gb(4)
    a2posb = rhod*tempb10 + (temp2d-temp3d)*rho*gdb(4) + (temp2-temp3)*&
&     rho*gb(4)
    temp2b = tempb11 + tempb9
    temp3b = -tempb11 - tempb9
    temp4b = gb(4)
    gb(4) = 0.D0
    tempb12 = rho*a2pos*gdb(4)
    temp2db = tempb12
    temp3db = -tempb12
    temp4db = gdb(4)
    gdb(4) = 0.D0
    tempb15 = 0.5d0*b2*temp1*temp4b
    tempb16 = 0.5d0*rho*un*temp4b
    tempb20 = 0.5d0*temp4db
    tempb13 = b2*temp1*tempb20
    tempb18 = (rhod*un+rho*und)*tempb20
    tempb17 = (b2d*temp1+b2*temp1d)*tempb20
    tempb19 = rho*un*tempb20
    b2b = temp1*tempb18 + temp1d*tempb19 + temp1*tempb16
    temp1b = b2*tempb18 + b2d*tempb19 + b2*tempb16
    b2db = temp1*tempb19
    temp1db = b2*tempb19
    utb = a1negd*temp1db + a1neg*temp1b
    temp1 = 6.0d0*pr_by_rho + u_sqr
    utdb = a1neg*temp1db
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    tempb22 = 0.5d0*temp3db
    b1b = 0.5d0*temp1*temp3b + temp1d*tempb22 - temp1b
    b1db = temp1*tempb22 - temp1db
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    tempb23 = 0.5d0*a1neg*temp2b
    tempb21 = 0.5d0*temp2db
    a1negb = utd*temp1db + (utd*temp1+ut*temp1d)*tempb21 + 0.5d0*ut*&
&     temp1*temp2b + ut*temp1b
    a1negdb = ut*temp1*tempb21 + ut*temp1db
    temp1b = b1d*tempb22 + 0.5d0*b1*temp3b
    temp1db = b1*tempb22
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    pr_by_rhodb = 6.0d0*temp1db
    u_sqrdb = temp1db
    tempb24 = a1neg*tempb21
    temp1b = utd*tempb24 + a1negd*ut*tempb21 + ut*tempb23
    temp1db = ut*tempb24
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    pr_by_rhodb = pr_by_rhodb + 7.0d0*temp1db
    u_sqrdb = u_sqrdb + temp1db
    temp2 = un*a2pos + b2
    temp2d = und*a2pos + un*a2posd + b2d
    tempb14 = temp2*gdb(3)
    temp1b = rhod*tempb14 + temp2d*rho*gdb(3) + temp2*rho*gb(3)
    temp1db = rho*tempb14
    utb = utb + temp1d*tempb24 + a1negd*temp1*tempb21 + a1negd*temp1db +&
&     a1neg*temp1b + temp1*tempb23
    utdb = utdb + a1neg*temp1db + temp1*tempb24
    temp1 = ut*a1neg - b1
    rhodb = un*tempb13 + temp1*tempb14 + a2pos*tempb10
    temp1d = utd*a1neg + ut*a1negd - b1d
    rhob = rhob + und*tempb13 + un*tempb17 + temp1d*tempb14 + temp2d*&
&     temp1*gdb(3) + temp2*temp1*gb(3) + un*tempb15
    temp2b = (rhod*temp1+rho*temp1d)*gdb(3) + rho*temp1*gb(3)
    gb(3) = 0.D0
    temp2db = rho*temp1*gdb(3)
    a2posdb = un*temp2db + rho*tempb10
    unb = rhod*tempb13 + rho*tempb17 + a2posd*temp2db + 2*und*u_sqrdb + &
&     2*un*u_sqrb + a2pos*temp2b + rho*tempb15
    undb = a2pos*temp2db + 2*un*u_sqrdb + rho*tempb13
    gdb(3) = 0.D0
    b2b = b2b + temp2b
    b2db = b2db + temp2db
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp2d = temp1d*a1neg + temp1*a1negd - utd*b1 - ut*b1d
    tempb25 = temp2*gdb(2)
    a2posb = a2posb + und*temp2db + rhod*tempb25 + temp2d*rho*gdb(2) + &
&     temp2*rho*gb(2) + un*temp2b
    rhob = rhob + a2posd*tempb25 + temp2d*a2pos*gdb(2) + temp2*a2pos*gb(&
&     2)
    temp2b = (rhod*a2pos+rho*a2posd)*gdb(2) + rho*a2pos*gb(2)
    gb(2) = 0.D0
    temp2db = rho*a2pos*gdb(2)
    gdb(2) = 0.D0
    tempb31 = (ut*a1neg-b1)*gb(1)
    tempb28 = rho*a2pos*gb(1)
    gb(1) = 0.D0
    tempb29 = (ut*a1neg-b1)*gdb(1)
    a2posdb = a2posdb + rho*tempb29 + rho*tempb25
    tempb26 = (rhod*a2pos+rho*a2posd)*gdb(1)
    b1b = b1b - ut*temp2b - tempb28 - tempb26 - utd*temp2db - temp1b
    tempb32 = (utd*a1neg+ut*a1negd-b1d)*gdb(1)
    a2posb = a2posb + rhod*tempb29 + rho*tempb32 + rho*tempb31
    tempb27 = rho*a2pos*gdb(1)
    a1negb = a1negb + utd*temp1db + temp1d*temp2db + ut*tempb26 + utd*&
&     tempb27 + ut*tempb28 + temp1*temp2b + ut*temp1b
    a1negdb = a1negdb + temp1*temp2db + ut*tempb27 + ut*temp1db
    b1db = b1db - ut*temp2db - tempb27 - temp1db
    temp1b = a1negd*temp2db + a1neg*temp2b
    temp1db = a1neg*temp2db
    utb = utb + 2*utd*temp1db - b1d*temp2db + a1neg*tempb26 + a1negd*&
&     tempb27 + 2*utd*u_sqrdb + 2*ut*u_sqrb + a1neg*tempb28 + 2*ut*&
&     temp1b - b1*temp2b
    utdb = utdb + 2*ut*temp1db + 2*ut*u_sqrdb + a1neg*tempb27 - b1*&
&     temp2db
    pr_by_rhob = pr_by_rhob + temp1b
    pr_by_rhodb = pr_by_rhodb + temp1db
    gdb(1) = 0.D0
    tempb30 = pr_by_rhodb/rho**2
    rhodb = rhodb + a2pos*tempb29 - pr*tempb30 + a2pos*tempb25
    rhob = rhob + a2posd*tempb29 + a2pos*tempb32 + (prd-(prd*rho-pr*rhod&
&     )*2/rho)*tempb30 - pr*pr_by_rhob/rho**2 + a2pos*tempb31
    prb = pr_by_rhob/rho - rhod*tempb30
    prdb = rho*tempb30
    result1b = 0.5d0*a2posb
    result1db = 0.5d0*a2posdb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0
    CALL DERF_B(s2, s2b, result1b)
    CALL POPREAL8(s2)
    temp14 = SQRT(pi)
    result1b = -(0.5d0*a1negb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL POPREAL8(result1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0
    CALL DERF_B(s1, s1b, result1b)
    CALL POPREAL8(s1)
    CALL POPREAL8(result1)
    CALL POPREAL8(result1d)
    temp13 = SQRT(pi)
    tempb33 = 0.5d0*b2b/result1
    tempb34 = b2db/result1**2
    temp12 = DEXP(-(s2**2))
    temp10 = s2d*s2 + s2*s2d
    tempb36 = -(0.5d0*temp12*tempb34)
    tempb35 = result1*tempb36
    s2b = s2b + (DEXP(-(s2**2))*result1d*0.5d0*2*s2+DEXP(-(s2**2))*&
&     temp10*result1*0.5d0*2*s2)*tempb34 - DEXP(-(s2**2))*2*s2*tempb33 +&
&     2*s2d*tempb35 - DEXP(-(s2**2))*s2d*2.d0*2*s2*result1db/temp14
    s2db = 2*s2*tempb35 + DEXP(-(s2**2))*2.d0*result1db/temp14
    result1db = -(0.5d0*a1negdb)
    s1b = s1b - DEXP(-(s1**2))*s1d*2.d0*2*s1*result1db/temp13
    s1db = DEXP(-(s1**2))*2.d0*result1db/temp13
    temp11 = DEXP(-(s2**2))
    result1b = temp10*tempb36 - (-(0.5d0*(temp10*result1*temp12))-0.5d0*&
&     (temp11*result1d))*2*tempb34/result1 - DEXP(-(s2**2))*tempb33/&
&     result1
    result1db = -(0.5d0*temp11*tempb34)
    CALL POPREAL8(result1)
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.D0*DSQRT(arg1))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
      arg1db = 0.0_8
    ELSE
      CALL POPREAL8(result1d)
      temp9 = DSQRT(arg1)
      tempb8 = result1db/(2.d0*temp9)
      arg1db = tempb8
      IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb8/(temp9*2.D0*&
&         DSQRT(arg1))
    END IF
    temp7 = DEXP(-(s1**2))
    tempb6 = b1db/result1**2
    temp8 = DEXP(-(s1**2))
    temp6 = s1d*s1 + s1*s1d
    tempb7 = -(0.5d0*temp8*tempb6)
    tempb5 = result1*tempb7
    betab = pi*arg1b
    betadb = pi*arg1db
    tempb4 = 0.5d0*b1b/result1
    s1b = s1b + 2*s1d*tempb5 + (DEXP(-(s1**2))*result1d*0.5d0*2*s1+DEXP(&
&     -(s1**2))*temp6*result1*0.5d0*2*s1)*tempb6 - DEXP(-(s1**2))*2*s1*&
&     tempb4
    result1b = temp6*tempb7 - (-(0.5d0*(temp6*result1*temp8))-0.5d0*(&
&     temp7*result1d))*2*tempb6/result1 - DEXP(-(s1**2))*tempb4/result1
    s1db = s1db + 2*s1*tempb5
    result1db = -(0.5d0*temp7*tempb6)
    arg1 = pi*beta
    CALL POPREAL8(result1)
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.D0*DSQRT(arg1))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
      arg1db = 0.0_8
    ELSE
      arg1d = pi*betad
      CALL POPREAL8(result1d)
      temp5 = DSQRT(arg1)
      tempb3 = result1db/(2.d0*temp5)
      arg1db = tempb3
      IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb3/(temp5*2.D0*&
&         DSQRT(arg1))
    END IF
    result1b = und*s2db + un*s2b
    IF (beta .EQ. 0.0) THEN
      betab = betab + pi*arg1b
    ELSE
      betab = betab + result1b/(2.D0*DSQRT(beta)) + pi*arg1b
    END IF
    betadb = betadb + pi*arg1db
    unb = unb + result1d*s2db + result1*s2b
    undb = undb + result1*s2db
    result1db = un*s2db
    CALL POPREAL8(result1)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
    ELSE
      CALL POPREAL8(result1d)
      temp0 = DSQRT(beta)
      tempb2 = result1db/(2.d0*temp0)
      betadb = betadb + tempb2
      IF (.NOT.beta .EQ. 0.0) betab = betab - betad*tempb2/(temp0*2.D0*&
&         DSQRT(beta))
    END IF
    utb = utb + result1d*s1db + result1*s1b
    result1b = utd*s1db + ut*s1b
    utdb = utdb + result1*s1db
    result1db = ut*s1db
    IF (.NOT.beta .EQ. 0.0) betab = betab + result1b/(2.D0*DSQRT(beta))
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      temp = DSQRT(beta)
      tempb1 = result1db/(2.d0*temp)
      betadb = betadb + tempb1
      IF (.NOT.beta .EQ. 0.0) betab = betab - betad*tempb1/(temp*2.D0*&
&         DSQRT(beta))
    END IF
    tyb = u2d*utdb + u2*utb
    txb = u1d*utdb + u1*utb
    tempb0 = betadb/pr**2
    tempb = 0.5d0*betab/pr
    rhob = rhob + tempb - 0.5d0*prd*tempb0
    prb = prb + (0.5d0*rhod-(0.5d0*(rhod*pr)-0.5d0*(rho*prd))*2/pr)*&
&     tempb0 - rho*tempb/pr
    rhodb = rhodb + 0.5d0*pr*tempb0
    prdb = prdb - 0.5d0*rho*tempb0
    u1b = tx*utb + nx*unb
    nxb = nxb + u1d*undb - tyb + u1*unb
    u2b = ty*utb + ny*unb
    nyb = nyb + u2d*undb + txb + u2*unb
    u1db = tx*utdb + nx*undb
    u2db = ty*utdb + ny*undb
  END SUBROUTINE FLUX_QUAD_GXIV_D_B

!  Differentiation of flux_quad_gxiv in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: g u1 u2 pr rho
  SUBROUTINE FLUX_QUAD_GXIV_D(g, gd, nx, ny, u1, u1d, u2, u2d, rho, rhod&
&   , pr, prd)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: betad
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: s1d, b1d, s2d, b2d
    DOUBLE PRECISION :: a1neg, a2pos
    DOUBLE PRECISION :: a1negd, a2posd
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: temp1d, temp2d, temp3d, temp4d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    IF (beta .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!result1d = DERF_D(s1, s1d, result1)
    result1d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    result1 = DERF(s1)
    a1negd = -(0.5d0*result1d)
    a1neg = 0.5d0*(1.0d0-result1)
!result1d = DERF_D(s2, s2d, result1)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    result1 = DERF(s2)
    a2posd = 0.5d0*result1d
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    gd(1) = (rhod*a2pos+rho*a2posd)*(ut*a1neg-b1) + rho*a2pos*(utd*a1neg&
&     +ut*a1negd-b1d)
    g(1) = rho*a2pos*(ut*a1neg-b1)
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp1 = pr_by_rho + ut*ut
    temp2d = temp1d*a1neg + temp1*a1negd - utd*b1 - ut*b1d
    temp2 = temp1*a1neg - ut*b1
    gd(2) = (rhod*a2pos+rho*a2posd)*temp2 + rho*a2pos*temp2d
    g(2) = rho*a2pos*temp2
    temp1d = utd*a1neg + ut*a1negd - b1d
    temp1 = ut*a1neg - b1
    temp2d = und*a2pos + un*a2posd + b2d
    temp2 = un*a2pos + b2
    gd(3) = (rhod*temp1+rho*temp1d)*temp2 + rho*temp1*temp2d
    g(3) = rho*temp1*temp2
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1neg+ut*temp1*a1negd)
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3d = 0.5d0*(b1d*temp1+b1*temp1d)
    temp3 = 0.5d0*b1*temp1
    temp1d = utd*a1neg + ut*a1negd - b1d
    temp1 = ut*a1neg - b1
    temp4d = 0.5d0*((rhod*un+rho*und)*b2*temp1+rho*un*(b2d*temp1+b2*&
&     temp1d))
    temp4 = 0.5d0*rho*un*b2*temp1
    gd(4) = (rhod*a2pos+rho*a2posd)*(temp2-temp3) + rho*a2pos*(temp2d-&
&     temp3d) + temp4d
    g(4) = rho*a2pos*(temp2-temp3) + temp4
  END SUBROUTINE FLUX_QUAD_GXIV_D

  SUBROUTINE FLUX_QUAD_GXIV(g, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: g(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta
    DOUBLE PRECISION :: s1, b1, s2, b2
    DOUBLE PRECISION :: a1neg, a2pos
    DOUBLE PRECISION :: temp1, temp2, temp3, temp4
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    result1 = DSQRT(beta)
    s1 = ut*result1
    result1 = DSQRT(beta)
    s2 = un*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!	Expressions for the split fluxes ..	
    g(1) = rho*a2pos*(ut*a1neg-b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    g(2) = rho*a2pos*temp2
    temp1 = ut*a1neg - b1
    temp2 = un*a2pos + b2
    g(3) = rho*temp1*temp2
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    temp3 = 0.5d0*b1*temp1
    temp1 = ut*a1neg - b1
    temp4 = 0.5d0*rho*un*b2*temp1
    g(4) = rho*a2pos*(temp2-temp3) + temp4
  END SUBROUTINE FLUX_QUAD_GXIV

END MODULE QUADRANT_FLUXES_MOD_DIFF_DIFF

