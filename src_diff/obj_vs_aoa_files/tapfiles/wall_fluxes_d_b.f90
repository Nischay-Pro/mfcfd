!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
MODULE WALL_FLUXES_MOD_DIFF_DIFF
!
!	First written on 14.10.2016
!	updated on Dec 29, 2016
!	updated on 19.08.2017
!	
  USE DATA_STRUCTURE_MOD_DIFF_DIFF
  USE QUADRANT_FLUXES_MOD_DIFF_DIFF
  USE SPLIT_FLUXES_MOD_DIFF_DIFF
  USE Q_VARIABLES_MOD_DIFF_DIFF
  USE LIMITERS_MOD_DIFF_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of wall_dgx_pos_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: pointd.q pointd.dq pointd.qm
!                point.x point.y point.nx point.ny point.q point.dq
!                point.qm g gd
!   with respect to varying inputs: pointd.q pointd.dq pointd.qm
!                point.x point.y point.nx point.ny point.q point.dq
!                point.qm
!  Differentiation of wall_dgx_pos in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: point.q point.dq point.qm
!	This subroutine evaluates the wall flux derivative dGs_pos
  SUBROUTINE WALL_DGX_POS_D_B(g, gb, gd, gdb, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: rhodb, u1db, u2db, prdb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txb, tyb, nxb, nyb
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: g_idb(4), g_kdb(4), gdb(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxb, delyb, detb, one_by_detb
    REAL*8 :: dels, deln
    REAL*8 :: delsb, delnb
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: sum_delx_delfdb(4), sum_dely_delfdb(4)
    REAL*8 :: dist, weights
    REAL*8 :: distb, weightsb
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: qtilde_idb(4), qtilde_kdb(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_ib(4), phi_kb(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: phi_idb(4), phi_kdb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxib(4), minib(4)
    REAL*8 :: maxid(4), minid(4)
    REAL*8 :: maxidb(4), minidb(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsb, deln_weightsb
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    REAL*8, DIMENSION(4) :: tempb1
    REAL*8, DIMENSION(4) :: tempb2
    REAL*8, DIMENSION(4) :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    REAL*8, DIMENSION(4) :: tempb5
    REAL*8, DIMENSION(4) :: tempb6
    REAL*8, DIMENSION(4) :: tempb7
    REAL*8, DIMENSION(4) :: tempb8
    REAL*8, DIMENSION(4) :: tempb9
    REAL*8, DIMENSION(4) :: tempb10
    REAL*8, DIMENSION(4) :: tempb11
    REAL*8, DIMENSION(4) :: tempb12
    INTEGER :: branch
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      CALL PUSHREAL8(dist)
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
!			Higher order accuracy using q-variables ..
      CALL PUSHREAL8ARRAY(qtilde_id, 4)
      qtilde_id = pointd%q(:, i) - 0.5d0*(delx*pointd%dq(1, :, i)+dely*&
&       pointd%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_kd, 4)
      qtilde_kd = pointd%q(:, k) - 0.5d0*(delx*pointd%dq(1, :, k)+dely*&
&       pointd%dq(2, :, k))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL PUSHREAL8ARRAY(phi_id, 4)
        CALL PUSHREAL8ARRAY(phi_i, 4)
        CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
        CALL PUSHREAL8ARRAY(phi_kd, 4)
        CALL PUSHREAL8ARRAY(phi_k, 4)
        CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
        qtilde_id = pointd%q(:, i) - 0.5d0*(phi_id*(delx*point%dq(1, :, &
&         i)+dely*point%dq(2, :, i))+phi_i*(delx*pointd%dq(1, :, i)+dely&
&         *pointd%dq(2, :, i)))
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_kd = pointd%q(:, k) - 0.5d0*(phi_kd*(delx*point%dq(1, :, &
&         k)+dely*point%dq(2, :, k))+phi_k*(delx*pointd%dq(1, :, k)+dely&
&         *pointd%dq(2, :, k)))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE_D(i, maxi, maxid)
        CALL MIN_Q_VALUE_D(i, mini, minid)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_id(r) = maxid(r)
            qtilde_i(r) = maxi(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_id(r) = minid(r)
            qtilde_i(r) = mini(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_kd(r) = maxid(r)
            qtilde_k(r) = maxi(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_kd(r) = minid(r)
            qtilde_k(r) = mini(r)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8(prd)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rhod)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2d)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1d)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL PUSHREAL8ARRAY(g_id, 4)
      CALL PUSHREAL8ARRAY(g_i, 4)
      CALL FLUX_QUAD_GXII_D(g_i, g_id, nx, ny, u1, u1d, u2, u2d, rho, &
&                     rhod, pr, prd)
      CALL PUSHREAL8(prd)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rhod)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2d)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1d)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL PUSHREAL8ARRAY(g_kd, 4)
      CALL PUSHREAL8ARRAY(g_k, 4)
      CALL FLUX_QUAD_GXII_D(g_k, g_kd, nx, ny, u1, u1d, u2, u2d, rho, &
&                     rhod, pr, prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id)
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    one_by_detb = SUM((sum_dely_sqr*sum_delx_delfd-sum_delx_dely*&
&     sum_dely_delfd)*gdb) + SUM((sum_delx_delf*sum_dely_sqr-&
&     sum_dely_delf*sum_delx_dely)*gb)
    tempb12 = one_by_det*gdb
    detb = -(one_by_detb/det**2)
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    tempb11 = one_by_det*gb
    sum_delx_delfb = sum_dely_sqr*tempb11
    sum_dely_sqrb = SUM(sum_delx_delfd*tempb12) + sum_delx_sqr*detb + &
&     SUM(sum_delx_delf*tempb11)
    sum_dely_delfb = -(sum_delx_dely*tempb11)
    sum_delx_delyb = -SUM(sum_dely_delfd*tempb12) - 2*sum_delx_dely*detb&
&     - SUM(sum_dely_delf*tempb11)
    sum_dely_delfdb = 0.0_8
    sum_delx_delfdb = 0.0_8
    sum_delx_delfdb = sum_dely_sqr*tempb12
    sum_dely_delfdb = -(sum_delx_dely*tempb12)
    sum_delx_sqrb = sum_dely_sqr*detb
    phi_idb = 0.0_8
    txb = 0.0_8
    tyb = 0.0_8
    g_idb = 0.0_8
    nxb = 0.0_8
    y_ib = 0.0_8
    nyb = 0.0_8
    g_ib = 0.0_8
    g_kb = 0.0_8
    phi_kdb = 0.0_8
    x_ib = 0.0_8
    phi_ib = 0.0_8
    phi_kb = 0.0_8
    g_kdb = 0.0_8
    DO j=point%xpos_nbhs(i),1,-1
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      delx = x_k - x_i
      y_k = point%y(k)
      dely = y_k - y_i
      deln = delx*nx + dely*ny
      weights = dist**power
      deln_weights = deln*weights
      deln_weightsb = SUM((g_kd-g_id)*sum_dely_delfdb) + SUM((g_k-g_i)*&
&       sum_dely_delfb)
      dels = delx*tx + dely*ty
      dels_weights = dels*weights
      g_kb = g_kb + dels_weights*sum_delx_delfb + deln_weights*&
&       sum_dely_delfb
      g_ib = g_ib - dels_weights*sum_delx_delfb - deln_weights*&
&       sum_dely_delfb
      g_kdb = g_kdb + dels_weights*sum_delx_delfdb + deln_weights*&
&       sum_dely_delfdb
      g_idb = g_idb - dels_weights*sum_delx_delfdb - deln_weights*&
&       sum_dely_delfdb
      dels_weightsb = SUM((g_kd-g_id)*sum_delx_delfdb) + SUM((g_k-g_i)*&
&       sum_delx_delfb)
      CALL POPREAL8ARRAY(g_k, 4)
      CALL POPREAL8ARRAY(g_kd, 4)
      CALL FLUX_QUAD_GXII_D_B(g_k, g_kb, g_kd, g_kdb, nx, nxb, ny, nyb, &
&                       u1, u1b, u1d, u1db, u2, u2b, u2d, u2db, rho, &
&                       rhob, rhod, rhodb, pr, prb, prd, prdb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u1d)
      CALL POPREAL8(u2)
      CALL POPREAL8(u2d)
      CALL POPREAL8(rho)
      CALL POPREAL8(rhod)
      CALL POPREAL8(pr)
      CALL POPREAL8(prd)
      CALL QTILDE_TO_PRIMITIVE_D_B(qtilde_k, qtilde_kb, qtilde_kd, &
&                            qtilde_kdb, u1, u1b, u1d, u1db, u2, u2b, &
&                            u2d, u2db, rho, rhob, rhod, rhodb, pr, prb&
&                            , prd, prdb)
      CALL POPREAL8ARRAY(g_i, 4)
      CALL POPREAL8ARRAY(g_id, 4)
      CALL FLUX_QUAD_GXII_D_B(g_i, g_ib, g_id, g_idb, nx, nxb, ny, nyb, &
&                       u1, u1b, u1d, u1db, u2, u2b, u2d, u2db, rho, &
&                       rhob, rhod, rhodb, pr, prb, prd, prdb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u1d)
      CALL POPREAL8(u2)
      CALL POPREAL8(u2d)
      CALL POPREAL8(rho)
      CALL POPREAL8(rhod)
      CALL POPREAL8(pr)
      CALL POPREAL8(prd)
      CALL QTILDE_TO_PRIMITIVE_D_B(qtilde_i, qtilde_ib, qtilde_id, &
&                            qtilde_idb, u1, u1b, u1d, u1db, u2, u2b, &
&                            u2d, u2db, rho, rhob, rhod, rhodb, pr, prb&
&                            , prd, prdb)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        minidb = 0.0_8
        minib = 0.0_8
        maxib = 0.0_8
        maxidb = 0.0_8
        DO r=4,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            minib(r) = minib(r) + qtilde_kb(r)
            qtilde_kb(r) = 0.0_8
            minidb(r) = minidb(r) + qtilde_kdb(r)
            qtilde_kdb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            maxib(r) = maxib(r) + qtilde_kb(r)
            qtilde_kb(r) = 0.0_8
            maxidb(r) = maxidb(r) + qtilde_kdb(r)
            qtilde_kdb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            minib(r) = minib(r) + qtilde_ib(r)
            qtilde_ib(r) = 0.0_8
            minidb(r) = minidb(r) + qtilde_idb(r)
            qtilde_idb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            maxib(r) = maxib(r) + qtilde_ib(r)
            qtilde_ib(r) = 0.0_8
            maxidb(r) = maxidb(r) + qtilde_idb(r)
            qtilde_idb(r) = 0.0_8
          END IF
        END DO
        CALL MIN_Q_VALUE_D_B(i, mini, minib, minid, minidb)
        CALL MAX_Q_VALUE_D_B(i, maxi, maxib, maxid, maxidb)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        tempb10 = -(0.5d0*qtilde_idb)
        tempb7 = phi_id*tempb10
        tempb8 = phi_i*tempb10
        tempb9 = -(0.5d0*phi_i*qtilde_ib)
        tempb4 = -(0.5d0*qtilde_kdb)
        tempb5 = phi_kd*tempb4
        tempb6 = phi_k*tempb4
        tempb3 = -(0.5d0*phi_k*qtilde_kb)
        pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
        phi_kb = phi_kb + (delx*pointd%dq(1, :, k)+dely*pointd%dq(2, :, &
&         k))*tempb4 - 0.5d0*(delx*point%dq(1, :, k)+dely*point%dq(2, :&
&         , k))*qtilde_kb
        delxb = SUM(point%dq(1, :, k)*tempb5) + SUM(pointd%dq(1, :, k)*&
&         tempb6) + SUM(point%dq(1, :, i)*tempb7) + SUM(pointd%dq(1, :, &
&         i)*tempb8) + SUM(point%dq(1, :, i)*tempb9) + SUM(point%dq(1, :&
&         , k)*tempb3)
        pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb3
        delyb = SUM(point%dq(2, :, k)*tempb5) + SUM(pointd%dq(2, :, k)*&
&         tempb6) + SUM(point%dq(2, :, i)*tempb7) + SUM(pointd%dq(2, :, &
&         i)*tempb8) + SUM(point%dq(2, :, i)*tempb9) + SUM(point%dq(2, :&
&         , k)*tempb3)
        pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb3
        pointdb%q(:, k) = pointdb%q(:, k) + qtilde_kdb
        phi_kdb = phi_kdb + (delx*point%dq(1, :, k)+dely*point%dq(2, :, &
&         k))*tempb4
        pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb5
        pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb5
        pointdb%dq(1, :, k) = pointdb%dq(1, :, k) + delx*tempb6
        pointdb%dq(2, :, k) = pointdb%dq(2, :, k) + dely*tempb6
        pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
        phi_ib = phi_ib + (delx*pointd%dq(1, :, i)+dely*pointd%dq(2, :, &
&         i))*tempb10 - 0.5d0*(delx*point%dq(1, :, i)+dely*point%dq(2, :&
&         , i))*qtilde_ib
        pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb9
        pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb9
        pointdb%q(:, i) = pointdb%q(:, i) + qtilde_idb
        phi_idb = phi_idb + (delx*point%dq(1, :, i)+dely*point%dq(2, :, &
&         i))*tempb10
        pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb7
        pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb7
        pointdb%dq(1, :, i) = pointdb%dq(1, :, i) + delx*tempb8
        pointdb%dq(2, :, i) = pointdb%dq(2, :, i) + dely*tempb8
        qtilde_kd = pointd%q(:, k) - 0.5d0*(delx*pointd%dq(1, :, k)+dely&
&         *pointd%dq(2, :, k))
        qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&         point%dq(2, :, k))
        CALL POPREAL8ARRAY(phi_k, 4)
        CALL POPREAL8ARRAY(phi_kd, 4)
        CALL VENKAT_LIMITER_D_B(qtilde_k, qtilde_kb, qtilde_kd, &
&                         qtilde_kdb, phi_k, phi_kb, phi_kd, phi_kdb, k)
        qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&         point%dq(2, :, i))
        qtilde_id = pointd%q(:, i) - 0.5d0*(delx*pointd%dq(1, :, i)+dely&
&         *pointd%dq(2, :, i))
        CALL POPREAL8ARRAY(phi_i, 4)
        CALL POPREAL8ARRAY(phi_id, 4)
        CALL VENKAT_LIMITER_D_B(qtilde_i, qtilde_ib, qtilde_id, &
&                         qtilde_idb, phi_i, phi_ib, phi_id, phi_idb, i)
      ELSE
        delxb = 0.0_8
        delyb = 0.0_8
      END IF
      deln_weightsb = deln_weightsb + deln*sum_dely_sqrb + dels*&
&       sum_delx_delyb
      dels_weightsb = dels_weightsb + dels*sum_delx_sqrb
      weightsb = dels*dels_weightsb + deln*deln_weightsb
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        distb = 0.0
      ELSE
        distb = power*dist**(power-1)*weightsb
      END IF
      arg1 = dels*dels + deln*deln
      IF (arg1 .EQ. 0.0) THEN
        arg1b = 0.0
      ELSE
        arg1b = distb/(2.D0*DSQRT(arg1))
      END IF
      delnb = weights*deln_weightsb + 2*deln*arg1b + deln_weights*&
&       sum_dely_sqrb
      delsb = dels_weights*sum_delx_sqrb + 2*dels*arg1b + weights*&
&       dels_weightsb + deln_weights*sum_delx_delyb
      tempb1 = -(0.5d0*qtilde_idb)
      tempb2 = -(0.5d0*qtilde_ib)
      tempb0 = -(0.5d0*qtilde_kdb)
      CALL POPREAL8ARRAY(qtilde_k, 4)
      tempb = -(0.5d0*qtilde_kb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      delxb = delxb + SUM(pointd%dq(1, :, k)*tempb0) + SUM(pointd%dq(1, &
&       :, i)*tempb1) + tx*delsb + nx*delnb + SUM(point%dq(1, :, i)*&
&       tempb2) + SUM(point%dq(1, :, k)*tempb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb
      delyb = delyb + SUM(pointd%dq(2, :, k)*tempb0) + SUM(pointd%dq(2, &
&       :, i)*tempb1) + ty*delsb + ny*delnb + SUM(point%dq(2, :, i)*&
&       tempb2) + SUM(point%dq(2, :, k)*tempb)
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb
      CALL POPREAL8ARRAY(qtilde_kd, 4)
      pointdb%q(:, k) = pointdb%q(:, k) + qtilde_kdb
      pointdb%dq(1, :, k) = pointdb%dq(1, :, k) + delx*tempb0
      pointdb%dq(2, :, k) = pointdb%dq(2, :, k) + dely*tempb0
      CALL POPREAL8ARRAY(qtilde_i, 4)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb2
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb2
      CALL POPREAL8ARRAY(qtilde_id, 4)
      pointdb%q(:, i) = pointdb%q(:, i) + qtilde_idb
      pointdb%dq(1, :, i) = pointdb%dq(1, :, i) + delx*tempb1
      pointdb%dq(2, :, i) = pointdb%dq(2, :, i) + dely*tempb1
      CALL POPREAL8(dist)
      nxb = nxb + delx*delnb
      nyb = nyb + dely*delnb
      txb = txb + delx*delsb
      tyb = tyb + dely*delsb
      y_kb = delyb
      y_ib = y_ib - delyb
      x_kb = delxb
      x_ib = x_ib - delxb
      pointb%y(k) = pointb%y(k) + y_kb
      pointb%x(k) = pointb%x(k) + x_kb
    END DO
    nxb = nxb - tyb
    nyb = nyb + txb
    pointb%ny(i) = pointb%ny(i) + nyb
    pointb%nx(i) = pointb%nx(i) + nxb
    pointb%y(i) = pointb%y(i) + y_ib
    pointb%x(i) = pointb%x(i) + x_ib
  END SUBROUTINE WALL_DGX_POS_D_B

!  Differentiation of wall_dgx_pos in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: point.q point.dq point.qm
!	This subroutine evaluates the wall flux derivative dGs_pos
  SUBROUTINE WALL_DGX_POS_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxid(4), minid(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
!			Higher order accuracy using q-variables ..
      qtilde_id = pointd%q(:, i) - 0.5d0*(delx*pointd%dq(1, :, i)+dely*&
&       pointd%dq(2, :, i))
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(delx*pointd%dq(1, :, k)+dely*&
&       pointd%dq(2, :, k))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
        CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
        qtilde_id = pointd%q(:, i) - 0.5d0*(phi_id*(delx*point%dq(1, :, &
&         i)+dely*point%dq(2, :, i))+phi_i*(delx*pointd%dq(1, :, i)+dely&
&         *pointd%dq(2, :, i)))
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_kd = pointd%q(:, k) - 0.5d0*(phi_kd*(delx*point%dq(1, :, &
&         k)+dely*point%dq(2, :, k))+phi_k*(delx*pointd%dq(1, :, k)+dely&
&         *pointd%dq(2, :, k)))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE_D(i, maxi, maxid)
        CALL MIN_Q_VALUE_D(i, mini, minid)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_id(r) = maxid(r)
            qtilde_i(r) = maxi(r)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_id(r) = minid(r)
            qtilde_i(r) = mini(r)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_kd(r) = maxid(r)
            qtilde_k(r) = maxi(r)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_kd(r) = minid(r)
            qtilde_k(r) = mini(r)
          END IF
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_QUAD_GXII_D(g_i, g_id, nx, ny, u1, u1d, u2, u2d, rho, &
&                     rhod, pr, prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_QUAD_GXII_D(g_k, g_kd, nx, ny, u1, u1d, u2, u2d, rho, &
&                     rhod, pr, prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id)
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    gd = one_by_det*(sum_dely_sqr*sum_delx_delfd-sum_delx_dely*&
&     sum_dely_delfd)
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGX_POS_D

!	This subroutine evaluates the wall flux derivative dGs_pos
  SUBROUTINE WALL_DGX_POS(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xpos_nbhs(i)
      k = point%xpos_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
!			Higher order accuracy using q-variables ..
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) qtilde_i(r) = maxi(r)
          IF (qtilde_i(r) .LT. mini(r)) qtilde_i(r) = mini(r)
          IF (qtilde_k(r) .GT. maxi(r)) qtilde_k(r) = maxi(r)
          IF (qtilde_k(r) .LT. mini(r)) qtilde_k(r) = mini(r)
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXII(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXII(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGX_POS

!  Differentiation of wall_dgx_neg_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: pointd.q pointd.dq pointd.qm
!                point.x point.y point.nx point.ny point.q point.dq
!                point.qm g gd
!   with respect to varying inputs: pointd.q pointd.dq pointd.qm
!                point.x point.y point.nx point.ny point.q point.dq
!                point.qm
!  Differentiation of wall_dgx_neg in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: point.q point.dq point.qm
!	This subroutine evaluates the wall flux derivative dGs_neg
  SUBROUTINE WALL_DGX_NEG_D_B(g, gb, gd, gdb, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: rhodb, u1db, u2db, prdb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txb, tyb, nxb, nyb
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: g_idb(4), g_kdb(4), gdb(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: delxb, delyb, detb
    REAL*8 :: dels, deln
    REAL*8 :: delsb, delnb
!		real*8 :: sum_delx_delx, sum_dely_dely
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: sum_delx_delfdb(4), sum_dely_delfdb(4)
    REAL*8 :: dist, weights
    REAL*8 :: distb, weightsb
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: qtilde_idb(4), qtilde_kdb(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_ib(4), phi_kb(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: phi_idb(4), phi_kdb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxib(4), minib(4)
    REAL*8 :: maxid(4), minid(4)
    REAL*8 :: maxidb(4), minidb(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsb, deln_weightsb
    REAL*8 :: one_by_det
    REAL*8 :: one_by_detb
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    REAL*8, DIMENSION(4) :: tempb1
    REAL*8, DIMENSION(4) :: tempb2
    REAL*8, DIMENSION(4) :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    REAL*8, DIMENSION(4) :: tempb5
    REAL*8, DIMENSION(4) :: tempb6
    REAL*8, DIMENSION(4) :: tempb7
    REAL*8, DIMENSION(4) :: tempb8
    REAL*8, DIMENSION(4) :: tempb9
    REAL*8, DIMENSION(4) :: tempb10
    REAL*8, DIMENSION(4) :: tempb11
    REAL*8, DIMENSION(4) :: tempb12
    INTEGER :: branch
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      CALL PUSHREAL8(dist)
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_id, 4)
      qtilde_id = pointd%q(:, i) - 0.5d0*(delx*pointd%dq(1, :, i)+dely*&
&       pointd%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_kd, 4)
      qtilde_kd = pointd%q(:, k) - 0.5d0*(delx*pointd%dq(1, :, k)+dely*&
&       pointd%dq(2, :, k))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL PUSHREAL8ARRAY(phi_id, 4)
        CALL PUSHREAL8ARRAY(phi_i, 4)
        CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
        CALL PUSHREAL8ARRAY(phi_kd, 4)
        CALL PUSHREAL8ARRAY(phi_k, 4)
        CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
        qtilde_id = pointd%q(:, i) - 0.5d0*(phi_id*(delx*point%dq(1, :, &
&         i)+dely*point%dq(2, :, i))+phi_i*(delx*pointd%dq(1, :, i)+dely&
&         *pointd%dq(2, :, i)))
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_kd = pointd%q(:, k) - 0.5d0*(phi_kd*(delx*point%dq(1, :, &
&         k)+dely*point%dq(2, :, k))+phi_k*(delx*pointd%dq(1, :, k)+dely&
&         *pointd%dq(2, :, k)))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE_D(i, maxi, maxid)
        CALL MIN_Q_VALUE_D(i, mini, minid)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_id(r) = maxid(r)
            qtilde_i(r) = maxi(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_id(r) = minid(r)
            qtilde_i(r) = mini(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_kd(r) = maxid(r)
            qtilde_k(r) = maxi(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_kd(r) = minid(r)
            qtilde_k(r) = mini(r)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8(prd)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rhod)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2d)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1d)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL PUSHREAL8ARRAY(g_id, 4)
      CALL PUSHREAL8ARRAY(g_i, 4)
      CALL FLUX_QUAD_GXI_D(g_i, g_id, nx, ny, u1, u1d, u2, u2d, rho, &
&                    rhod, pr, prd)
      CALL PUSHREAL8(prd)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rhod)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2d)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1d)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL PUSHREAL8ARRAY(g_kd, 4)
      CALL PUSHREAL8ARRAY(g_k, 4)
      CALL FLUX_QUAD_GXI_D(g_k, g_kd, nx, ny, u1, u1d, u2, u2d, rho, &
&                    rhod, pr, prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id)
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    one_by_detb = SUM((sum_dely_sqr*sum_delx_delfd-sum_delx_dely*&
&     sum_dely_delfd)*gdb) + SUM((sum_delx_delf*sum_dely_sqr-&
&     sum_dely_delf*sum_delx_dely)*gb)
    tempb12 = one_by_det*gdb
    detb = -(one_by_detb/det**2)
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    tempb11 = one_by_det*gb
    sum_delx_delfb = sum_dely_sqr*tempb11
    sum_dely_sqrb = SUM(sum_delx_delfd*tempb12) + sum_delx_sqr*detb + &
&     SUM(sum_delx_delf*tempb11)
    sum_dely_delfb = -(sum_delx_dely*tempb11)
    sum_delx_delyb = -SUM(sum_dely_delfd*tempb12) - 2*sum_delx_dely*detb&
&     - SUM(sum_dely_delf*tempb11)
    sum_dely_delfdb = 0.0_8
    sum_delx_delfdb = 0.0_8
    sum_delx_delfdb = sum_dely_sqr*tempb12
    sum_dely_delfdb = -(sum_delx_dely*tempb12)
    sum_delx_sqrb = sum_dely_sqr*detb
    phi_idb = 0.0_8
    txb = 0.0_8
    tyb = 0.0_8
    g_idb = 0.0_8
    nxb = 0.0_8
    y_ib = 0.0_8
    nyb = 0.0_8
    g_ib = 0.0_8
    g_kb = 0.0_8
    phi_kdb = 0.0_8
    x_ib = 0.0_8
    phi_ib = 0.0_8
    phi_kb = 0.0_8
    g_kdb = 0.0_8
    DO j=point%xneg_nbhs(i),1,-1
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      delx = x_k - x_i
      y_k = point%y(k)
      dely = y_k - y_i
      deln = delx*nx + dely*ny
      weights = dist**power
      deln_weights = deln*weights
      deln_weightsb = SUM((g_kd-g_id)*sum_dely_delfdb) + SUM((g_k-g_i)*&
&       sum_dely_delfb)
      dels = delx*tx + dely*ty
      dels_weights = dels*weights
      g_kb = g_kb + dels_weights*sum_delx_delfb + deln_weights*&
&       sum_dely_delfb
      g_ib = g_ib - dels_weights*sum_delx_delfb - deln_weights*&
&       sum_dely_delfb
      g_kdb = g_kdb + dels_weights*sum_delx_delfdb + deln_weights*&
&       sum_dely_delfdb
      g_idb = g_idb - dels_weights*sum_delx_delfdb - deln_weights*&
&       sum_dely_delfdb
      dels_weightsb = SUM((g_kd-g_id)*sum_delx_delfdb) + SUM((g_k-g_i)*&
&       sum_delx_delfb)
      CALL POPREAL8ARRAY(g_k, 4)
      CALL POPREAL8ARRAY(g_kd, 4)
      CALL FLUX_QUAD_GXI_D_B(g_k, g_kb, g_kd, g_kdb, nx, nxb, ny, nyb, &
&                      u1, u1b, u1d, u1db, u2, u2b, u2d, u2db, rho, rhob&
&                      , rhod, rhodb, pr, prb, prd, prdb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u1d)
      CALL POPREAL8(u2)
      CALL POPREAL8(u2d)
      CALL POPREAL8(rho)
      CALL POPREAL8(rhod)
      CALL POPREAL8(pr)
      CALL POPREAL8(prd)
      CALL QTILDE_TO_PRIMITIVE_D_B(qtilde_k, qtilde_kb, qtilde_kd, &
&                            qtilde_kdb, u1, u1b, u1d, u1db, u2, u2b, &
&                            u2d, u2db, rho, rhob, rhod, rhodb, pr, prb&
&                            , prd, prdb)
      CALL POPREAL8ARRAY(g_i, 4)
      CALL POPREAL8ARRAY(g_id, 4)
      CALL FLUX_QUAD_GXI_D_B(g_i, g_ib, g_id, g_idb, nx, nxb, ny, nyb, &
&                      u1, u1b, u1d, u1db, u2, u2b, u2d, u2db, rho, rhob&
&                      , rhod, rhodb, pr, prb, prd, prdb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u1d)
      CALL POPREAL8(u2)
      CALL POPREAL8(u2d)
      CALL POPREAL8(rho)
      CALL POPREAL8(rhod)
      CALL POPREAL8(pr)
      CALL POPREAL8(prd)
      CALL QTILDE_TO_PRIMITIVE_D_B(qtilde_i, qtilde_ib, qtilde_id, &
&                            qtilde_idb, u1, u1b, u1d, u1db, u2, u2b, &
&                            u2d, u2db, rho, rhob, rhod, rhodb, pr, prb&
&                            , prd, prdb)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        minidb = 0.0_8
        minib = 0.0_8
        maxib = 0.0_8
        maxidb = 0.0_8
        DO r=4,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            minib(r) = minib(r) + qtilde_kb(r)
            qtilde_kb(r) = 0.0_8
            minidb(r) = minidb(r) + qtilde_kdb(r)
            qtilde_kdb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            maxib(r) = maxib(r) + qtilde_kb(r)
            qtilde_kb(r) = 0.0_8
            maxidb(r) = maxidb(r) + qtilde_kdb(r)
            qtilde_kdb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            minib(r) = minib(r) + qtilde_ib(r)
            qtilde_ib(r) = 0.0_8
            minidb(r) = minidb(r) + qtilde_idb(r)
            qtilde_idb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            maxib(r) = maxib(r) + qtilde_ib(r)
            qtilde_ib(r) = 0.0_8
            maxidb(r) = maxidb(r) + qtilde_idb(r)
            qtilde_idb(r) = 0.0_8
          END IF
        END DO
        CALL MIN_Q_VALUE_D_B(i, mini, minib, minid, minidb)
        CALL MAX_Q_VALUE_D_B(i, maxi, maxib, maxid, maxidb)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        tempb10 = -(0.5d0*qtilde_idb)
        tempb7 = phi_id*tempb10
        tempb8 = phi_i*tempb10
        tempb9 = -(0.5d0*phi_i*qtilde_ib)
        tempb4 = -(0.5d0*qtilde_kdb)
        tempb5 = phi_kd*tempb4
        tempb6 = phi_k*tempb4
        tempb3 = -(0.5d0*phi_k*qtilde_kb)
        pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
        phi_kb = phi_kb + (delx*pointd%dq(1, :, k)+dely*pointd%dq(2, :, &
&         k))*tempb4 - 0.5d0*(delx*point%dq(1, :, k)+dely*point%dq(2, :&
&         , k))*qtilde_kb
        delxb = SUM(point%dq(1, :, k)*tempb5) + SUM(pointd%dq(1, :, k)*&
&         tempb6) + SUM(point%dq(1, :, i)*tempb7) + SUM(pointd%dq(1, :, &
&         i)*tempb8) + SUM(point%dq(1, :, i)*tempb9) + SUM(point%dq(1, :&
&         , k)*tempb3)
        pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb3
        delyb = SUM(point%dq(2, :, k)*tempb5) + SUM(pointd%dq(2, :, k)*&
&         tempb6) + SUM(point%dq(2, :, i)*tempb7) + SUM(pointd%dq(2, :, &
&         i)*tempb8) + SUM(point%dq(2, :, i)*tempb9) + SUM(point%dq(2, :&
&         , k)*tempb3)
        pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb3
        pointdb%q(:, k) = pointdb%q(:, k) + qtilde_kdb
        phi_kdb = phi_kdb + (delx*point%dq(1, :, k)+dely*point%dq(2, :, &
&         k))*tempb4
        pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb5
        pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb5
        pointdb%dq(1, :, k) = pointdb%dq(1, :, k) + delx*tempb6
        pointdb%dq(2, :, k) = pointdb%dq(2, :, k) + dely*tempb6
        pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
        phi_ib = phi_ib + (delx*pointd%dq(1, :, i)+dely*pointd%dq(2, :, &
&         i))*tempb10 - 0.5d0*(delx*point%dq(1, :, i)+dely*point%dq(2, :&
&         , i))*qtilde_ib
        pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb9
        pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb9
        pointdb%q(:, i) = pointdb%q(:, i) + qtilde_idb
        phi_idb = phi_idb + (delx*point%dq(1, :, i)+dely*point%dq(2, :, &
&         i))*tempb10
        pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb7
        pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb7
        pointdb%dq(1, :, i) = pointdb%dq(1, :, i) + delx*tempb8
        pointdb%dq(2, :, i) = pointdb%dq(2, :, i) + dely*tempb8
        qtilde_kd = pointd%q(:, k) - 0.5d0*(delx*pointd%dq(1, :, k)+dely&
&         *pointd%dq(2, :, k))
        qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&         point%dq(2, :, k))
        CALL POPREAL8ARRAY(phi_k, 4)
        CALL POPREAL8ARRAY(phi_kd, 4)
        CALL VENKAT_LIMITER_D_B(qtilde_k, qtilde_kb, qtilde_kd, &
&                         qtilde_kdb, phi_k, phi_kb, phi_kd, phi_kdb, k)
        qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&         point%dq(2, :, i))
        qtilde_id = pointd%q(:, i) - 0.5d0*(delx*pointd%dq(1, :, i)+dely&
&         *pointd%dq(2, :, i))
        CALL POPREAL8ARRAY(phi_i, 4)
        CALL POPREAL8ARRAY(phi_id, 4)
        CALL VENKAT_LIMITER_D_B(qtilde_i, qtilde_ib, qtilde_id, &
&                         qtilde_idb, phi_i, phi_ib, phi_id, phi_idb, i)
      ELSE
        delxb = 0.0_8
        delyb = 0.0_8
      END IF
      deln_weightsb = deln_weightsb + deln*sum_dely_sqrb + dels*&
&       sum_delx_delyb
      dels_weightsb = dels_weightsb + dels*sum_delx_sqrb
      weightsb = dels*dels_weightsb + deln*deln_weightsb
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        distb = 0.0
      ELSE
        distb = power*dist**(power-1)*weightsb
      END IF
      arg1 = dels*dels + deln*deln
      IF (arg1 .EQ. 0.0) THEN
        arg1b = 0.0
      ELSE
        arg1b = distb/(2.D0*DSQRT(arg1))
      END IF
      delnb = weights*deln_weightsb + 2*deln*arg1b + deln_weights*&
&       sum_dely_sqrb
      delsb = dels_weights*sum_delx_sqrb + 2*dels*arg1b + weights*&
&       dels_weightsb + deln_weights*sum_delx_delyb
      tempb1 = -(0.5d0*qtilde_idb)
      tempb2 = -(0.5d0*qtilde_ib)
      tempb0 = -(0.5d0*qtilde_kdb)
      CALL POPREAL8ARRAY(qtilde_k, 4)
      tempb = -(0.5d0*qtilde_kb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      delxb = delxb + SUM(pointd%dq(1, :, k)*tempb0) + SUM(pointd%dq(1, &
&       :, i)*tempb1) + tx*delsb + nx*delnb + SUM(point%dq(1, :, i)*&
&       tempb2) + SUM(point%dq(1, :, k)*tempb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb
      delyb = delyb + SUM(pointd%dq(2, :, k)*tempb0) + SUM(pointd%dq(2, &
&       :, i)*tempb1) + ty*delsb + ny*delnb + SUM(point%dq(2, :, i)*&
&       tempb2) + SUM(point%dq(2, :, k)*tempb)
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb
      CALL POPREAL8ARRAY(qtilde_kd, 4)
      pointdb%q(:, k) = pointdb%q(:, k) + qtilde_kdb
      pointdb%dq(1, :, k) = pointdb%dq(1, :, k) + delx*tempb0
      pointdb%dq(2, :, k) = pointdb%dq(2, :, k) + dely*tempb0
      CALL POPREAL8ARRAY(qtilde_i, 4)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb2
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb2
      CALL POPREAL8ARRAY(qtilde_id, 4)
      pointdb%q(:, i) = pointdb%q(:, i) + qtilde_idb
      pointdb%dq(1, :, i) = pointdb%dq(1, :, i) + delx*tempb1
      pointdb%dq(2, :, i) = pointdb%dq(2, :, i) + dely*tempb1
      CALL POPREAL8(dist)
      nxb = nxb + delx*delnb
      nyb = nyb + dely*delnb
      txb = txb + delx*delsb
      tyb = tyb + dely*delsb
      y_kb = delyb
      y_ib = y_ib - delyb
      x_kb = delxb
      x_ib = x_ib - delxb
      pointb%y(k) = pointb%y(k) + y_kb
      pointb%x(k) = pointb%x(k) + x_kb
    END DO
    nxb = nxb - tyb
    nyb = nyb + txb
    pointb%ny(i) = pointb%ny(i) + nyb
    pointb%nx(i) = pointb%nx(i) + nxb
    pointb%y(i) = pointb%y(i) + y_ib
    pointb%x(i) = pointb%x(i) + x_ib
  END SUBROUTINE WALL_DGX_NEG_D_B

!  Differentiation of wall_dgx_neg in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: point.q point.dq point.qm
!	This subroutine evaluates the wall flux derivative dGs_neg
  SUBROUTINE WALL_DGX_NEG_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: dels, deln
!		real*8 :: sum_delx_delx, sum_dely_dely
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxid(4), minid(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(delx*pointd%dq(1, :, i)+dely*&
&       pointd%dq(2, :, i))
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(delx*pointd%dq(1, :, k)+dely*&
&       pointd%dq(2, :, k))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
        CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
        qtilde_id = pointd%q(:, i) - 0.5d0*(phi_id*(delx*point%dq(1, :, &
&         i)+dely*point%dq(2, :, i))+phi_i*(delx*pointd%dq(1, :, i)+dely&
&         *pointd%dq(2, :, i)))
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_kd = pointd%q(:, k) - 0.5d0*(phi_kd*(delx*point%dq(1, :, &
&         k)+dely*point%dq(2, :, k))+phi_k*(delx*pointd%dq(1, :, k)+dely&
&         *pointd%dq(2, :, k)))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE_D(i, maxi, maxid)
        CALL MIN_Q_VALUE_D(i, mini, minid)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_id(r) = maxid(r)
            qtilde_i(r) = maxi(r)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_id(r) = minid(r)
            qtilde_i(r) = mini(r)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_kd(r) = maxid(r)
            qtilde_k(r) = maxi(r)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_kd(r) = minid(r)
            qtilde_k(r) = mini(r)
          END IF
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_QUAD_GXI_D(g_i, g_id, nx, ny, u1, u1d, u2, u2d, rho, &
&                    rhod, pr, prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_QUAD_GXI_D(g_k, g_kd, nx, ny, u1, u1d, u2, u2d, rho, &
&                    rhod, pr, prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id)
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    gd = one_by_det*(sum_dely_sqr*sum_delx_delfd-sum_delx_dely*&
&     sum_dely_delfd)
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGX_NEG_D

!	This subroutine evaluates the wall flux derivative dGs_neg
  SUBROUTINE WALL_DGX_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det
    REAL*8 :: dels, deln
!		real*8 :: sum_delx_delx, sum_dely_dely
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: one_by_det
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%xneg_nbhs(i)
      k = point%xneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) qtilde_i(r) = maxi(r)
          IF (qtilde_i(r) .LT. mini(r)) qtilde_i(r) = mini(r)
          IF (qtilde_k(r) .GT. maxi(r)) qtilde_k(r) = maxi(r)
          IF (qtilde_k(r) .LT. mini(r)) qtilde_k(r) = mini(r)
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXI(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_QUAD_GXI(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_delx_delf*sum_dely_sqr-sum_dely_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGX_NEG

!  Differentiation of wall_dgy_neg_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: pointd.q pointd.dq pointd.qm
!                point.x point.y point.nx point.ny point.q point.dq
!                point.qm g gd
!   with respect to varying inputs: pointd.q pointd.dq pointd.qm
!                point.x point.y point.nx point.ny point.q point.dq
!                point.qm
!  Differentiation of wall_dgy_neg in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: point.q point.dq point.qm
  SUBROUTINE WALL_DGY_NEG_D_B(g, gb, gd, gdb, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhob, u1b, u2b, prb
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: rhodb, u1db, u2db, prdb
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: txb, tyb, nxb, nyb
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: x_ib, y_ib, x_kb, y_kb
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_ib(4), g_kb(4), gb(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: g_idb(4), g_kdb(4), gdb(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: delxb, delyb, detb, one_by_detb
    REAL*8 :: dels, deln
    REAL*8 :: delsb, delnb
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_sqrb, sum_dely_sqrb, sum_delx_delyb
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfb(4), sum_dely_delfb(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: sum_delx_delfdb(4), sum_dely_delfdb(4)
    REAL*8 :: dist, weights
    REAL*8 :: distb, weightsb
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_ib(4), qtilde_kb(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: qtilde_idb(4), qtilde_kdb(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_ib(4), phi_kb(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: phi_idb(4), phi_kdb(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxib(4), minib(4)
    REAL*8 :: maxid(4), minid(4)
    REAL*8 :: maxidb(4), minidb(4)
    REAL*8 :: dels_weights, deln_weights
    REAL*8 :: dels_weightsb, deln_weightsb
    INTRINSIC DSQRT
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8, DIMENSION(4) :: tempb
    REAL*8, DIMENSION(4) :: tempb0
    REAL*8, DIMENSION(4) :: tempb1
    REAL*8, DIMENSION(4) :: tempb2
    REAL*8, DIMENSION(4) :: tempb3
    REAL*8, DIMENSION(4) :: tempb4
    REAL*8, DIMENSION(4) :: tempb5
    REAL*8, DIMENSION(4) :: tempb6
    REAL*8, DIMENSION(4) :: tempb7
    REAL*8, DIMENSION(4) :: tempb8
    REAL*8, DIMENSION(4) :: tempb9
    REAL*8, DIMENSION(4) :: tempb10
    REAL*8, DIMENSION(4) :: tempb11
    REAL*8, DIMENSION(4) :: tempb12
    INTEGER :: branch
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%yneg_nbhs(i)
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      CALL PUSHREAL8(dist)
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      CALL PUSHREAL8ARRAY(qtilde_id, 4)
      qtilde_id = pointd%q(:, i) - 0.5d0*(delx*pointd%dq(1, :, i)+dely*&
&       pointd%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_i, 4)
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      CALL PUSHREAL8ARRAY(qtilde_kd, 4)
      qtilde_kd = pointd%q(:, k) - 0.5d0*(delx*pointd%dq(1, :, k)+dely*&
&       pointd%dq(2, :, k))
      CALL PUSHREAL8ARRAY(qtilde_k, 4)
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL PUSHREAL8ARRAY(phi_id, 4)
        CALL PUSHREAL8ARRAY(phi_i, 4)
        CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
        CALL PUSHREAL8ARRAY(phi_kd, 4)
        CALL PUSHREAL8ARRAY(phi_k, 4)
        CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
        qtilde_id = pointd%q(:, i) - 0.5d0*(phi_id*(delx*point%dq(1, :, &
&         i)+dely*point%dq(2, :, i))+phi_i*(delx*pointd%dq(1, :, i)+dely&
&         *pointd%dq(2, :, i)))
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_kd = pointd%q(:, k) - 0.5d0*(phi_kd*(delx*point%dq(1, :, &
&         k)+dely*point%dq(2, :, k))+phi_k*(delx*pointd%dq(1, :, k)+dely&
&         *pointd%dq(2, :, k)))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE_D(i, maxi, maxid)
        CALL MIN_Q_VALUE_D(i, mini, minid)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_id(r) = maxid(r)
            qtilde_i(r) = maxi(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_id(r) = minid(r)
            qtilde_i(r) = mini(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_kd(r) = maxid(r)
            qtilde_k(r) = maxi(r)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_kd(r) = minid(r)
            qtilde_k(r) = mini(r)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8(prd)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rhod)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2d)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1d)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL PUSHREAL8ARRAY(g_id, 4)
      CALL PUSHREAL8ARRAY(g_i, 4)
      CALL FLUX_GYN_D(g_i, g_id, nx, ny, u1, u1d, u2, u2d, rho, rhod, pr&
&               , prd)
      CALL PUSHREAL8(prd)
      CALL PUSHREAL8(pr)
      CALL PUSHREAL8(rhod)
      CALL PUSHREAL8(rho)
      CALL PUSHREAL8(u2d)
      CALL PUSHREAL8(u2)
      CALL PUSHREAL8(u1d)
      CALL PUSHREAL8(u1)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL PUSHREAL8ARRAY(g_kd, 4)
      CALL PUSHREAL8ARRAY(g_k, 4)
      CALL FLUX_GYN_D(g_k, g_kd, nx, ny, u1, u1d, u2, u2d, rho, rhod, pr&
&               , prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id)
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    one_by_detb = SUM((sum_delx_sqr*sum_dely_delfd-sum_delx_dely*&
&     sum_delx_delfd)*gdb) + SUM((sum_dely_delf*sum_delx_sqr-&
&     sum_delx_delf*sum_delx_dely)*gb)
    tempb12 = one_by_det*gdb
    detb = -(one_by_detb/det**2)
    sum_dely_delfb = 0.0_8
    sum_delx_delfb = 0.0_8
    tempb11 = one_by_det*gb
    sum_dely_delfb = sum_delx_sqr*tempb11
    sum_delx_sqrb = SUM(sum_dely_delfd*tempb12) + sum_dely_sqr*detb + &
&     SUM(sum_dely_delf*tempb11)
    sum_delx_delfb = -(sum_delx_dely*tempb11)
    sum_delx_delyb = -SUM(sum_delx_delfd*tempb12) - 2*sum_delx_dely*detb&
&     - SUM(sum_delx_delf*tempb11)
    sum_dely_delfdb = 0.0_8
    sum_delx_delfdb = 0.0_8
    sum_dely_delfdb = sum_delx_sqr*tempb12
    sum_delx_delfdb = -(sum_delx_dely*tempb12)
    sum_dely_sqrb = sum_delx_sqr*detb
    phi_idb = 0.0_8
    txb = 0.0_8
    tyb = 0.0_8
    g_idb = 0.0_8
    nxb = 0.0_8
    y_ib = 0.0_8
    nyb = 0.0_8
    g_ib = 0.0_8
    g_kb = 0.0_8
    phi_kdb = 0.0_8
    x_ib = 0.0_8
    phi_ib = 0.0_8
    phi_kb = 0.0_8
    g_kdb = 0.0_8
    DO j=point%yneg_nbhs(i),1,-1
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      delx = x_k - x_i
      y_k = point%y(k)
      dely = y_k - y_i
      deln = delx*nx + dely*ny
      weights = dist**power
      deln_weights = deln*weights
      deln_weightsb = SUM((g_kd-g_id)*sum_dely_delfdb) + SUM((g_k-g_i)*&
&       sum_dely_delfb)
      dels = delx*tx + dely*ty
      dels_weights = dels*weights
      g_kb = g_kb + dels_weights*sum_delx_delfb + deln_weights*&
&       sum_dely_delfb
      g_ib = g_ib - dels_weights*sum_delx_delfb - deln_weights*&
&       sum_dely_delfb
      g_kdb = g_kdb + dels_weights*sum_delx_delfdb + deln_weights*&
&       sum_dely_delfdb
      g_idb = g_idb - dels_weights*sum_delx_delfdb - deln_weights*&
&       sum_dely_delfdb
      dels_weightsb = SUM((g_kd-g_id)*sum_delx_delfdb) + SUM((g_k-g_i)*&
&       sum_delx_delfb)
      CALL POPREAL8ARRAY(g_k, 4)
      CALL POPREAL8ARRAY(g_kd, 4)
      CALL FLUX_GYN_D_B(g_k, g_kb, g_kd, g_kdb, nx, nxb, ny, nyb, u1, &
&                 u1b, u1d, u1db, u2, u2b, u2d, u2db, rho, rhob, rhod, &
&                 rhodb, pr, prb, prd, prdb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u1d)
      CALL POPREAL8(u2)
      CALL POPREAL8(u2d)
      CALL POPREAL8(rho)
      CALL POPREAL8(rhod)
      CALL POPREAL8(pr)
      CALL POPREAL8(prd)
      CALL QTILDE_TO_PRIMITIVE_D_B(qtilde_k, qtilde_kb, qtilde_kd, &
&                            qtilde_kdb, u1, u1b, u1d, u1db, u2, u2b, &
&                            u2d, u2db, rho, rhob, rhod, rhodb, pr, prb&
&                            , prd, prdb)
      CALL POPREAL8ARRAY(g_i, 4)
      CALL POPREAL8ARRAY(g_id, 4)
      CALL FLUX_GYN_D_B(g_i, g_ib, g_id, g_idb, nx, nxb, ny, nyb, u1, &
&                 u1b, u1d, u1db, u2, u2b, u2d, u2db, rho, rhob, rhod, &
&                 rhodb, pr, prb, prd, prdb)
      CALL POPREAL8(u1)
      CALL POPREAL8(u1d)
      CALL POPREAL8(u2)
      CALL POPREAL8(u2d)
      CALL POPREAL8(rho)
      CALL POPREAL8(rhod)
      CALL POPREAL8(pr)
      CALL POPREAL8(prd)
      CALL QTILDE_TO_PRIMITIVE_D_B(qtilde_i, qtilde_ib, qtilde_id, &
&                            qtilde_idb, u1, u1b, u1d, u1db, u2, u2b, &
&                            u2d, u2db, rho, rhob, rhod, rhodb, pr, prb&
&                            , prd, prdb)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        minidb = 0.0_8
        minib = 0.0_8
        maxib = 0.0_8
        maxidb = 0.0_8
        DO r=4,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            minib(r) = minib(r) + qtilde_kb(r)
            qtilde_kb(r) = 0.0_8
            minidb(r) = minidb(r) + qtilde_kdb(r)
            qtilde_kdb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            maxib(r) = maxib(r) + qtilde_kb(r)
            qtilde_kb(r) = 0.0_8
            maxidb(r) = maxidb(r) + qtilde_kdb(r)
            qtilde_kdb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            minib(r) = minib(r) + qtilde_ib(r)
            qtilde_ib(r) = 0.0_8
            minidb(r) = minidb(r) + qtilde_idb(r)
            qtilde_idb(r) = 0.0_8
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            maxib(r) = maxib(r) + qtilde_ib(r)
            qtilde_ib(r) = 0.0_8
            maxidb(r) = maxidb(r) + qtilde_idb(r)
            qtilde_idb(r) = 0.0_8
          END IF
        END DO
        CALL MIN_Q_VALUE_D_B(i, mini, minib, minid, minidb)
        CALL MAX_Q_VALUE_D_B(i, maxi, maxib, maxid, maxidb)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        tempb10 = -(0.5d0*qtilde_idb)
        tempb7 = phi_id*tempb10
        tempb8 = phi_i*tempb10
        tempb9 = -(0.5d0*phi_i*qtilde_ib)
        tempb4 = -(0.5d0*qtilde_kdb)
        tempb5 = phi_kd*tempb4
        tempb6 = phi_k*tempb4
        tempb3 = -(0.5d0*phi_k*qtilde_kb)
        pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
        phi_kb = phi_kb + (delx*pointd%dq(1, :, k)+dely*pointd%dq(2, :, &
&         k))*tempb4 - 0.5d0*(delx*point%dq(1, :, k)+dely*point%dq(2, :&
&         , k))*qtilde_kb
        delxb = SUM(point%dq(1, :, k)*tempb5) + SUM(pointd%dq(1, :, k)*&
&         tempb6) + SUM(point%dq(1, :, i)*tempb7) + SUM(pointd%dq(1, :, &
&         i)*tempb8) + SUM(point%dq(1, :, i)*tempb9) + SUM(point%dq(1, :&
&         , k)*tempb3)
        pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb3
        delyb = SUM(point%dq(2, :, k)*tempb5) + SUM(pointd%dq(2, :, k)*&
&         tempb6) + SUM(point%dq(2, :, i)*tempb7) + SUM(pointd%dq(2, :, &
&         i)*tempb8) + SUM(point%dq(2, :, i)*tempb9) + SUM(point%dq(2, :&
&         , k)*tempb3)
        pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb3
        pointdb%q(:, k) = pointdb%q(:, k) + qtilde_kdb
        phi_kdb = phi_kdb + (delx*point%dq(1, :, k)+dely*point%dq(2, :, &
&         k))*tempb4
        pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb5
        pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb5
        pointdb%dq(1, :, k) = pointdb%dq(1, :, k) + delx*tempb6
        pointdb%dq(2, :, k) = pointdb%dq(2, :, k) + dely*tempb6
        pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
        phi_ib = phi_ib + (delx*pointd%dq(1, :, i)+dely*pointd%dq(2, :, &
&         i))*tempb10 - 0.5d0*(delx*point%dq(1, :, i)+dely*point%dq(2, :&
&         , i))*qtilde_ib
        pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb9
        pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb9
        pointdb%q(:, i) = pointdb%q(:, i) + qtilde_idb
        phi_idb = phi_idb + (delx*point%dq(1, :, i)+dely*point%dq(2, :, &
&         i))*tempb10
        pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb7
        pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb7
        pointdb%dq(1, :, i) = pointdb%dq(1, :, i) + delx*tempb8
        pointdb%dq(2, :, i) = pointdb%dq(2, :, i) + dely*tempb8
        qtilde_kd = pointd%q(:, k) - 0.5d0*(delx*pointd%dq(1, :, k)+dely&
&         *pointd%dq(2, :, k))
        qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&         point%dq(2, :, k))
        CALL POPREAL8ARRAY(phi_k, 4)
        CALL POPREAL8ARRAY(phi_kd, 4)
        CALL VENKAT_LIMITER_D_B(qtilde_k, qtilde_kb, qtilde_kd, &
&                         qtilde_kdb, phi_k, phi_kb, phi_kd, phi_kdb, k)
        qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&         point%dq(2, :, i))
        qtilde_id = pointd%q(:, i) - 0.5d0*(delx*pointd%dq(1, :, i)+dely&
&         *pointd%dq(2, :, i))
        CALL POPREAL8ARRAY(phi_i, 4)
        CALL POPREAL8ARRAY(phi_id, 4)
        CALL VENKAT_LIMITER_D_B(qtilde_i, qtilde_ib, qtilde_id, &
&                         qtilde_idb, phi_i, phi_ib, phi_id, phi_idb, i)
      ELSE
        delxb = 0.0_8
        delyb = 0.0_8
      END IF
      deln_weightsb = deln_weightsb + deln*sum_dely_sqrb + dels*&
&       sum_delx_delyb
      dels_weightsb = dels_weightsb + dels*sum_delx_sqrb
      weightsb = dels*dels_weightsb + deln*deln_weightsb
      IF (dist .LE. 0.0 .AND. (power .EQ. 0.0 .OR. power .NE. INT(power)&
&         )) THEN
        distb = 0.0
      ELSE
        distb = power*dist**(power-1)*weightsb
      END IF
      arg1 = dels*dels + deln*deln
      IF (arg1 .EQ. 0.0) THEN
        arg1b = 0.0
      ELSE
        arg1b = distb/(2.D0*DSQRT(arg1))
      END IF
      delnb = weights*deln_weightsb + 2*deln*arg1b + deln_weights*&
&       sum_dely_sqrb
      delsb = dels_weights*sum_delx_sqrb + 2*dels*arg1b + weights*&
&       dels_weightsb + deln_weights*sum_delx_delyb
      tempb1 = -(0.5d0*qtilde_idb)
      tempb2 = -(0.5d0*qtilde_ib)
      tempb0 = -(0.5d0*qtilde_kdb)
      CALL POPREAL8ARRAY(qtilde_k, 4)
      tempb = -(0.5d0*qtilde_kb)
      pointb%q(:, k) = pointb%q(:, k) + qtilde_kb
      delxb = delxb + SUM(pointd%dq(1, :, k)*tempb0) + SUM(pointd%dq(1, &
&       :, i)*tempb1) + tx*delsb + nx*delnb + SUM(point%dq(1, :, i)*&
&       tempb2) + SUM(point%dq(1, :, k)*tempb)
      pointb%dq(1, :, k) = pointb%dq(1, :, k) + delx*tempb
      delyb = delyb + SUM(pointd%dq(2, :, k)*tempb0) + SUM(pointd%dq(2, &
&       :, i)*tempb1) + ty*delsb + ny*delnb + SUM(point%dq(2, :, i)*&
&       tempb2) + SUM(point%dq(2, :, k)*tempb)
      pointb%dq(2, :, k) = pointb%dq(2, :, k) + dely*tempb
      CALL POPREAL8ARRAY(qtilde_kd, 4)
      pointdb%q(:, k) = pointdb%q(:, k) + qtilde_kdb
      pointdb%dq(1, :, k) = pointdb%dq(1, :, k) + delx*tempb0
      pointdb%dq(2, :, k) = pointdb%dq(2, :, k) + dely*tempb0
      CALL POPREAL8ARRAY(qtilde_i, 4)
      pointb%q(:, i) = pointb%q(:, i) + qtilde_ib
      pointb%dq(1, :, i) = pointb%dq(1, :, i) + delx*tempb2
      pointb%dq(2, :, i) = pointb%dq(2, :, i) + dely*tempb2
      CALL POPREAL8ARRAY(qtilde_id, 4)
      pointdb%q(:, i) = pointdb%q(:, i) + qtilde_idb
      pointdb%dq(1, :, i) = pointdb%dq(1, :, i) + delx*tempb1
      pointdb%dq(2, :, i) = pointdb%dq(2, :, i) + dely*tempb1
      CALL POPREAL8(dist)
      nxb = nxb + delx*delnb
      nyb = nyb + dely*delnb
      txb = txb + delx*delsb
      tyb = tyb + dely*delsb
      y_kb = delyb
      y_ib = y_ib - delyb
      x_kb = delxb
      x_ib = x_ib - delxb
      pointb%y(k) = pointb%y(k) + y_kb
      pointb%x(k) = pointb%x(k) + x_kb
    END DO
    nxb = nxb - tyb
    nyb = nyb + txb
    pointb%ny(i) = pointb%ny(i) + nyb
    pointb%nx(i) = pointb%nx(i) + nxb
    pointb%y(i) = pointb%y(i) + y_ib
    pointb%x(i) = pointb%x(i) + x_ib
  END SUBROUTINE WALL_DGY_NEG_D_B

!  Differentiation of wall_dgy_neg in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: g
!   with respect to varying inputs: point.q point.dq point.qm
  SUBROUTINE WALL_DGY_NEG_D(g, gd, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: rhod, u1d, u2d, prd
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: g_id(4), g_kd(4), gd(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: sum_delx_delfd(4), sum_dely_delfd(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: qtilde_id(4), qtilde_kd(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: phi_id(4), phi_kd(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: maxid(4), minid(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    g_id = 0.0_8
    g_kd = 0.0_8
    sum_dely_delfd = 0.0_8
    phi_id = 0.0_8
    phi_kd = 0.0_8
    sum_delx_delfd = 0.0_8
    DO j=1,point%yneg_nbhs(i)
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_id = pointd%q(:, i) - 0.5d0*(delx*pointd%dq(1, :, i)+dely*&
&       pointd%dq(2, :, i))
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_kd = pointd%q(:, k) - 0.5d0*(delx*pointd%dq(1, :, k)+dely*&
&       pointd%dq(2, :, k))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER_D(qtilde_i, qtilde_id, phi_i, phi_id, i)
        CALL VENKAT_LIMITER_D(qtilde_k, qtilde_kd, phi_k, phi_kd, k)
        qtilde_id = pointd%q(:, i) - 0.5d0*(phi_id*(delx*point%dq(1, :, &
&         i)+dely*point%dq(2, :, i))+phi_i*(delx*pointd%dq(1, :, i)+dely&
&         *pointd%dq(2, :, i)))
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_kd = pointd%q(:, k) - 0.5d0*(phi_kd*(delx*point%dq(1, :, &
&         k)+dely*point%dq(2, :, k))+phi_k*(delx*pointd%dq(1, :, k)+dely&
&         *pointd%dq(2, :, k)))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE_D(i, maxi, maxid)
        CALL MIN_Q_VALUE_D(i, mini, minid)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) THEN
            qtilde_id(r) = maxid(r)
            qtilde_i(r) = maxi(r)
          END IF
          IF (qtilde_i(r) .LT. mini(r)) THEN
            qtilde_id(r) = minid(r)
            qtilde_i(r) = mini(r)
          END IF
          IF (qtilde_k(r) .GT. maxi(r)) THEN
            qtilde_kd(r) = maxid(r)
            qtilde_k(r) = maxi(r)
          END IF
          IF (qtilde_k(r) .LT. mini(r)) THEN
            qtilde_kd(r) = minid(r)
            qtilde_k(r) = mini(r)
          END IF
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_i, qtilde_id, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GYN_D(g_i, g_id, nx, ny, u1, u1d, u2, u2d, rho, rhod, pr&
&               , prd)
      CALL QTILDE_TO_PRIMITIVE_D(qtilde_k, qtilde_kd, u1, u1d, u2, u2d, &
&                          rho, rhod, pr, prd)
      CALL FLUX_GYN_D(g_k, g_kd, nx, ny, u1, u1d, u2, u2d, rho, rhod, pr&
&               , prd)
      sum_delx_delfd = sum_delx_delfd + dels_weights*(g_kd-g_id)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delfd = sum_dely_delfd + deln_weights*(g_kd-g_id)
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    gd = one_by_det*(sum_delx_sqr*sum_dely_delfd-sum_delx_dely*&
&     sum_delx_delfd)
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGY_NEG_D

  SUBROUTINE WALL_DGY_NEG(g, i)
    IMPLICIT NONE
    INTEGER :: i, j, k, r
    REAL*8 :: rho, u1, u2, pr
    REAL*8 :: tx, ty, nx, ny
    REAL*8 :: x_i, y_i, x_k, y_k
    REAL*8 :: g_i(4), g_k(4), g(4)
    REAL*8 :: delx, dely, det, one_by_det
    REAL*8 :: dels, deln
    REAL*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
    REAL*8 :: sum_delx_delf(4), sum_dely_delf(4)
    REAL*8 :: dist, weights
    REAL*8 :: temp, qtilde_i(4), qtilde_k(4)
    REAL*8 :: phi_i(4), phi_k(4)
    REAL*8 :: maxi(4), mini(4)
    REAL*8 :: dels_weights, deln_weights
    INTRINSIC DSQRT
    REAL*8 :: arg1
    sum_delx_sqr = 0.0d0
    sum_dely_sqr = 0.0d0
    sum_delx_dely = 0.0d0
    sum_delx_delf = 0.0d0
    sum_dely_delf = 0.0d0
    x_i = point%x(i)
    y_i = point%y(i)
    nx = point%nx(i)
    ny = point%ny(i)
    tx = ny
    ty = -nx
    DO j=1,point%yneg_nbhs(i)
      k = point%yneg_conn(i, j)
      x_k = point%x(k)
      y_k = point%y(k)
      delx = x_k - x_i
      dely = y_k - y_i
      dels = delx*tx + dely*ty
      deln = delx*nx + dely*ny
      arg1 = dels*dels + deln*deln
      dist = DSQRT(arg1)
      weights = dist**power
      dels_weights = dels*weights
      deln_weights = deln*weights
      sum_delx_sqr = sum_delx_sqr + dels*dels_weights
      sum_dely_sqr = sum_dely_sqr + deln*deln_weights
      sum_delx_dely = sum_delx_dely + dels*deln_weights
      qtilde_i = point%q(:, i) - 0.5d0*(delx*point%dq(1, :, i)+dely*&
&       point%dq(2, :, i))
      qtilde_k = point%q(:, k) - 0.5d0*(delx*point%dq(1, :, k)+dely*&
&       point%dq(2, :, k))
      IF (limiter_flag .EQ. 1) THEN
        CALL VENKAT_LIMITER(qtilde_i, phi_i, i)
        CALL VENKAT_LIMITER(qtilde_k, phi_k, k)
        qtilde_i = point%q(:, i) - 0.5d0*phi_i*(delx*point%dq(1, :, i)+&
&         dely*point%dq(2, :, i))
        qtilde_k = point%q(:, k) - 0.5d0*phi_k*(delx*point%dq(1, :, k)+&
&         dely*point%dq(2, :, k))
      END IF
      IF (limiter_flag .EQ. 2) THEN
        CALL MAX_Q_VALUE(i, maxi)
        CALL MIN_Q_VALUE(i, mini)
        DO r=1,4
          IF (qtilde_i(r) .GT. maxi(r)) qtilde_i(r) = maxi(r)
          IF (qtilde_i(r) .LT. mini(r)) qtilde_i(r) = mini(r)
          IF (qtilde_k(r) .GT. maxi(r)) qtilde_k(r) = maxi(r)
          IF (qtilde_k(r) .LT. mini(r)) qtilde_k(r) = mini(r)
        END DO
      END IF
      CALL QTILDE_TO_PRIMITIVE(qtilde_i, u1, u2, rho, pr)
      CALL FLUX_GYN(g_i, nx, ny, u1, u2, rho, pr)
      CALL QTILDE_TO_PRIMITIVE(qtilde_k, u1, u2, rho, pr)
      CALL FLUX_GYN(g_k, nx, ny, u1, u2, rho, pr)
      sum_delx_delf = sum_delx_delf + (g_k-g_i)*dels_weights
      sum_dely_delf = sum_dely_delf + (g_k-g_i)*deln_weights
    END DO
    det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
    one_by_det = 1.d0/det
    g = (sum_dely_delf*sum_delx_sqr-sum_delx_delf*sum_delx_dely)*&
&     one_by_det
  END SUBROUTINE WALL_DGY_NEG

END MODULE WALL_FLUXES_MOD_DIFF_DIFF

