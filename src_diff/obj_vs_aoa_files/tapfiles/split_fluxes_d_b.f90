!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
MODULE SPLIT_FLUXES_MOD_DIFF_DIFF
  USE PARAMETER_MOD_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of flux_gxp_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: gxp nx ny gxpd
!   with respect to varying inputs: gxp nx ny u1d rhod gxpd prd
!                u1 u2 pr u2d rho
!  Differentiation of flux_gxp in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: gxp
!   with respect to varying inputs: gxp u1 u2 pr rho
  SUBROUTINE FLUX_GXP_D_B(gxp, gxpb, gxpd, gxpdb, nx, nxb, ny, nyb, u1, &
&   u1b, u1d, u1db, u2, u2b, u2d, u2db, rho, rhob, rhod, rhodb, pr, prb&
&   , prd, prdb)
    IMPLICIT NONE
    DOUBLE PRECISION :: gxp(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gxpb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: gxpd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: gxpdb(4), u1db, u2db, rhodb, prdb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: utdb, undb
    DOUBLE PRECISION :: beta, s1, b1, a1pos
    DOUBLE PRECISION :: betab, s1b, b1b, a1posb
    DOUBLE PRECISION :: betad, s1d, b1d, a1posd
    DOUBLE PRECISION :: betadb, s1db, b1db, a1posdb
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: temp1b, temp2b
    DOUBLE PRECISION :: temp1d, temp2d
    DOUBLE PRECISION :: temp1db, temp2db
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: pr_by_rhodb, u_sqrdb
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: result1db
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: DERF
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: temp0
    REAL*8 :: tempb2
    DOUBLE PRECISION :: temp3
    DOUBLE PRECISION :: temp4
    DOUBLE PRECISION :: temp5
    REAL*8 :: temp6
    DOUBLE PRECISION :: tempb3
    DOUBLE PRECISION :: tempb4
    DOUBLE PRECISION :: tempb5
    DOUBLE PRECISION :: tempb6
    DOUBLE PRECISION :: tempb7
    DOUBLE PRECISION :: tempb8
    DOUBLE PRECISION :: tempb9
    DOUBLE PRECISION :: tempb10
    DOUBLE PRECISION :: tempb11
    DOUBLE PRECISION :: tempb12
    DOUBLE PRECISION :: tempb13
    DOUBLE PRECISION :: tempb14
    DOUBLE PRECISION :: tempb15
    DOUBLE PRECISION :: tempb16
    DOUBLE PRECISION :: tempb17
    INTEGER :: branch
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      CALL PUSHCONTROL1B(0)
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
      CALL PUSHCONTROL1B(1)
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = arg1d/(2.d0*DSQRT(arg1))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
!result1d = DERF_D(s1, s1d, result1)
    CALL PUSHREAL8(result1d)
    result1d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    CALL PUSHREAL8(result1)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1posd = 0.5d0*result1d
    a1pos = 0.5d0*(1.0d0+result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!     Expressions for the split fluxes ..	
    temp1d = (utd*un+ut*und)*a1pos + ut*un*a1posd + und*b1 + un*b1d
    CALL PUSHREAL8(temp1d)
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1pos+ut*temp1*a1posd)
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    tempb5 = rho*0.5d0*gxpdb(4)
    tempb4 = rhod*gxpdb(4)
    tempb3 = rho*gxpb(4)
    rhob = (temp2d+0.5d0*(temp1d*b1+temp1*b1d))*gxpdb(4) + (temp2+0.5d0*&
&     (temp1*b1))*gxpb(4)
    temp2b = tempb4 + tempb3
    temp1b = 0.5d0*b1*tempb4 + b1d*tempb5 + 0.5d0*b1*tempb3
    b1b = 0.5d0*temp1*tempb4 + temp1d*tempb5 + 0.5d0*temp1*tempb3
    gxpb(4) = 0.D0
    rhodb = (temp2+0.5d0*(temp1*b1))*gxpdb(4)
    temp2db = rho*gxpdb(4)
    temp1db = b1*tempb5
    b1db = temp1*tempb5
    gxpdb(4) = 0.D0
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    pr_by_rhodb = 6.0d0*temp1db
    u_sqrdb = temp1db
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    tempb6 = 0.5d0*a1pos*temp2b
    tempb8 = 0.5d0*temp2db
    a1posb = (utd*temp1+ut*temp1d)*tempb8 + 0.5d0*ut*temp1*temp2b
    tempb7 = a1pos*tempb8
    temp1b = utd*tempb7 + a1posd*ut*tempb8 + ut*tempb6
    utdb = temp1*tempb7
    temp1db = ut*tempb7
    a1posdb = ut*temp1*tempb8
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    pr_by_rhodb = pr_by_rhodb + 7.0d0*temp1db
    u_sqrdb = u_sqrdb + temp1db
    temp1b = rhod*gxpdb(3) + rho*gxpb(3)
    temp1db = rho*gxpdb(3)
    tempb9 = a1pos*temp1db
    utb = temp1d*tempb7 + a1posd*temp1*tempb8 + und*tempb9 + a1posd*un*&
&     temp1db + a1pos*un*temp1b + temp1*tempb6
    CALL POPREAL8(temp1d)
    temp1 = ut*un*a1pos + un*b1
    rhob = rhob + temp1d*gxpdb(3) + temp1*gxpb(3)
    gxpb(3) = 0.D0
    rhodb = rhodb + temp1*gxpdb(3)
    gxpdb(3) = 0.D0
    unb = utd*tempb9 + (b1d+a1posd*ut)*temp1db + 2*und*u_sqrdb + 2*un*&
&     u_sqrb + (b1+a1pos*ut)*temp1b
    undb = 2*un*u_sqrdb + b1*temp1db + ut*tempb9
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    temp2b = rhod*gxpdb(2) + rho*gxpb(2)
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp2d = temp1d*a1pos + temp1*a1posd + utd*b1 + ut*b1d
    rhob = rhob + temp2d*gxpdb(2) + temp2*gxpb(2)
    gxpb(2) = 0.D0
    rhodb = rhodb + temp2*gxpdb(2)
    temp2db = rho*gxpdb(2)
    gxpdb(2) = 0.D0
    tempb12 = rho*gxpb(1)
    tempb10 = rhod*gxpdb(1)
    b1b = b1b + und*temp1db + utd*temp2db + tempb10 + tempb12 + ut*&
&     temp2b + un*temp1b
    tempb11 = rho*gxpdb(1)
    a1posb = a1posb + (utd*un+ut*und)*temp1db + temp1d*temp2db + ut*&
&     tempb10 + utd*tempb11 + ut*tempb12 + temp1*temp2b + ut*un*temp1b
    a1posdb = a1posdb + temp1*temp2db + ut*tempb11 + ut*un*temp1db
    b1db = b1db + ut*temp2db + tempb11 + un*temp1db
    temp1b = a1posd*temp2db + a1pos*temp2b
    temp1db = a1pos*temp2db
    utdb = utdb + b1*temp2db + a1pos*tempb11 + 2*ut*u_sqrdb + 2*ut*&
&     temp1db + un*tempb9
    utb = utb + b1d*temp2db + 2*utd*temp1db + a1pos*tempb10 + a1posd*&
&     tempb11 + 2*utd*u_sqrdb + 2*ut*u_sqrb + a1pos*tempb12 + 2*ut*&
&     temp1b + b1*temp2b
    pr_by_rhob = pr_by_rhob + temp1b
    pr_by_rhodb = pr_by_rhodb + temp1db
    tempb13 = pr_by_rhodb/rho**2
    rhob = rhob + (utd*a1pos+ut*a1posd+b1d)*gxpdb(1) + (prd-(prd*rho-pr*&
&     rhod)*2/rho)*tempb13 - pr*pr_by_rhob/rho**2 + (ut*a1pos+b1)*gxpb(1&
&     )
    gxpb(1) = 0.D0
    rhodb = rhodb + (ut*a1pos+b1)*gxpdb(1) - pr*tempb13
    gxpdb(1) = 0.D0
    prb = pr_by_rhob/rho - rhod*tempb13
    prdb = rho*tempb13
    result1b = 0.5d0*a1posb
    result1db = 0.5d0*a1posdb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL POPREAL8(result1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0
    CALL DERF_B(s1, s1b, result1b)
    CALL POPREAL8(s1)
    CALL POPREAL8(result1)
    CALL POPREAL8(result1d)
    temp6 = SQRT(pi)
    tempb14 = 0.5d0*b1b/result1
    tempb15 = b1db/result1**2
    temp5 = DEXP(-(s1**2))
    temp3 = s1d*s1 + s1*s1d
    tempb17 = -(0.5d0*temp5*tempb15)
    tempb16 = result1*tempb17
    s1b = s1b + (DEXP(-(s1**2))*result1d*0.5d0*2*s1+DEXP(-(s1**2))*temp3&
&     *result1*0.5d0*2*s1)*tempb15 - DEXP(-(s1**2))*2*s1*tempb14 + 2*s1d&
&     *tempb16 - DEXP(-(s1**2))*s1d*2.d0*2*s1*result1db/temp6
    s1db = 2*s1*tempb16 + DEXP(-(s1**2))*2.d0*result1db/temp6
    temp4 = DEXP(-(s1**2))
    result1b = temp3*tempb17 - (-(0.5d0*(temp3*result1*temp5))-0.5d0*(&
&     temp4*result1d))*2*tempb15/result1 - DEXP(-(s1**2))*tempb14/&
&     result1
    result1db = -(0.5d0*temp4*tempb15)
    CALL POPREAL8(result1)
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.D0*DSQRT(arg1))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
      arg1db = 0.0_8
    ELSE
      CALL POPREAL8(result1d)
      temp0 = DSQRT(arg1)
      tempb2 = result1db/(2.d0*temp0)
      arg1db = tempb2
      IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb2/(temp0*2.D0*&
&         DSQRT(arg1))
    END IF
    result1b = utd*s1db + ut*s1b
    IF (beta .EQ. 0.0) THEN
      betab = pi*arg1b
    ELSE
      betab = result1b/(2.D0*DSQRT(beta)) + pi*arg1b
    END IF
    betadb = pi*arg1db
    utb = utb + result1d*s1db + result1*s1b
    utdb = utdb + result1*s1db
    result1db = ut*s1db
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      temp = DSQRT(beta)
      tempb1 = result1db/(2.d0*temp)
      betadb = betadb + tempb1
      IF (.NOT.beta .EQ. 0.0) betab = betab - betad*tempb1/(temp*2.D0*&
&         DSQRT(beta))
    END IF
    tyb = u2d*utdb + u2*utb
    txb = u1d*utdb + u1*utb
    tempb0 = betadb/pr**2
    tempb = 0.5d0*betab/pr
    rhob = rhob + tempb - 0.5d0*prd*tempb0
    prb = prb + (0.5d0*rhod-(0.5d0*(rhod*pr)-0.5d0*(rho*prd))*2/pr)*&
&     tempb0 - rho*tempb/pr
    rhodb = rhodb + 0.5d0*pr*tempb0
    prdb = prdb - 0.5d0*rho*tempb0
    u1b = tx*utb + nx*unb
    nxb = nxb + u1d*undb - tyb + u1*unb
    u2b = ty*utb + ny*unb
    nyb = nyb + u2d*undb + txb + u2*unb
    u1db = tx*utdb + nx*undb
    u2db = ty*utdb + ny*undb
  END SUBROUTINE FLUX_GXP_D_B

!  Differentiation of flux_gxp in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: gxp
!   with respect to varying inputs: gxp u1 u2 pr rho
  SUBROUTINE FLUX_GXP_D(gxp, gxpd, nx, ny, u1, u1d, u2, u2d, rho, rhod, &
&   pr, prd)
    IMPLICIT NONE
    DOUBLE PRECISION :: gxp(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gxpd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: beta, s1, b1, a1pos
    DOUBLE PRECISION :: betad, s1d, b1d, a1posd
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: temp1d, temp2d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
!result1d = DERF_D(s1, s1d, result1)
    result1d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    result1 = DERF(s1)
    a1posd = 0.5d0*result1d
    a1pos = 0.5d0*(1.0d0+result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!     Expressions for the split fluxes ..	
    gxpd(1) = rhod*(ut*a1pos+b1) + rho*(utd*a1pos+ut*a1posd+b1d)
    gxp(1) = rho*(ut*a1pos+b1)
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp1 = pr_by_rho + ut*ut
    temp2d = temp1d*a1pos + temp1*a1posd + utd*b1 + ut*b1d
    temp2 = temp1*a1pos + ut*b1
    gxpd(2) = rhod*temp2 + rho*temp2d
    gxp(2) = rho*temp2
    temp1d = (utd*un+ut*und)*a1pos + ut*un*a1posd + und*b1 + un*b1d
    temp1 = ut*un*a1pos + un*b1
    gxpd(3) = rhod*temp1 + rho*temp1d
    gxp(3) = rho*temp1
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1pos+ut*temp1*a1posd)
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    gxpd(4) = rhod*(temp2+0.5d0*temp1*b1) + rho*(temp2d+0.5d0*(temp1d*b1&
&     +temp1*b1d))
    gxp(4) = rho*(temp2+0.5d0*temp1*b1)
  END SUBROUTINE FLUX_GXP_D

  SUBROUTINE FLUX_GXP(gxp, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: gxp(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta, s1, b1, a1pos
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    result1 = DSQRT(beta)
    s1 = ut*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    result1 = DERF(s1)
    a1pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!     Expressions for the split fluxes ..	
    gxp(1) = rho*(ut*a1pos+b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1pos + ut*b1
    gxp(2) = rho*temp2
    temp1 = ut*un*a1pos + un*b1
    gxp(3) = rho*temp1
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    gxp(4) = rho*(temp2+0.5d0*temp1*b1)
  END SUBROUTINE FLUX_GXP

!  Differentiation of flux_gxn_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: gxnd gxn nx ny
!   with respect to varying inputs: gxnd gxn nx ny u1d rhod prd
!                u1 u2 pr u2d rho
!  Differentiation of flux_gxn in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: gxn
!   with respect to varying inputs: gxn u1 u2 pr rho
  SUBROUTINE FLUX_GXN_D_B(gxn, gxnb, gxnd, gxndb, nx, nxb, ny, nyb, u1, &
&   u1b, u1d, u1db, u2, u2b, u2d, u2db, rho, rhob, rhod, rhodb, pr, prb&
&   , prd, prdb)
    IMPLICIT NONE
    DOUBLE PRECISION :: gxn(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gxnb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: gxnd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: gxndb(4), u1db, u2db, rhodb, prdb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: utdb, undb
    DOUBLE PRECISION :: beta, s1, b1, a1neg
    DOUBLE PRECISION :: betab, s1b, b1b, a1negb
    DOUBLE PRECISION :: betad, s1d, b1d, a1negd
    DOUBLE PRECISION :: betadb, s1db, b1db, a1negdb
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: temp1b, temp2b
    DOUBLE PRECISION :: temp1d, temp2d
    DOUBLE PRECISION :: temp1db, temp2db
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: pr_by_rhodb, u_sqrdb
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: result1db
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: DERF
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: temp0
    REAL*8 :: tempb2
    DOUBLE PRECISION :: temp3
    DOUBLE PRECISION :: temp4
    DOUBLE PRECISION :: temp5
    REAL*8 :: temp6
    DOUBLE PRECISION :: tempb3
    DOUBLE PRECISION :: tempb4
    DOUBLE PRECISION :: tempb5
    DOUBLE PRECISION :: tempb6
    DOUBLE PRECISION :: tempb7
    DOUBLE PRECISION :: tempb8
    DOUBLE PRECISION :: tempb9
    DOUBLE PRECISION :: tempb10
    DOUBLE PRECISION :: tempb11
    DOUBLE PRECISION :: tempb12
    DOUBLE PRECISION :: tempb13
    DOUBLE PRECISION :: tempb14
    DOUBLE PRECISION :: tempb15
    DOUBLE PRECISION :: tempb16
    DOUBLE PRECISION :: tempb17
    INTEGER :: branch
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      CALL PUSHCONTROL1B(0)
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
      CALL PUSHCONTROL1B(1)
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = arg1d/(2.d0*DSQRT(arg1))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
!result1d = DERF_D(s1, s1d, result1)
    CALL PUSHREAL8(result1d)
    result1d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    CALL PUSHREAL8(result1)
    CALL PUSHREAL8(s1)
    result1 = DERF(s1)
    a1negd = -(0.5d0*result1d)
    a1neg = 0.5d0*(1.0d0-result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    temp1d = (utd*un+ut*und)*a1neg + ut*un*a1negd - und*b1 - un*b1d
    CALL PUSHREAL8(temp1d)
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1neg+ut*temp1*a1negd)
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    tempb5 = -(rho*0.5d0*gxndb(4))
    tempb4 = rhod*gxndb(4)
    tempb3 = rho*gxnb(4)
    rhob = (temp2d-0.5d0*(temp1d*b1+temp1*b1d))*gxndb(4) + (temp2-0.5d0*&
&     (temp1*b1))*gxnb(4)
    temp2b = tempb4 + tempb3
    temp1b = b1d*tempb5 - 0.5d0*b1*tempb4 - 0.5d0*b1*tempb3
    b1b = temp1d*tempb5 - 0.5d0*temp1*tempb4 - 0.5d0*temp1*tempb3
    gxnb(4) = 0.D0
    rhodb = (temp2-0.5d0*(temp1*b1))*gxndb(4)
    temp2db = rho*gxndb(4)
    temp1db = b1*tempb5
    b1db = temp1*tempb5
    gxndb(4) = 0.D0
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    pr_by_rhodb = 6.0d0*temp1db
    u_sqrdb = temp1db
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    tempb6 = 0.5d0*a1neg*temp2b
    tempb8 = 0.5d0*temp2db
    a1negb = (utd*temp1+ut*temp1d)*tempb8 + 0.5d0*ut*temp1*temp2b
    tempb7 = a1neg*tempb8
    temp1b = utd*tempb7 + a1negd*ut*tempb8 + ut*tempb6
    utdb = temp1*tempb7
    temp1db = ut*tempb7
    a1negdb = ut*temp1*tempb8
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    pr_by_rhodb = pr_by_rhodb + 7.0d0*temp1db
    u_sqrdb = u_sqrdb + temp1db
    temp1b = rhod*gxndb(3) + rho*gxnb(3)
    temp1db = rho*gxndb(3)
    tempb9 = a1neg*temp1db
    utb = temp1d*tempb7 + a1negd*temp1*tempb8 + und*tempb9 + a1negd*un*&
&     temp1db + a1neg*un*temp1b + temp1*tempb6
    CALL POPREAL8(temp1d)
    temp1 = ut*un*a1neg - un*b1
    rhob = rhob + temp1d*gxndb(3) + temp1*gxnb(3)
    gxnb(3) = 0.D0
    rhodb = rhodb + temp1*gxndb(3)
    gxndb(3) = 0.D0
    unb = utd*tempb9 + (a1negd*ut-b1d)*temp1db + 2*und*u_sqrdb + 2*un*&
&     u_sqrb + (a1neg*ut-b1)*temp1b
    undb = 2*un*u_sqrdb - b1*temp1db + ut*tempb9
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    temp2b = rhod*gxndb(2) + rho*gxnb(2)
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp2d = temp1d*a1neg + temp1*a1negd - utd*b1 - ut*b1d
    rhob = rhob + temp2d*gxndb(2) + temp2*gxnb(2)
    gxnb(2) = 0.D0
    rhodb = rhodb + temp2*gxndb(2)
    temp2db = rho*gxndb(2)
    gxndb(2) = 0.D0
    tempb12 = rho*gxnb(1)
    tempb10 = rhod*gxndb(1)
    b1b = b1b - und*temp1db - utd*temp2db - tempb10 - tempb12 - ut*&
&     temp2b - un*temp1b
    tempb11 = rho*gxndb(1)
    a1negb = a1negb + (utd*un+ut*und)*temp1db + temp1d*temp2db + ut*&
&     tempb10 + utd*tempb11 + ut*tempb12 + temp1*temp2b + ut*un*temp1b
    a1negdb = a1negdb + temp1*temp2db + ut*tempb11 + ut*un*temp1db
    b1db = b1db - ut*temp2db - tempb11 - un*temp1db
    temp1b = a1negd*temp2db + a1neg*temp2b
    temp1db = a1neg*temp2db
    utdb = utdb + a1neg*tempb11 - b1*temp2db + 2*ut*u_sqrdb + 2*ut*&
&     temp1db + un*tempb9
    utb = utb + 2*utd*temp1db - b1d*temp2db + a1neg*tempb10 + a1negd*&
&     tempb11 + 2*utd*u_sqrdb + 2*ut*u_sqrb + a1neg*tempb12 + 2*ut*&
&     temp1b - b1*temp2b
    pr_by_rhob = pr_by_rhob + temp1b
    pr_by_rhodb = pr_by_rhodb + temp1db
    tempb13 = pr_by_rhodb/rho**2
    rhob = rhob + (utd*a1neg+ut*a1negd-b1d)*gxndb(1) + (prd-(prd*rho-pr*&
&     rhod)*2/rho)*tempb13 - pr*pr_by_rhob/rho**2 + (ut*a1neg-b1)*gxnb(1&
&     )
    gxnb(1) = 0.D0
    rhodb = rhodb + (ut*a1neg-b1)*gxndb(1) - pr*tempb13
    gxndb(1) = 0.D0
    prb = pr_by_rhob/rho - rhod*tempb13
    prdb = rho*tempb13
    result1b = -(0.5d0*a1negb)
    result1db = -(0.5d0*a1negdb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s1)
    CALL POPREAL8(result1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s1b = 0.D0
    CALL DERF_B(s1, s1b, result1b)
    CALL POPREAL8(s1)
    CALL POPREAL8(result1)
    CALL POPREAL8(result1d)
    temp6 = SQRT(pi)
    tempb14 = 0.5d0*b1b/result1
    tempb15 = b1db/result1**2
    temp5 = DEXP(-(s1**2))
    temp3 = s1d*s1 + s1*s1d
    tempb17 = -(0.5d0*temp5*tempb15)
    tempb16 = result1*tempb17
    s1b = s1b + (DEXP(-(s1**2))*result1d*0.5d0*2*s1+DEXP(-(s1**2))*temp3&
&     *result1*0.5d0*2*s1)*tempb15 - DEXP(-(s1**2))*2*s1*tempb14 + 2*s1d&
&     *tempb16 - DEXP(-(s1**2))*s1d*2.d0*2*s1*result1db/temp6
    s1db = 2*s1*tempb16 + DEXP(-(s1**2))*2.d0*result1db/temp6
    temp4 = DEXP(-(s1**2))
    result1b = temp3*tempb17 - (-(0.5d0*(temp3*result1*temp5))-0.5d0*(&
&     temp4*result1d))*2*tempb15/result1 - DEXP(-(s1**2))*tempb14/&
&     result1
    result1db = -(0.5d0*temp4*tempb15)
    CALL POPREAL8(result1)
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.D0*DSQRT(arg1))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
      arg1db = 0.0_8
    ELSE
      CALL POPREAL8(result1d)
      temp0 = DSQRT(arg1)
      tempb2 = result1db/(2.d0*temp0)
      arg1db = tempb2
      IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb2/(temp0*2.D0*&
&         DSQRT(arg1))
    END IF
    result1b = utd*s1db + ut*s1b
    IF (beta .EQ. 0.0) THEN
      betab = pi*arg1b
    ELSE
      betab = result1b/(2.D0*DSQRT(beta)) + pi*arg1b
    END IF
    betadb = pi*arg1db
    utb = utb + result1d*s1db + result1*s1b
    utdb = utdb + result1*s1db
    result1db = ut*s1db
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      temp = DSQRT(beta)
      tempb1 = result1db/(2.d0*temp)
      betadb = betadb + tempb1
      IF (.NOT.beta .EQ. 0.0) betab = betab - betad*tempb1/(temp*2.D0*&
&         DSQRT(beta))
    END IF
    tyb = u2d*utdb + u2*utb
    txb = u1d*utdb + u1*utb
    tempb0 = betadb/pr**2
    tempb = 0.5d0*betab/pr
    rhob = rhob + tempb - 0.5d0*prd*tempb0
    prb = prb + (0.5d0*rhod-(0.5d0*(rhod*pr)-0.5d0*(rho*prd))*2/pr)*&
&     tempb0 - rho*tempb/pr
    rhodb = rhodb + 0.5d0*pr*tempb0
    prdb = prdb - 0.5d0*rho*tempb0
    u1b = tx*utb + nx*unb
    nxb = nxb + u1d*undb - tyb + u1*unb
    u2b = ty*utb + ny*unb
    nyb = nyb + u2d*undb + txb + u2*unb
    u1db = tx*utdb + nx*undb
    u2db = ty*utdb + ny*undb
  END SUBROUTINE FLUX_GXN_D_B

!  Differentiation of flux_gxn in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: gxn
!   with respect to varying inputs: gxn u1 u2 pr rho
  SUBROUTINE FLUX_GXN_D(gxn, gxnd, nx, ny, u1, u1d, u2, u2d, rho, rhod, &
&   pr, prd)
    IMPLICIT NONE
    DOUBLE PRECISION :: gxn(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gxnd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: beta, s1, b1, a1neg
    DOUBLE PRECISION :: betad, s1d, b1d, a1negd
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: temp1d, temp2d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s1d = utd*result1 + ut*result1d
    s1 = ut*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b1d = (-(0.5d0*(s1d*s1+s1*s1d)*DEXP(-(s1*s1))*result1)-0.5d0*DEXP(-(&
&     s1*s1))*result1d)/result1**2
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
!result1d = DERF_D(s1, s1d, result1)
    result1d = DEXP(-(s1**2))*(2.d0/SQRT(pi))*s1d
    result1 = DERF(s1)
    a1negd = -(0.5d0*result1d)
    a1neg = 0.5d0*(1.0d0-result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    gxnd(1) = rhod*(ut*a1neg-b1) + rho*(utd*a1neg+ut*a1negd-b1d)
    gxn(1) = rho*(ut*a1neg-b1)
    temp1d = pr_by_rhod + utd*ut + ut*utd
    temp1 = pr_by_rho + ut*ut
    temp2d = temp1d*a1neg + temp1*a1negd - utd*b1 - ut*b1d
    temp2 = temp1*a1neg - ut*b1
    gxnd(2) = rhod*temp2 + rho*temp2d
    gxn(2) = rho*temp2
    temp1d = (utd*un+ut*und)*a1neg + ut*un*a1negd - und*b1 - un*b1d
    temp1 = ut*un*a1neg - un*b1
    gxnd(3) = rhod*temp1 + rho*temp1d
    gxn(3) = rho*temp1
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((utd*temp1+ut*temp1d)*a1neg+ut*temp1*a1negd)
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    gxnd(4) = rhod*(temp2-0.5d0*temp1*b1) + rho*(temp2d-0.5d0*(temp1d*b1&
&     +temp1*b1d))
    gxn(4) = rho*(temp2-0.5d0*temp1*b1)
  END SUBROUTINE FLUX_GXN_D

  SUBROUTINE FLUX_GXN(gxn, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: gxn(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta, s1, b1, a1neg
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    result1 = DSQRT(beta)
    s1 = ut*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b1 = 0.5d0*DEXP(-(s1*s1))/result1
    result1 = DERF(s1)
    a1neg = 0.5d0*(1.0d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    gxn(1) = rho*(ut*a1neg-b1)
    temp1 = pr_by_rho + ut*ut
    temp2 = temp1*a1neg - ut*b1
    gxn(2) = rho*temp2
    temp1 = ut*un*a1neg - un*b1
    gxn(3) = rho*temp1
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*ut*temp1*a1neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    gxn(4) = rho*(temp2-0.5d0*temp1*b1)
  END SUBROUTINE FLUX_GXN

!  Differentiation of flux_gyp_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: gypd nx ny gyp
!   with respect to varying inputs: gypd nx ny gyp u1d rhod prd
!                u1 u2 pr u2d rho
!  Differentiation of flux_gyp in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: gyp
!   with respect to varying inputs: gyp u1 u2 pr rho
  SUBROUTINE FLUX_GYP_D_B(gyp, gypb, gypd, gypdb, nx, nxb, ny, nyb, u1, &
&   u1b, u1d, u1db, u2, u2b, u2d, u2db, rho, rhob, rhod, rhodb, pr, prb&
&   , prd, prdb)
    IMPLICIT NONE
    DOUBLE PRECISION :: gyp(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gypb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: gypd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: gypdb(4), u1db, u2db, rhodb, prdb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: utdb, undb
    DOUBLE PRECISION :: beta, s2, b2, a2pos
    DOUBLE PRECISION :: betab, s2b, b2b, a2posb
    DOUBLE PRECISION :: betad, s2d, b2d, a2posd
    DOUBLE PRECISION :: betadb, s2db, b2db, a2posdb
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: temp1b, temp2b
    DOUBLE PRECISION :: temp1d, temp2d
    DOUBLE PRECISION :: temp1db, temp2db
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: pr_by_rhodb, u_sqrdb
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: result1db
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: DERF
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: temp0
    REAL*8 :: tempb2
    DOUBLE PRECISION :: temp3
    DOUBLE PRECISION :: temp4
    DOUBLE PRECISION :: temp5
    REAL*8 :: temp6
    DOUBLE PRECISION :: tempb3
    DOUBLE PRECISION :: tempb4
    DOUBLE PRECISION :: tempb5
    DOUBLE PRECISION :: tempb6
    DOUBLE PRECISION :: tempb7
    DOUBLE PRECISION :: tempb8
    DOUBLE PRECISION :: tempb9
    DOUBLE PRECISION :: tempb10
    DOUBLE PRECISION :: tempb11
    DOUBLE PRECISION :: tempb12
    DOUBLE PRECISION :: tempb13
    DOUBLE PRECISION :: tempb14
    DOUBLE PRECISION :: tempb15
    DOUBLE PRECISION :: tempb16
    DOUBLE PRECISION :: tempb17
    INTEGER :: branch
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      CALL PUSHCONTROL1B(0)
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
      CALL PUSHCONTROL1B(1)
    END IF
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = arg1d/(2.d0*DSQRT(arg1))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!result1d = DERF_D(s2, s2d, result1)
    CALL PUSHREAL8(result1d)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    CALL PUSHREAL8(result1)
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2posd = 0.5d0*result1d
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    temp1d = (utd*un+ut*und)*a2pos + ut*un*a2posd + utd*b2 + ut*b2d
    CALL PUSHREAL8(temp1d)
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((und*temp1+un*temp1d)*a2pos+un*temp1*a2posd)
    temp2 = 0.5d0*un*temp1*a2pos
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    tempb5 = rho*0.5d0*gypdb(4)
    tempb4 = rhod*gypdb(4)
    tempb3 = rho*gypb(4)
    rhob = (temp2d+0.5d0*(temp1d*b2+temp1*b2d))*gypdb(4) + (temp2+0.5d0*&
&     (temp1*b2))*gypb(4)
    temp2b = tempb4 + tempb3
    temp1b = 0.5d0*b2*tempb4 + b2d*tempb5 + 0.5d0*b2*tempb3
    b2b = 0.5d0*temp1*tempb4 + temp1d*tempb5 + 0.5d0*temp1*tempb3
    gypb(4) = 0.D0
    rhodb = (temp2+0.5d0*(temp1*b2))*gypdb(4)
    temp2db = rho*gypdb(4)
    temp1db = b2*tempb5
    b2db = temp1*tempb5
    gypdb(4) = 0.D0
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    pr_by_rhodb = 6.0d0*temp1db
    u_sqrdb = temp1db
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    tempb6 = 0.5d0*a2pos*temp2b
    tempb8 = 0.5d0*temp2db
    a2posb = (und*temp1+un*temp1d)*tempb8 + 0.5d0*un*temp1*temp2b
    tempb7 = a2pos*tempb8
    temp1b = und*tempb7 + a2posd*un*tempb8 + un*tempb6
    undb = temp1*tempb7
    temp1db = un*tempb7
    a2posdb = un*temp1*tempb8
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    pr_by_rhodb = pr_by_rhodb + 7.0d0*temp1db
    u_sqrdb = u_sqrdb + temp1db
    temp1b = rhod*gypdb(2) + rho*gypb(2)
    temp1db = rho*gypdb(2)
    tempb9 = a2pos*temp1db
    unb = temp1d*tempb7 + a2posd*temp1*tempb8 + utd*tempb9 + a2posd*ut*&
&     temp1db + a2pos*ut*temp1b + temp1*tempb6
    CALL POPREAL8(temp1d)
    temp1 = ut*un*a2pos + ut*b2
    rhob = rhob + temp1d*gypdb(2) + temp1*gypb(2)
    gypb(2) = 0.D0
    rhodb = rhodb + temp1*gypdb(2)
    gypdb(2) = 0.D0
    utb = und*tempb9 + (b2d+a2posd*un)*temp1db + 2*utd*u_sqrdb + 2*ut*&
&     u_sqrb + (b2+a2pos*un)*temp1b
    utdb = 2*ut*u_sqrdb + b2*temp1db + un*tempb9
    temp1 = pr_by_rho + un*un
    temp2 = temp1*a2pos + un*b2
    temp2b = rhod*gypdb(3) + rho*gypb(3)
    temp1d = pr_by_rhod + und*un + un*und
    temp2d = temp1d*a2pos + temp1*a2posd + und*b2 + un*b2d
    rhob = rhob + temp2d*gypdb(3) + temp2*gypb(3)
    gypb(3) = 0.D0
    rhodb = rhodb + temp2*gypdb(3)
    temp2db = rho*gypdb(3)
    gypdb(3) = 0.D0
    tempb12 = rho*gypb(1)
    tempb10 = rhod*gypdb(1)
    b2b = b2b + utd*temp1db + und*temp2db + tempb10 + tempb12 + un*&
&     temp2b + ut*temp1b
    tempb11 = rho*gypdb(1)
    a2posb = a2posb + (utd*un+ut*und)*temp1db + temp1d*temp2db + un*&
&     tempb10 + und*tempb11 + un*tempb12 + temp1*temp2b + ut*un*temp1b
    a2posdb = a2posdb + temp1*temp2db + un*tempb11 + ut*un*temp1db
    b2db = b2db + un*temp2db + tempb11 + ut*temp1db
    temp1b = a2posd*temp2db + a2pos*temp2b
    temp1db = a2pos*temp2db
    undb = undb + b2*temp2db + a2pos*tempb11 + 2*un*u_sqrdb + 2*un*&
&     temp1db + ut*tempb9
    unb = unb + b2d*temp2db + 2*und*temp1db + a2pos*tempb10 + a2posd*&
&     tempb11 + 2*und*u_sqrdb + 2*un*u_sqrb + a2pos*tempb12 + 2*un*&
&     temp1b + b2*temp2b
    pr_by_rhob = pr_by_rhob + temp1b
    pr_by_rhodb = pr_by_rhodb + temp1db
    tempb13 = pr_by_rhodb/rho**2
    rhob = rhob + (und*a2pos+un*a2posd+b2d)*gypdb(1) + (prd-(prd*rho-pr*&
&     rhod)*2/rho)*tempb13 - pr*pr_by_rhob/rho**2 + (un*a2pos+b2)*gypb(1&
&     )
    gypb(1) = 0.D0
    rhodb = rhodb + (un*a2pos+b2)*gypdb(1) - pr*tempb13
    gypdb(1) = 0.D0
    prb = pr_by_rhob/rho - rhod*tempb13
    prdb = rho*tempb13
    result1b = 0.5d0*a2posb
    result1db = 0.5d0*a2posdb
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL POPREAL8(result1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0
    CALL DERF_B(s2, s2b, result1b)
    CALL POPREAL8(s2)
    CALL POPREAL8(result1)
    CALL POPREAL8(result1d)
    temp6 = SQRT(pi)
    tempb14 = 0.5d0*b2b/result1
    tempb15 = b2db/result1**2
    temp5 = DEXP(-(s2**2))
    temp3 = s2d*s2 + s2*s2d
    tempb17 = -(0.5d0*temp5*tempb15)
    tempb16 = result1*tempb17
    s2b = s2b + (DEXP(-(s2**2))*result1d*0.5d0*2*s2+DEXP(-(s2**2))*temp3&
&     *result1*0.5d0*2*s2)*tempb15 - DEXP(-(s2**2))*2*s2*tempb14 + 2*s2d&
&     *tempb16 - DEXP(-(s2**2))*s2d*2.d0*2*s2*result1db/temp6
    s2db = 2*s2*tempb16 + DEXP(-(s2**2))*2.d0*result1db/temp6
    temp4 = DEXP(-(s2**2))
    result1b = temp3*tempb17 - (-(0.5d0*(temp3*result1*temp5))-0.5d0*(&
&     temp4*result1d))*2*tempb15/result1 - DEXP(-(s2**2))*tempb14/&
&     result1
    result1db = -(0.5d0*temp4*tempb15)
    CALL POPREAL8(result1)
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.D0*DSQRT(arg1))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
      arg1db = 0.0_8
    ELSE
      CALL POPREAL8(result1d)
      temp0 = DSQRT(arg1)
      tempb2 = result1db/(2.d0*temp0)
      arg1db = tempb2
      IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb2/(temp0*2.D0*&
&         DSQRT(arg1))
    END IF
    result1b = und*s2db + un*s2b
    IF (beta .EQ. 0.0) THEN
      betab = pi*arg1b
    ELSE
      betab = result1b/(2.D0*DSQRT(beta)) + pi*arg1b
    END IF
    betadb = pi*arg1db
    unb = unb + result1d*s2db + result1*s2b
    undb = undb + result1*s2db
    result1db = un*s2db
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      temp = DSQRT(beta)
      tempb1 = result1db/(2.d0*temp)
      betadb = betadb + tempb1
      IF (.NOT.beta .EQ. 0.0) betab = betab - betad*tempb1/(temp*2.D0*&
&         DSQRT(beta))
    END IF
    tyb = u2d*utdb + u2*utb
    txb = u1d*utdb + u1*utb
    tempb0 = betadb/pr**2
    tempb = 0.5d0*betab/pr
    rhob = rhob + tempb - 0.5d0*prd*tempb0
    prb = prb + (0.5d0*rhod-(0.5d0*(rhod*pr)-0.5d0*(rho*prd))*2/pr)*&
&     tempb0 - rho*tempb/pr
    rhodb = rhodb + 0.5d0*pr*tempb0
    prdb = prdb - 0.5d0*rho*tempb0
    u1b = tx*utb + nx*unb
    nxb = nxb + u1d*undb - tyb + u1*unb
    u2b = ty*utb + ny*unb
    nyb = nyb + u2d*undb + txb + u2*unb
    u1db = tx*utdb + nx*undb
    u2db = ty*utdb + ny*undb
  END SUBROUTINE FLUX_GYP_D_B

!  Differentiation of flux_gyp in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: gyp
!   with respect to varying inputs: gyp u1 u2 pr rho
  SUBROUTINE FLUX_GYP_D(gyp, gypd, nx, ny, u1, u1d, u2, u2d, rho, rhod, &
&   pr, prd)
    IMPLICIT NONE
    DOUBLE PRECISION :: gyp(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gypd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: beta, s2, b2, a2pos
    DOUBLE PRECISION :: betad, s2d, b2d, a2posd
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: temp1d, temp2d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!result1d = DERF_D(s2, s2d, result1)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    result1 = DERF(s2)
    a2posd = 0.5d0*result1d
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    gypd(1) = rhod*(un*a2pos+b2) + rho*(und*a2pos+un*a2posd+b2d)
    gyp(1) = rho*(un*a2pos+b2)
    temp1d = pr_by_rhod + und*un + un*und
    temp1 = pr_by_rho + un*un
    temp2d = temp1d*a2pos + temp1*a2posd + und*b2 + un*b2d
    temp2 = temp1*a2pos + un*b2
    gypd(3) = rhod*temp2 + rho*temp2d
    gyp(3) = rho*temp2
    temp1d = (utd*un+ut*und)*a2pos + ut*un*a2posd + utd*b2 + ut*b2d
    temp1 = ut*un*a2pos + ut*b2
    gypd(2) = rhod*temp1 + rho*temp1d
    gyp(2) = rho*temp1
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((und*temp1+un*temp1d)*a2pos+un*temp1*a2posd)
    temp2 = 0.5d0*un*temp1*a2pos
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    gypd(4) = rhod*(temp2+0.5d0*temp1*b2) + rho*(temp2d+0.5d0*(temp1d*b2&
&     +temp1*b2d))
    gyp(4) = rho*(temp2+0.5d0*temp1*b2)
  END SUBROUTINE FLUX_GYP_D

  SUBROUTINE FLUX_GYP(gyp, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: gyp(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta, s2, b2, a2pos
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    result1 = DSQRT(beta)
    s2 = un*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
    result1 = DERF(s2)
    a2pos = 0.5d0*(1.0d0+result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    gyp(1) = rho*(un*a2pos+b2)
    temp1 = pr_by_rho + un*un
    temp2 = temp1*a2pos + un*b2
    gyp(3) = rho*temp2
    temp1 = ut*un*a2pos + ut*b2
    gyp(2) = rho*temp1
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*un*temp1*a2pos
    temp1 = 6.0d0*pr_by_rho + u_sqr
    gyp(4) = rho*(temp2+0.5d0*temp1*b2)
  END SUBROUTINE FLUX_GYP

!  Differentiation of flux_gyn_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: nx ny gyn gynd
!   with respect to varying inputs: nx ny gyn u1d rhod gynd prd
!                u1 u2 pr u2d rho
!  Differentiation of flux_gyn in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: gyn
!   with respect to varying inputs: gyn u1 u2 pr rho
  SUBROUTINE FLUX_GYN_D_B(gyn, gynb, gynd, gyndb, nx, nxb, ny, nyb, u1, &
&   u1b, u1d, u1db, u2, u2b, u2d, u2db, rho, rhob, rhod, rhodb, pr, prb&
&   , prd, prdb)
    IMPLICIT NONE
    DOUBLE PRECISION :: gyn(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gynb(4), u1b, u2b, rhob, prb
    DOUBLE PRECISION :: gynd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: gyndb(4), u1db, u2db, rhodb, prdb
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: txb, tyb, nxb, nyb, utb, unb
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: utdb, undb
    DOUBLE PRECISION :: beta, s2, b2, a2neg
    DOUBLE PRECISION :: betab, s2b, b2b, a2negb
    DOUBLE PRECISION :: betad, s2d, b2d, a2negd
    DOUBLE PRECISION :: betadb, s2db, b2db, a2negdb
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: temp1b, temp2b
    DOUBLE PRECISION :: temp1d, temp2d
    DOUBLE PRECISION :: temp1db, temp2db
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhob, u_sqrb
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: pr_by_rhodb, u_sqrdb
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1b
    DOUBLE PRECISION :: result1d
    DOUBLE PRECISION :: result1db
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    EXTERNAL DERF_B
    DOUBLE PRECISION :: DERF
    DOUBLE PRECISION :: tempb
    DOUBLE PRECISION :: tempb0
    DOUBLE PRECISION :: temp
    DOUBLE PRECISION :: tempb1
    DOUBLE PRECISION :: temp0
    REAL*8 :: tempb2
    DOUBLE PRECISION :: temp3
    DOUBLE PRECISION :: temp4
    DOUBLE PRECISION :: temp5
    REAL*8 :: temp6
    DOUBLE PRECISION :: tempb3
    DOUBLE PRECISION :: tempb4
    DOUBLE PRECISION :: tempb5
    DOUBLE PRECISION :: tempb6
    DOUBLE PRECISION :: tempb7
    DOUBLE PRECISION :: tempb8
    DOUBLE PRECISION :: tempb9
    DOUBLE PRECISION :: tempb10
    DOUBLE PRECISION :: tempb11
    DOUBLE PRECISION :: tempb12
    DOUBLE PRECISION :: tempb13
    DOUBLE PRECISION :: tempb14
    DOUBLE PRECISION :: tempb15
    DOUBLE PRECISION :: tempb16
    DOUBLE PRECISION :: tempb17
    INTEGER :: branch
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      CALL PUSHCONTROL1B(0)
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
      CALL PUSHCONTROL1B(1)
    END IF
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      CALL PUSHREAL8(result1d)
      result1d = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(result1d)
      result1d = arg1d/(2.d0*DSQRT(arg1))
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(result1)
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!result1d = DERF_D(s2, s2d, result1)
    CALL PUSHREAL8(result1d)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    CALL PUSHREAL8(result1)
    CALL PUSHREAL8(s2)
    result1 = DERF(s2)
    a2negd = -(0.5d0*result1d)
    a2neg = 0.5d0*(1.0d0-result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    temp1d = (utd*un+ut*und)*a2neg + ut*un*a2negd - utd*b2 - ut*b2d
    CALL PUSHREAL8(temp1d)
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((und*temp1+un*temp1d)*a2neg+un*temp1*a2negd)
    temp2 = 0.5d0*un*temp1*a2neg
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    tempb5 = -(rho*0.5d0*gyndb(4))
    tempb4 = rhod*gyndb(4)
    tempb3 = rho*gynb(4)
    rhob = (temp2d-0.5d0*(temp1d*b2+temp1*b2d))*gyndb(4) + (temp2-0.5d0*&
&     (temp1*b2))*gynb(4)
    temp2b = tempb4 + tempb3
    temp1b = b2d*tempb5 - 0.5d0*b2*tempb4 - 0.5d0*b2*tempb3
    b2b = temp1d*tempb5 - 0.5d0*temp1*tempb4 - 0.5d0*temp1*tempb3
    gynb(4) = 0.D0
    rhodb = (temp2-0.5d0*(temp1*b2))*gyndb(4)
    temp2db = rho*gyndb(4)
    temp1db = b2*tempb5
    b2db = temp1*tempb5
    gyndb(4) = 0.D0
    pr_by_rhob = 6.0d0*temp1b
    u_sqrb = temp1b
    temp1 = 7.0d0*pr_by_rho + u_sqr
    pr_by_rhodb = 6.0d0*temp1db
    u_sqrdb = temp1db
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    tempb6 = 0.5d0*a2neg*temp2b
    tempb8 = 0.5d0*temp2db
    a2negb = (und*temp1+un*temp1d)*tempb8 + 0.5d0*un*temp1*temp2b
    tempb7 = a2neg*tempb8
    temp1b = und*tempb7 + a2negd*un*tempb8 + un*tempb6
    undb = temp1*tempb7
    temp1db = un*tempb7
    a2negdb = un*temp1*tempb8
    pr_by_rhob = pr_by_rhob + 7.0d0*temp1b
    u_sqrb = u_sqrb + temp1b
    pr_by_rhodb = pr_by_rhodb + 7.0d0*temp1db
    u_sqrdb = u_sqrdb + temp1db
    temp1b = rhod*gyndb(2) + rho*gynb(2)
    temp1db = rho*gyndb(2)
    tempb9 = a2neg*temp1db
    unb = temp1d*tempb7 + a2negd*temp1*tempb8 + utd*tempb9 + a2negd*ut*&
&     temp1db + a2neg*ut*temp1b + temp1*tempb6
    CALL POPREAL8(temp1d)
    temp1 = ut*un*a2neg - ut*b2
    rhob = rhob + temp1d*gyndb(2) + temp1*gynb(2)
    gynb(2) = 0.D0
    rhodb = rhodb + temp1*gyndb(2)
    gyndb(2) = 0.D0
    utb = und*tempb9 + (a2negd*un-b2d)*temp1db + 2*utd*u_sqrdb + 2*ut*&
&     u_sqrb + (a2neg*un-b2)*temp1b
    utdb = 2*ut*u_sqrdb - b2*temp1db + un*tempb9
    temp1 = pr_by_rho + un*un
    temp2 = temp1*a2neg - un*b2
    temp2b = rhod*gyndb(3) + rho*gynb(3)
    temp1d = pr_by_rhod + und*un + un*und
    temp2d = temp1d*a2neg + temp1*a2negd - und*b2 - un*b2d
    rhob = rhob + temp2d*gyndb(3) + temp2*gynb(3)
    gynb(3) = 0.D0
    rhodb = rhodb + temp2*gyndb(3)
    temp2db = rho*gyndb(3)
    gyndb(3) = 0.D0
    tempb12 = rho*gynb(1)
    tempb10 = rhod*gyndb(1)
    b2b = b2b - utd*temp1db - und*temp2db - tempb10 - tempb12 - un*&
&     temp2b - ut*temp1b
    tempb11 = rho*gyndb(1)
    a2negb = a2negb + (utd*un+ut*und)*temp1db + temp1d*temp2db + un*&
&     tempb10 + und*tempb11 + un*tempb12 + temp1*temp2b + ut*un*temp1b
    a2negdb = a2negdb + temp1*temp2db + un*tempb11 + ut*un*temp1db
    b2db = b2db - un*temp2db - tempb11 - ut*temp1db
    temp1b = a2negd*temp2db + a2neg*temp2b
    temp1db = a2neg*temp2db
    undb = undb + a2neg*tempb11 - b2*temp2db + 2*un*u_sqrdb + 2*un*&
&     temp1db + ut*tempb9
    unb = unb + 2*und*temp1db - b2d*temp2db + a2neg*tempb10 + a2negd*&
&     tempb11 + 2*und*u_sqrdb + 2*un*u_sqrb + a2neg*tempb12 + 2*un*&
&     temp1b - b2*temp2b
    pr_by_rhob = pr_by_rhob + temp1b
    pr_by_rhodb = pr_by_rhodb + temp1db
    tempb13 = pr_by_rhodb/rho**2
    rhob = rhob + (und*a2neg+un*a2negd-b2d)*gyndb(1) + (prd-(prd*rho-pr*&
&     rhod)*2/rho)*tempb13 - pr*pr_by_rhob/rho**2 + (un*a2neg-b2)*gynb(1&
&     )
    gynb(1) = 0.D0
    rhodb = rhodb + (un*a2neg-b2)*gyndb(1) - pr*tempb13
    gyndb(1) = 0.D0
    prb = pr_by_rhob/rho - rhod*tempb13
    prdb = rho*tempb13
    result1b = -(0.5d0*a2negb)
    result1db = -(0.5d0*a2negdb)
    CALL ADSTACK_STARTREPEAT()
    CALL POPREAL8(s2)
    CALL POPREAL8(result1)
    CALL ADSTACK_RESETREPEAT()
    CALL ADSTACK_ENDREPEAT()
    s2b = 0.D0
    CALL DERF_B(s2, s2b, result1b)
    CALL POPREAL8(s2)
    CALL POPREAL8(result1)
    CALL POPREAL8(result1d)
    temp6 = SQRT(pi)
    tempb14 = 0.5d0*b2b/result1
    tempb15 = b2db/result1**2
    temp5 = DEXP(-(s2**2))
    temp3 = s2d*s2 + s2*s2d
    tempb17 = -(0.5d0*temp5*tempb15)
    tempb16 = result1*tempb17
    s2b = s2b + (DEXP(-(s2**2))*result1d*0.5d0*2*s2+DEXP(-(s2**2))*temp3&
&     *result1*0.5d0*2*s2)*tempb15 - DEXP(-(s2**2))*2*s2*tempb14 + 2*s2d&
&     *tempb16 - DEXP(-(s2**2))*s2d*2.d0*2*s2*result1db/temp6
    s2db = 2*s2*tempb16 + DEXP(-(s2**2))*2.d0*result1db/temp6
    temp4 = DEXP(-(s2**2))
    result1b = temp3*tempb17 - (-(0.5d0*(temp3*result1*temp5))-0.5d0*(&
&     temp4*result1d))*2*tempb15/result1 - DEXP(-(s2**2))*tempb14/&
&     result1
    result1db = -(0.5d0*temp4*tempb15)
    CALL POPREAL8(result1)
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.D0*DSQRT(arg1))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(result1d)
      arg1db = 0.0_8
    ELSE
      CALL POPREAL8(result1d)
      temp0 = DSQRT(arg1)
      tempb2 = result1db/(2.d0*temp0)
      arg1db = tempb2
      IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb2/(temp0*2.D0*&
&         DSQRT(arg1))
    END IF
    result1b = und*s2db + un*s2b
    IF (beta .EQ. 0.0) THEN
      betab = pi*arg1b
    ELSE
      betab = result1b/(2.D0*DSQRT(beta)) + pi*arg1b
    END IF
    betadb = pi*arg1db
    unb = unb + result1d*s2db + result1*s2b
    undb = undb + result1*s2db
    result1db = un*s2db
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      temp = DSQRT(beta)
      tempb1 = result1db/(2.d0*temp)
      betadb = betadb + tempb1
      IF (.NOT.beta .EQ. 0.0) betab = betab - betad*tempb1/(temp*2.D0*&
&         DSQRT(beta))
    END IF
    tyb = u2d*utdb + u2*utb
    txb = u1d*utdb + u1*utb
    tempb0 = betadb/pr**2
    tempb = 0.5d0*betab/pr
    rhob = rhob + tempb - 0.5d0*prd*tempb0
    prb = prb + (0.5d0*rhod-(0.5d0*(rhod*pr)-0.5d0*(rho*prd))*2/pr)*&
&     tempb0 - rho*tempb/pr
    rhodb = rhodb + 0.5d0*pr*tempb0
    prdb = prdb - 0.5d0*rho*tempb0
    u1b = tx*utb + nx*unb
    nxb = nxb + u1d*undb - tyb + u1*unb
    u2b = ty*utb + ny*unb
    nyb = nyb + u2d*undb + txb + u2*unb
    u1db = tx*utdb + nx*undb
    u2db = ty*utdb + ny*undb
  END SUBROUTINE FLUX_GYN_D_B

!  Differentiation of flux_gyn in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: gyn
!   with respect to varying inputs: gyn u1 u2 pr rho
  SUBROUTINE FLUX_GYN_D(gyn, gynd, nx, ny, u1, u1d, u2, u2d, rho, rhod, &
&   pr, prd)
    IMPLICIT NONE
    DOUBLE PRECISION :: gyn(4), u1, u2, rho, pr
    DOUBLE PRECISION :: gynd(4), u1d, u2d, rhod, prd
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: utd, und
    DOUBLE PRECISION :: beta, s2, b2, a2neg
    DOUBLE PRECISION :: betad, s2d, b2d, a2negd
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: temp1d, temp2d
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: pr_by_rhod, u_sqrd
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    INTRINSIC DSQRT
    INTRINSIC DEXP
    INTRINSIC SQRT
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    utd = tx*u1d + ty*u2d
    ut = u1*tx + u2*ty
    und = nx*u1d + ny*u2d
    un = u1*nx + u2*ny
    betad = (0.5d0*rhod*pr-0.5d0*rho*prd)/pr**2
    beta = 0.5d0*rho/pr
    IF (beta .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = betad/(2.d0*DSQRT(beta))
    END IF
    result1 = DSQRT(beta)
    s2d = und*result1 + un*result1d
    s2 = un*result1
    arg1d = pi*betad
    arg1 = pi*beta
    IF (arg1 .EQ. 0.0) THEN
      result1d = 0.d0
    ELSE
      result1d = arg1d/(2.d0*DSQRT(arg1))
    END IF
    result1 = DSQRT(arg1)
    b2d = (-(0.5d0*(s2d*s2+s2*s2d)*DEXP(-(s2*s2))*result1)-0.5d0*DEXP(-(&
&     s2*s2))*result1d)/result1**2
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
!result1d = DERF_D(s2, s2d, result1)
    result1d = DEXP(-(s2**2))*(2.d0/SQRT(pi))*s2d
    result1 = DERF(s2)
    a2negd = -(0.5d0*result1d)
    a2neg = 0.5d0*(1.0d0-result1)
    pr_by_rhod = (prd*rho-pr*rhod)/rho**2
    pr_by_rho = pr/rho
    u_sqrd = utd*ut + ut*utd + und*un + un*und
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    gynd(1) = rhod*(un*a2neg-b2) + rho*(und*a2neg+un*a2negd-b2d)
    gyn(1) = rho*(un*a2neg-b2)
    temp1d = pr_by_rhod + und*un + un*und
    temp1 = pr_by_rho + un*un
    temp2d = temp1d*a2neg + temp1*a2negd - und*b2 - un*b2d
    temp2 = temp1*a2neg - un*b2
    gynd(3) = rhod*temp2 + rho*temp2d
    gyn(3) = rho*temp2
    temp1d = (utd*un+ut*und)*a2neg + ut*un*a2negd - utd*b2 - ut*b2d
    temp1 = ut*un*a2neg - ut*b2
    gynd(2) = rhod*temp1 + rho*temp1d
    gyn(2) = rho*temp1
    temp1d = 7.0d0*pr_by_rhod + u_sqrd
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2d = 0.5d0*((und*temp1+un*temp1d)*a2neg+un*temp1*a2negd)
    temp2 = 0.5d0*un*temp1*a2neg
    temp1d = 6.0d0*pr_by_rhod + u_sqrd
    temp1 = 6.0d0*pr_by_rho + u_sqr
    gynd(4) = rhod*(temp2-0.5d0*temp1*b2) + rho*(temp2d-0.5d0*(temp1d*b2&
&     +temp1*b2d))
    gyn(4) = rho*(temp2-0.5d0*temp1*b2)
  END SUBROUTINE FLUX_GYN_D

  SUBROUTINE FLUX_GYN(gyn, nx, ny, u1, u2, rho, pr)
    IMPLICIT NONE
    DOUBLE PRECISION :: gyn(4), u1, u2, rho, pr
    DOUBLE PRECISION :: tx, ty, nx, ny, ut, un
    DOUBLE PRECISION :: beta, s2, b2, a2neg
    DOUBLE PRECISION :: temp1, temp2
    DOUBLE PRECISION :: pr_by_rho, u_sqr
    DOUBLE PRECISION :: result1
    REAL*8 :: arg1
    INTRINSIC DSQRT
    INTRINSIC DEXP
    EXTERNAL DERF
    DOUBLE PRECISION :: DERF
    tx = ny
    ty = -nx
    ut = u1*tx + u2*ty
    un = u1*nx + u2*ny
    beta = 0.5d0*rho/pr
    result1 = DSQRT(beta)
    s2 = un*result1
    arg1 = pi*beta
    result1 = DSQRT(arg1)
    b2 = 0.5d0*DEXP(-(s2*s2))/result1
    result1 = DERF(s2)
    a2neg = 0.5d0*(1.0d0-result1)
    pr_by_rho = pr/rho
    u_sqr = ut*ut + un*un
!		Expressions for the split fluxes ..	
    gyn(1) = rho*(un*a2neg-b2)
    temp1 = pr_by_rho + un*un
    temp2 = temp1*a2neg - un*b2
    gyn(3) = rho*temp2
    temp1 = ut*un*a2neg - ut*b2
    gyn(2) = rho*temp1
    temp1 = 7.0d0*pr_by_rho + u_sqr
    temp2 = 0.5d0*un*temp1*a2neg
    temp1 = 6.0d0*pr_by_rho + u_sqr
    gyn(4) = rho*(temp2-0.5d0*temp1*b2)
  END SUBROUTINE FLUX_GYN

END MODULE SPLIT_FLUXES_MOD_DIFF_DIFF

