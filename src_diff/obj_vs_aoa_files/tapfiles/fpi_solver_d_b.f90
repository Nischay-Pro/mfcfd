!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7079) -  5 Oct 2018 09:56
!
MODULE FPI_SOLVER_MOD_DIFF_DIFF
  USE DATA_STRUCTURE_MOD_DIFF_DIFF
  USE FLUX_RESIDUAL_MOD_DIFF_DIFF
  USE STATE_UPDATE_MOD_DIFF_DIFF
  USE Q_VARIABLES_MOD_DIFF_DIFF
  USE OBJECTIVE_FUNCTION_MOD_DIFF_DIFF
  IMPLICIT NONE

CONTAINS
!  Differentiation of fpi_solver_d in reverse (adjoint) mode (with options fixinterface):
!   gradient     of useful results: pointd.prim pointd.prim_old
!                pointd.flux_res pointd.q pointd.dq pointd.qm pointd.delta
!                cmd cdd point.x point.y point.nx point.ny point.prim
!                point.prim_old point.flux_res point.q point.dq
!                point.qm point.delta cld
!   with respect to varying inputs: pointd.prim pointd.prim_old
!                pointd.flux_res pointd.q pointd.dq pointd.qm pointd.delta
!                point.x point.y point.nx point.ny point.prim point.prim_old
!                point.flux_res point.q point.dq point.qm point.delta
!  Differentiation of fpi_solver in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: cd cl cm point.prim point.prim_old
!                point.flux_res point.q point.dq point.qm point.delta
!   with respect to varying inputs: q_inf theta point.prim point.prim_old
!                point.flux_res point.q point.dq point.qm point.delta
  SUBROUTINE FPI_SOLVER_D_B(t)
    IMPLICIT NONE
    INTEGER :: t, i, rk
    INTRINSIC DSQRT
    INTRINSIC DLOG10
    DOUBLE PRECISION :: result1
    DO i=1,local_points
      pointd%prim_old(:, i) = pointd%prim(:, i)
      point%prim_old(:, i) = point%prim(:, i)
    END DO
    CALL FUNC_DELTA_D()
! Perform 4-stage, 3-order SSPRK update
    DO rk=1,rks
      CALL PUSHREAL8ARRAY(point%q, 4*max_points)
      CALL PUSHREAL8ARRAY(pointd%q, 4*max_points)
      CALL EVAL_Q_VARIABLES_D()
      CALL PUSHREAL8ARRAY(point%qm, 2*4*max_points)
      CALL PUSHREAL8ARRAY(point%dq, 2*4*max_points)
      CALL PUSHREAL8ARRAY(pointd%qm, 2*4*max_points)
      CALL PUSHREAL8ARRAY(pointd%dq, 2*4*max_points)
      CALL EVAL_Q_DERIVATIVES_D()
      CALL PUSHREAL8ARRAY(point%flux_res, 4*max_points)
      CALL PUSHREAL8ARRAY(pointd%flux_res, 4*max_points)
      CALL CAL_FLUX_RESIDUAL_D()
      CALL PUSHREAL8ARRAY(point%prim, 4*max_points)
      CALL PUSHREAL8ARRAY(pointd%prim, 4*max_points)
      CALL STATE_UPDATE_D(rk)
    END DO
    CALL OBJECTIVE_FUNCTION_D_B()
    DO rk=rks,1,-1
      CALL POPREAL8ARRAY(pointd%prim, 4*max_points)
      CALL POPREAL8ARRAY(point%prim, 4*max_points)
      CALL STATE_UPDATE_D_B(rk)
      CALL POPREAL8ARRAY(pointd%flux_res, 4*max_points)
      CALL POPREAL8ARRAY(point%flux_res, 4*max_points)
      CALL CAL_FLUX_RESIDUAL_D_B()
      CALL POPREAL8ARRAY(pointd%dq, 2*4*max_points)
      CALL POPREAL8ARRAY(pointd%qm, 2*4*max_points)
      CALL POPREAL8ARRAY(point%dq, 2*4*max_points)
      CALL POPREAL8ARRAY(point%qm, 2*4*max_points)
      CALL EVAL_Q_DERIVATIVES_D_B()
      CALL POPREAL8ARRAY(pointd%q, 4*max_points)
      CALL POPREAL8ARRAY(point%q, 4*max_points)
      CALL EVAL_Q_VARIABLES_D_B()
    END DO
    CALL FUNC_DELTA_D_B()
    DO i=local_points,1,-1
      pointb%prim(:, i) = pointb%prim(:, i) + pointb%prim_old(:, i)
      pointb%prim_old(:, i) = 0.0_8
      pointdb%prim(:, i) = pointdb%prim(:, i) + pointdb%prim_old(:, i)
      pointdb%prim_old(:, i) = 0.0_8
    END DO
  END SUBROUTINE FPI_SOLVER_D_B

!  Differentiation of fpi_solver in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: cd cl cm point.prim point.prim_old
!                point.flux_res point.q point.dq point.qm point.delta
!   with respect to varying inputs: q_inf theta point.prim point.prim_old
!                point.flux_res point.q point.dq point.qm point.delta
  SUBROUTINE FPI_SOLVER_D(t)
    IMPLICIT NONE
    INTEGER :: t, i, rk
    INTRINSIC DSQRT
    INTRINSIC DLOG10
    DOUBLE PRECISION :: result1
    DO i=1,local_points
      pointd%prim_old(:, i) = pointd%prim(:, i)
      point%prim_old(:, i) = point%prim(:, i)
    END DO
    CALL FUNC_DELTA_D()
! Perform 4-stage, 3-order SSPRK update
    DO rk=1,rks
      CALL EVAL_Q_VARIABLES_D()
      CALL EVAL_Q_DERIVATIVES_D()
      CALL CAL_FLUX_RESIDUAL_D()
      CALL STATE_UPDATE_D(rk)
    END DO
    CALL OBJECTIVE_FUNCTION_D()
    result1 = DSQRT(sum_res_sqr)
    res_new = result1/plen
    IF (t .LE. 2) THEN
      res_old = res_new
      residue = 0.d0
    ELSE
      residue = DLOG10(res_new/res_old)
    END IF
  END SUBROUTINE FPI_SOLVER_D

  SUBROUTINE FPI_SOLVER(t)
    IMPLICIT NONE
    INTEGER :: t, i, rk
    INTRINSIC DSQRT
    INTRINSIC DLOG10
    DOUBLE PRECISION :: result1
    DO i=1,local_points
      point%prim_old(:, i) = point%prim(:, i)
    END DO
    CALL FUNC_DELTA()
! Perform 4-stage, 3-order SSPRK update
    DO rk=1,rks
      CALL EVAL_Q_VARIABLES()
      CALL EVAL_Q_DERIVATIVES()
      CALL CAL_FLUX_RESIDUAL()
      CALL STATE_UPDATE(rk)
    END DO
    CALL OBJECTIVE_FUNCTION()
    result1 = DSQRT(sum_res_sqr)
    res_new = result1/plen
    IF (t .LE. 2) THEN
      res_old = res_new
      residue = 0.d0
    ELSE
      residue = DLOG10(res_new/res_old)
    END IF
  END SUBROUTINE FPI_SOLVER

END MODULE FPI_SOLVER_MOD_DIFF_DIFF

