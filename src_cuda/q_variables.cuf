module q_variables_mod
       
        use device_data_structure_mod

contains

        attributes(global) subroutine eval_q_variables(prim_d, q_d)

                        implicit none

                        ! device variables
                        real*8 :: prim_d(:,:), q_d(:,:)
                        ! local variables
                        integer :: i
                        real*8 :: rho, u1, u2, pr, beta
                        real*8 :: two_times_beta

                        i = (blockIdx%x-1)* blockDim%x + threadIdx%x

                        if(i > mp_d) return

                        rho = prim_d(1,i)
                        u1 = prim_d(2,i)
                        u2 = prim_d(3,i)
                        pr = prim_d(4,i)

                        beta = 0.5d0*rho/pr

                        q_d(1,i) = dlog(rho) + (dlog(beta)*2.5d0) - beta*(u1*u1 + u2*u2)

                        two_times_beta = 2.0d0*beta

                        q_d(2,i) = two_times_beta*u1

                        q_d(3,i) = two_times_beta*u2

                        q_d(4,i) = -two_times_beta

        end subroutine

        attributes(global) subroutine eval_q_derivatives(x_d, nbhs_d, conn_d, q_d, qm_d, dq_d)

                implicit none

                ! device variables
                real*8 :: q_d(:,:), dq_d(:,:,:), qm_d(:,:,:)
                integer :: nbhs_d(:), conn_d(:,:)
                real*8 :: x_d(:,:)
                ! local variables
                integer :: i
                integer :: k, r, nbh
                real*8 :: x_i, y_i, x_k, y_k
                real*8 :: delx, dely, dist, weights
                real*8 :: sum_delx_sqr, sum_dely_sqr, sum_delx_dely
                real*8 :: sum_delx_delq(4), sum_dely_delq(4)
                real*8 :: det, delq, temp
                real*8 :: one_by_det

                i = (blockIdx%x-1)* blockDim%x + threadIdx%x

                if(i > mp_d) return

                x_i = x_d(1,i)
                y_i = x_d(2,i)

                sum_delx_sqr = 0.d0
                sum_dely_sqr = 0.d0
                sum_delx_dely = 0.d0

                sum_delx_delq = 0.d0
                sum_dely_delq = 0.d0

		qm_d(1, :, i) = q_d(:, i)
		qm_d(2, :, i) = q_d(:, i)

                do k = 1, nbhs_d(i)

                        nbh = conn_d(i,k)
			
			do r = 1, 4
				if(q_d(r, nbh) > qm_d(1, r, i)) then
					qm_d(1, r, i) = q_d(r, nbh)
				endif
				if(q_d(r, nbh) < qm_d(2, r, i)) then
					qm_d(2, r, i) = q_d(r, nbh)
				endif
			end do
                        
			x_k = x_d(1,nbh)
                        y_k = x_d(2,nbh)

                        delx = x_k - x_i
                        dely = y_k - y_i

                        dist = dsqrt(delx*delx + dely*dely)
                        weights = dist**power_d

                        sum_delx_sqr = sum_delx_sqr + delx*delx*weights
                        sum_dely_sqr = sum_dely_sqr + dely*dely*weights

                        sum_delx_dely = sum_delx_dely + delx*dely*weights

                        sum_delx_delq = sum_delx_delq + weights*delx*(q_d(:,nbh) - q_d(:,i))
                        sum_dely_delq = sum_dely_delq + weights*dely*(q_d(:,nbh) - q_d(:,i))

                enddo

                det = sum_delx_sqr*sum_dely_sqr - sum_delx_dely*sum_delx_dely
                one_by_det = 1.0d0/det

                dq_d(1,:,i) = (sum_delx_delq*sum_dely_sqr&
                       & - sum_dely_delq*sum_delx_dely)*one_by_det
                dq_d(2,:,i) = (sum_dely_delq*sum_delx_sqr&
                                       &- sum_delx_delq*sum_delx_dely)*one_by_det

        end subroutine

end module q_variables_mod
